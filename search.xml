<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>408真题</title>
    <url>/2023/11/27/408%E7%9C%9F%E9%A2%98/</url>
    <content><![CDATA[<h2 id="边角知识">边角知识</h2>
<h3 id="海明码">海明码</h3>
<p>原理先不深究了，先记住校验位的计算，以及如何校验</p>
<h4 id="校验位确认">校验位确认</h4>
<p>校验位的个数k要满足<span class="math inline">\(2^k-1 \ge n +
k\)</span>，即k个二进制位要能够表示数据位加校验位错误位的情况以及没有错的情况。</p>
<p>假如原数据从低到高为1010 110，则校验位需要4位，记为<span class="math inline">\(p_0,p_1,p_2,p_3\)</span>，对应放在<span class="math inline">\(2^i\)</span>处，即</p>
<table>
<colgroup>
<col style="width: 9%">
<col style="width: 9%">
<col style="width: 9%">
<col style="width: 9%">
<col style="width: 9%">
<col style="width: 9%">
<col style="width: 9%">
<col style="width: 9%">
<col style="width: 9%">
<col style="width: 9%">
<col style="width: 9%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">1</th>
<th style="text-align: center;">2</th>
<th style="text-align: center;">3</th>
<th style="text-align: center;">4</th>
<th style="text-align: center;">5</th>
<th style="text-align: center;">6</th>
<th style="text-align: center;">7</th>
<th style="text-align: center;">8</th>
<th style="text-align: center;">9</th>
<th style="text-align: center;">10</th>
<th style="text-align: center;">11</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(p_0\)</span></td>
<td style="text-align: center;"><span class="math inline">\(p_1\)</span></td>
<td style="text-align: center;"><span class="math inline">\(D_1\)</span></td>
<td style="text-align: center;"><span class="math inline">\(p_2\)</span></td>
<td style="text-align: center;"><span class="math inline">\(D_2\)</span></td>
<td style="text-align: center;"><span class="math inline">\(D_3\)</span></td>
<td style="text-align: center;"><span class="math inline">\(D_4\)</span></td>
<td style="text-align: center;"><span class="math inline">\(p_3\)</span></td>
<td style="text-align: center;"><span class="math inline">\(D_5\)</span></td>
<td style="text-align: center;"><span class="math inline">\(D_6\)</span></td>
<td style="text-align: center;"><span class="math inline">\(D_7\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;">待求</td>
<td style="text-align: center;">待求</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">待求</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">待求</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
</tr>
</tbody>
</table>
<p>求<span class="math inline">\(p_i\)</span>的方法是将位置二进制表示下<span class="math inline">\(i+1\)</span>位为1的所有数异或结果为0，例如求<span class="math inline">\(p_1\)</span>，就是将所有二进制下2位为1的数据异或使其为0，就能得到所求的<span class="math inline">\(p_1\)</span>。</p>
<table>
<colgroup>
<col style="width: 10%">
<col style="width: 10%">
<col style="width: 8%">
<col style="width: 10%">
<col style="width: 8%">
<col style="width: 8%">
<col style="width: 8%">
<col style="width: 10%">
<col style="width: 8%">
<col style="width: 8%">
<col style="width: 8%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">0001</th>
<th style="text-align: center;">0010</th>
<th style="text-align: center;">0011</th>
<th style="text-align: center;">0100</th>
<th style="text-align: center;">0101</th>
<th style="text-align: center;">0110</th>
<th style="text-align: center;">0111</th>
<th style="text-align: center;">1000</th>
<th style="text-align: center;">1001</th>
<th style="text-align: center;">1010</th>
<th style="text-align: center;">1011</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(p_0\)</span></td>
<td style="text-align: center;"><span class="math inline">\(p_1\)</span></td>
<td style="text-align: center;">1</td>
<td style="text-align: center;"><span class="math inline">\(p_2\)</span></td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;"><span class="math inline">\(p_3\)</span></td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
</tr>
</tbody>
</table>
<p><span class="math inline">\(p_1 \bigoplus 1 \bigoplus 1 \bigoplus 0
\bigoplus1=0\)</span>，<span class="math inline">\(p_1=1\)</span>，同理可得<span class="math inline">\(p_0=0, p_2=1, p_3=0\)</span>。</p>
<h4 id="检错">检错</h4>
<p>检错时根据构造好的数据，同样在位置二进制表示下进行计算，<span class="math inline">\(s_i,\ i=0, 1, 2,3\)</span>分别用二进制下第<span class="math inline">\(i+1\)</span>位为1的数异或得到。例如下边的数据</p>
<table style="width:100%;">
<colgroup>
<col style="width: 6%">
<col style="width: 6%">
<col style="width: 6%">
<col style="width: 6%">
<col style="width: 6%">
<col style="width: 6%">
<col style="width: 6%">
<col style="width: 6%">
<col style="width: 6%">
<col style="width: 6%">
<col style="width: 6%">
<col style="width: 6%">
<col style="width: 6%">
<col style="width: 6%">
<col style="width: 6%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">0001</th>
<th style="text-align: center;">0010</th>
<th style="text-align: center;">0011</th>
<th style="text-align: center;">0100</th>
<th style="text-align: center;">0101</th>
<th style="text-align: center;">0110</th>
<th style="text-align: center;">0111</th>
<th style="text-align: center;">1000</th>
<th style="text-align: center;">1001</th>
<th style="text-align: center;">1010</th>
<th style="text-align: center;">1011</th>
<th style="text-align: center;">1100</th>
<th style="text-align: center;">1101</th>
<th style="text-align: center;">1110</th>
<th style="text-align: center;">1111</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">1</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">5</td>
<td style="text-align: center;">6</td>
<td style="text-align: center;">7</td>
<td style="text-align: center;">8</td>
<td style="text-align: center;">9</td>
<td style="text-align: center;">10</td>
<td style="text-align: center;">11</td>
<td style="text-align: center;">12</td>
<td style="text-align: center;">13</td>
<td style="text-align: center;">14</td>
<td style="text-align: center;">15</td>
</tr>
<tr class="even">
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
</tr>
</tbody>
</table>
<p><span class="math inline">\(s_0=1\bigoplus 0 \bigoplus 1 \bigoplus 1
\bigoplus 1 \bigoplus 1 \bigoplus 1 = 0\)</span></p>
<p><span class="math inline">\(s_1 = 0\)</span></p>
<p><span class="math inline">\(s_2 = 0\)</span></p>
<p><span class="math inline">\(s_3=1\)</span></p>
<p>因此，错误位为1000B， 即第8位。</p>
<h2 id="数据结构部分">数据结构部分</h2>
<h3 id="年">2009年</h3>
<ul>
<li><ol start="41" type="1">
<li>该方法不能求得最短路径。</li>
</ol>
<p>设初始顶点为1,目标顶点为4,欲求从顶点1到顶点4之间的最短路径，显然
这两点之间的最短路径长度为2。利用给定方法求得的路径长度为3,但这条路径并不是这
两点之间的最短路径。</p>
<p><img src="https://p.sda1.dev/14/52025298fed74a362eef79a5fe8f8e46/1.png" alt="1.png" style="zoom:80%;"></p></li>
<li><ol start="42" type="1">
<li></li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LNode</span> *link;</span><br><span class="line">&#125; *LinkList;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find_k</span><span class="params">(LinkList list, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkList p, q;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    p = q = list-&gt;link;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt &lt; k) cnt++;</span><br><span class="line">        <span class="keyword">else</span> q = q-&gt;link;</span><br><span class="line">        p = p-&gt;link;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt &lt; k) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 链表长度小于k, 查找失败</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; q-&gt;data &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 查找成功</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="年-1">2010年</h3>
<ul>
<li><ol start="41" type="1">
<li>(1). 装填因子为0.7，则散列表长度为10，所构造散列表为</li>
</ol>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">0</th>
<th style="text-align: center;">1</th>
<th style="text-align: center;">2</th>
<th style="text-align: center;">3</th>
<th style="text-align: center;">4</th>
<th style="text-align: center;">5</th>
<th style="text-align: center;">6</th>
<th style="text-align: center;">7</th>
<th style="text-align: center;">8</th>
<th style="text-align: center;">9</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">7</td>
<td style="text-align: center;">14</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">8</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">11</td>
<td style="text-align: center;">30</td>
<td style="text-align: center;">18</td>
<td style="text-align: center;">9</td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<p>(2). 查找成功的平均查找长度为<span class="math inline">\(\frac{1}{7}\times (1 + 2 + 1 + 1 + 1 + 3 + 3) =
\frac{12}{7}\)</span></p>
<p>查找失败的平均查找长度为<span class="math inline">\(\frac{1}{7}(3+2+1+2+1+5+4)=\frac{18}{7}\)</span>。</p></li>
<li><ol start="42" type="1">
<li></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> a[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = l, j = r;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = t;</span><br><span class="line">        i++, j--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">leftShift</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> n, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">reverse</span>(<span class="number">0</span>, n<span class="number">-1</span>, a);</span><br><span class="line">    <span class="built_in">reverse</span>(<span class="number">0</span>, n-p<span class="number">-1</span>, a);</span><br><span class="line">    <span class="built_in">reverse</span>(n-p, n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="年-2">2011年</h3>
<ul>
<li><ol start="42" type="1">
<li></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 遍历两个数组，记录遍历元素的个数，到中间时处理边界，求中位数 O(n)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums1.<span class="built_in">size</span>(), m = nums2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> k = (n + m) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> m % <span class="number">2</span> ? nums2[k] : (nums2[k<span class="number">-1</span>] + nums2[k]) / <span class="number">2.0</span>;</span><br><span class="line">        <span class="keyword">if</span>(m == <span class="number">0</span>) <span class="keyword">return</span> n % <span class="number">2</span> ? nums1[k] : (nums1[k<span class="number">-1</span>] + nums1[k]) / <span class="number">2.0</span>;</span><br><span class="line">        <span class="type">double</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l = <span class="number">0</span>; l &lt; k - <span class="number">1</span>; l++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; n &amp;&amp; j &lt; m &amp;&amp; nums1[i] &lt;= nums2[j]) i++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i &lt; n &amp;&amp; j &lt; m &amp;&amp; nums1[i] &gt; nums2[j]) j++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i &lt; n) i++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j &lt; m) j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>((n + m) % <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; n &amp;&amp; j &lt; m &amp;&amp; nums1[i] &lt;= nums2[j]) i++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i &lt; n &amp;&amp; j &lt; m &amp;&amp; nums1[i] &gt; nums2[j]) j++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i &lt; n) i++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j &lt; m) j++;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; n &amp;&amp; j &lt; m) res = <span class="built_in">min</span>(nums1[i], nums2[j]);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i &lt; n) res = nums1[i];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j &lt; m) res = nums2[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; j &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">if</span>(i == n<span class="number">-1</span> || j == m<span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i &lt; n - <span class="number">1</span>) res = <span class="built_in">min</span>(nums1[i] + nums1[i+<span class="number">1</span>], nums1[i] + nums2[j]) / <span class="number">2.0</span>;</span><br><span class="line">                <span class="keyword">if</span>(j &lt; m - <span class="number">1</span>) res = <span class="built_in">min</span>(nums2[j] + nums2[j+<span class="number">1</span>], nums1[i] + nums2[j]) / <span class="number">2.0</span>;</span><br><span class="line">                res = res == <span class="number">0</span> ? (nums1[i] + nums2[j]) / <span class="number">2.0</span> : res;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i &gt;= n || j &gt;= m)</span><br><span class="line">            &#123;</span><br><span class="line">                res = i &gt;= n ? (nums2[j] + nums2[j+<span class="number">1</span>]) / <span class="number">2.0</span> : (nums1[i] + nums1[i+<span class="number">1</span>]) / <span class="number">2.0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                res = <span class="built_in">min</span>(<span class="built_in">min</span>(nums1[i] + nums1[i+<span class="number">1</span>], nums2[j] + nums2[j+<span class="number">1</span>]), nums1[i] + nums2[j]) / <span class="number">2.0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// O(logn)的做法，应该想不出来，放弃了</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, <span class="type">int</span> i, vector&lt;<span class="type">int</span>&gt;&amp; nums2, <span class="type">int</span> j, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums1.<span class="built_in">size</span>() - i &gt; nums2.<span class="built_in">size</span>() - j) <span class="keyword">return</span> <span class="built_in">find</span>(nums2, j, nums1, i, k);</span><br><span class="line">        <span class="keyword">if</span>(nums1.<span class="built_in">size</span>() == i) <span class="keyword">return</span> nums2[j+k<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">min</span>(nums1[i], nums2[j]);</span><br><span class="line">        <span class="type">int</span> si = <span class="built_in">min</span>(i + k / <span class="number">2</span>, (<span class="type">int</span>)nums1.<span class="built_in">size</span>()), sj = j + k - k / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums1[si<span class="number">-1</span>] &gt; nums2[sj<span class="number">-1</span>]) <span class="keyword">return</span> <span class="built_in">find</span>(nums1, i, nums2, sj, k - (sj - j));</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">find</span>(nums1, si, nums2, j, k - (si - i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> total = nums1.<span class="built_in">size</span>() + nums2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(total % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> left = <span class="built_in">find</span>(nums1, <span class="number">0</span>, nums2, <span class="number">0</span>, total / <span class="number">2</span>);</span><br><span class="line">            <span class="type">int</span> right = <span class="built_in">find</span>(nums1, <span class="number">0</span>, nums2, <span class="number">0</span>, total / <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> (left + right) / <span class="number">2.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> res = <span class="built_in">find</span>(nums1, <span class="number">0</span>, nums2, <span class="number">0</span>, total / <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> (<span class="type">double</span>)res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="年-3">2012年</h3>
<ul>
<li><ol start="41" type="1">
<li>(1).
根据构造哈夫曼树的思想，先将A和B合并，得到一个含有45个元素的表AB，然后将表AB和表C合并，得到一个含有85个元素的表ABC，再将表D和表E合并得到一个含有110个元素的表DE，之后将表ABC和表DE合并，得到一个含有195个元素的表ABCDE，最后将表ABCDE和表F合并得到一个含有395个元素的最终表。由于<mark>两个表合并时最多比较次数为n+m-1</mark>，所以最坏情况下比较的总次数为<span class="math inline">\(44 + 84 + 109 + 194 + 394=825\)</span>。</li>
</ol>
<p>(2).
各表的合并策略是：在对多个有序表进行两两合并时，若表长不同，则最坏情况下总的比较
次数依赖于表的合并次序。可以借用哈夫曼树的构造思想，依次选择最短的两个表进行合并,
可以获得最坏情况下最佳的合并效率。</p></li>
<li><ol start="42" type="1">
<li></li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 核心思想是遍历链表，让两个指针走过相同数目的节点个数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">findFirstCommonNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(headA==<span class="literal">NULL</span>||headB==<span class="literal">NULL</span>)<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        ListNode *pa = headA,*pb = headB;</span><br><span class="line">        <span class="keyword">while</span>(pa!=pb)&#123;</span><br><span class="line">            pa = pa==<span class="literal">NULL</span> ? headB : pa-&gt;next;</span><br><span class="line">            pb = pb==<span class="literal">NULL</span> ? headA : pb-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pa;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="年-4">2013年</h3>
<ul>
<li><ol start="41" type="1">
<li></li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 摩尔投票法</span></span><br><span class="line"><span class="comment">// 集合为空或者集合中只有主元，加入</span></span><br><span class="line"><span class="comment">// 如果不是主元且集合中有主元则带走一个主元</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">moreThanHalfNum_Solution</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>, val;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!cnt) val = x, cnt++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(val == x) cnt++;</span><br><span class="line">            <span class="keyword">else</span> cnt--;</span><br><span class="line">        &#125;</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(x == val) cnt ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt &lt; nums.<span class="built_in">size</span>() / <span class="number">2</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="年-5">2014年</h3>
<ul>
<li><ol start="41" type="1">
<li></li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">wpl</span><span class="params">(TreeNode *root, <span class="type">int</span> d)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> root-&gt;val * d;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">return</span> (<span class="built_in">wpl</span>(root-&gt;left, d+<span class="number">1</span>) + <span class="built_in">wpl</span>(root-&gt;right, d+<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pathSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">wpl</span>(root, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="年-6">2015年</h3>
<ul>
<li><ol start="41" type="1">
<li></li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单链表结点数据类型定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span> *next;</span><br><span class="line">&#125;NODE *Pnode;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(Pnode h, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Pnode p = h, r;</span><br><span class="line">    <span class="type">int</span> cnt[n+<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="built_in">sizeof</span>(cnt));</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x = p-&gt;next-&gt;val &gt; <span class="number">0</span> ? p-&gt;next-&gt;val : -p-&gt;next-&gt;val;</span><br><span class="line">        <span class="keyword">if</span>(cnt[m] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt[m] = <span class="number">1</span>;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            r = p-&gt;next;</span><br><span class="line">            p-&gt;next = r-&gt;next;</span><br><span class="line">            <span class="built_in">free</span>(r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="年-7">2016年</h3>
<ul>
<li><ol start="42" type="1">
<li>(1).
根据定义，正则k叉树结点的度要么为k要么为0，设度为0即页结点个数为<span class="math inline">\(n_0\)</span>，度为k的结点个数为<span class="math inline">\(n_k\)</span>，则有<span class="math inline">\(n_k
\times k + 1 = n_k + n_0\)</span>所以，<span class="math inline">\(n_0=(k-1)n_k+1=(k-1)m+1\)</span>。</li>
</ol>
<p>(2). 当T的结点数最多时，每个非页结点的度都为k，所以结点个数为<span class="math inline">\(\sum
\limits_{i=0}^{i=h-1}k^i=\frac{1-k^h}{1-k}=\frac{k^h-1}{k-1}\)</span>。当T的结点数最少时，除最后一层外，每一层只有一个结点的度为k，所以结点个数为<span class="math inline">\(1+k(h-1)\)</span></p></li>
<li><ol start="43" type="1">
<li>直接用快排吧，拿大部分分</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">q_sort</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> v = a[l + r &gt;&gt; <span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> i = i - <span class="number">1</span>, j = r + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span> i++; <span class="keyword">while</span>(a[i] &lt; v);</span><br><span class="line">        <span class="keyword">do</span> j--; <span class="keyword">while</span>(a[j] &gt; v);</span><br><span class="line">        <span class="keyword">if</span>(i &lt; j) <span class="built_in">swap</span>(a[i], a[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">q_sort</span>(a, l, j);</span><br><span class="line">    <span class="built_in">q_sort</span>(a, j+<span class="number">1</span>, r); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="年-8">2017年</h3>
<ul>
<li><ol start="41" type="1">
<li>答案的写法好啊</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BtreeToE</span><span class="params">(BTree *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">BtreeToExp</span>(root, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BtreeToExp</span><span class="params">(Btree *root, <span class="type">int</span> deep)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, root-&gt;data); <span class="comment">// 如果是页结点则直接输出</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(deep &gt; <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;(&quot;</span>);</span><br><span class="line">        <span class="built_in">BtreeToExp</span>(root-&gt;left, deep+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, root-&gt;data);</span><br><span class="line">        <span class="built_in">BtreeToExp</span>(root-&gt;right, deep+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">BtreeToExp</span>(root-&gt;right, deep+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(deep &gt; <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="年-9">2018年</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find_miss_min</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt[n+<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="built_in">sizeof</span>(cnt));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] &gt; <span class="number">0</span> &amp;&amp; a[i] &lt;= n)</span><br><span class="line">            cnt[a[i] - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt[i] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="年-10">2019年</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rearrangedList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head-&gt;next)<span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(ListNode *h=head;h;h=h-&gt;next)</span><br><span class="line">            n++;</span><br><span class="line">        <span class="type">int</span> mid = (n + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        ListNode *a = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;mid<span class="number">-1</span>;i++)</span><br><span class="line">            a = a-&gt;next;</span><br><span class="line">        ListNode *b = a-&gt;next, *c = b-&gt;next;</span><br><span class="line">        a-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        b-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(c)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode *t = c-&gt;next;</span><br><span class="line">            c-&gt;next = b;</span><br><span class="line">            b = c;</span><br><span class="line">            c = t;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *p = head;</span><br><span class="line">        <span class="keyword">while</span>(b)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode *o = b-&gt;next;</span><br><span class="line">            b-&gt;next = p-&gt;next;</span><br><span class="line">            p-&gt;next = b;</span><br><span class="line">            p = p-&gt;next-&gt;next;</span><br><span class="line">            b = o;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="年-11">2020年</h3>
<ul>
<li><ol start="41" type="1">
<li></li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N], b[N], c[N];</span><br><span class="line"><span class="type">int</span> l, m, n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;l, &amp;m, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;l;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;b[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;c[i]);</span><br><span class="line">    </span><br><span class="line">    LL res =<span class="number">1e18</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>, k=<span class="number">0</span>;i&lt;l&amp;&amp;j&lt;m&amp;&amp;k&lt;n;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x = a[i], y = b[j], z = c[k];</span><br><span class="line">        res = <span class="built_in">min</span>(res, (LL)<span class="built_in">max</span>(<span class="built_in">max</span>(x, y), z) - (LL)<span class="built_in">min</span>(<span class="built_in">min</span>(x, y), z));</span><br><span class="line">        <span class="keyword">if</span>(x &lt;= y &amp;&amp; x &lt;= z) i++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(y &lt;= x &amp;&amp; y &lt;= z) j++;</span><br><span class="line">        <span class="keyword">else</span> k++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, res * <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="年-12">2021年</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 答案的代码</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">IsExistEL</span><span class="params">(MGraph G )</span></span>&#123;</span><br><span class="line">  <span class="comment">//记录度为奇数的顶点个数</span></span><br><span class="line">  <span class="type">int</span> count = <span class="number">0</span>; </span><br><span class="line">  <span class="comment">//暂存每个结点的度</span></span><br><span class="line">  <span class="type">int</span> row = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">    <span class="comment">//每行初始化为0 </span></span><br><span class="line">    row = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">for</span> <span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">      <span class="comment">//若邻接矩阵值为1，row代表的结点加1 </span></span><br><span class="line">      <span class="keyword">if</span>(G.edge[i][j]==<span class="number">1</span>)&#123;</span><br><span class="line">        row++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果度为奇数则记录</span></span><br><span class="line">    <span class="keyword">if</span>(row % <span class="number">2</span> == <span class="number">0</span>) count++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//若度数为奇数的count结点为0或者为2，则存在EL路径，否则不存在EL路径。</span></span><br><span class="line">  <span class="keyword">if</span> (count == <span class="number">0</span> || count == <span class="number">2</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="年-13">2022年</h3>
<ul>
<li><ol start="41" type="1">
<li>判断二叉搜索树</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">checkInoeder</span><span class="params">(TreeNode *root, <span class="type">long</span> <span class="type">long</span> low, <span class="type">long</span> <span class="type">long</span> up)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val &lt;= low || root-&gt;val &gt;= up) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">checkInoeder</span>(root-&gt;left, low, root-&gt;val) &amp;&amp; <span class="built_in">checkInoeder</span>(root-&gt;right, root-&gt;val, up);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">checkInoeder</span>(root, LONG_MIN, LONG_MAX);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="年-14">2023年</h2>
<h3 id="section">43</h3>
<ul>
<li><ol type="1">
<li>数组a起始虚拟地址是0042
2000H，页大小为4KB，页内偏移为4位，数组a恰在一个页面的起始位置，数组a大小为24*64*4，分布在2个页面中。会发生2次缺页异常。第一次页故障地址是0042
2000H，第二次页故障地址是0042 3000H。</li>
</ol></li>
<li><ol start="2" type="1">
<li>不具有时间局部性。因为对数组a的每个元素仅访问了一次。</li>
</ol></li>
<li><ol start="3" type="1">
<li>块大小为32B，按字节编址，则块内地址占5位，32位虚拟地址中低5位A4~A0表示。Cache采用4路组相连，数据区大小为8KB，Cache行数为：8KB/32B=<span class="math inline">\(2^8\)</span>行，组数为：<span class="math inline">\(2^6\)</span>，因此组号占6位，用A10-A5表示。</li>
</ol></li>
</ul>
<p>​ a[1][0]的虚拟地址是0042 2000H+(1*64+0)*4=0042 2100H。</p>
<p>​ 0042 2100H低12位二进制为：0001 0000 0000B，组号为001000B，即8。</p>
<ul>
<li><ol start="4" type="1">
<li>数组a占用主存块数为<span class="math inline">\(24*64*4/32=192\)</span>。一个Cache可存放数组元素8个，Cache共有256个Cache行，因此访问数组a时，只有每次访问Cache行的第一个元素时发生确实，所以命中率是<span class="math inline">\(\frac{8-1}{8}*100\%=87.5\%\)</span>。将i和j的次序调换，即按列优先访问，由于数据Cache能够存放所有元素，所以命中率不变，仍为87.5%。</li>
</ol></li>
</ul>
<h3 id="section-1">44</h3>
<ul>
<li><ol type="1">
<li>第19条指令虚拟地址为0040
10AEH，指令长度为11B，按字节编址，所以第20条指令的虚拟地址是0040
10AEH+11 = 0040 10B9H。</li>
</ol></li>
<li><ol start="2" type="1">
<li>这两条指令都采用相对寻址方式。第2条指令的跳转目标地址计算过程为：<span class="math inline">\(PC+2+09H=0040 1079H + 2 + 09H=0040
1084H\)</span>。</li>
</ol></li>
<li><ol start="3" type="1">
<li>源操作数采用变址寻址方式。<code>ecx</code>中存放的是i*256。计算机M采用小端存储方式。</li>
</ol></li>
<li><ol start="4" type="1">
<li>不会发生缺页异常。因为第19条指令和第一条指令的虚页号均为00401H，在同一页中，第一次执行第一条指令时发生缺页异常，进行异常处理后页面会调入内存，因此此时不会发生缺页异常。</li>
</ol></li>
</ul>
<h3 id="section-2">45</h3>
<ul>
<li><ol type="1">
<li>if (key == TRUE) swap key, lock; 错误，应改为:while (key == TRUE)
swap key, lock; lock = TRUE;错误，应改为: lock = FALSE;</li>
</ol></li>
<li><ol start="2" type="1">
<li>不能。因为函数调用执行过程不具有原子性，进行调用时可能会被其他进程打断，导致交换过程出错。</li>
</ol></li>
</ul>
<h3 id="section-3">47</h3>
<ul>
<li><ol type="1">
<li>操作1前一个操作是3，后一个操作是5。操作6的后一个操作是4。</li>
</ol></li>
<li><ol start="2" type="1">
<li>在操作2之后CPU一定从进程P切换到其他进程。操作1之后CPU才能选中进程P执行。</li>
</ol></li>
<li><ol start="3" type="1">
<li>完成操作3的代码属于键盘驱动程序。</li>
</ol></li>
<li><ol start="4" type="1">
<li>进程P处于阻塞态，CPU处于内核态。</li>
</ol></li>
</ul>
<p>​ （在系统调用返回之前将进程插入到就绪队列）</p>
<h3 id="section-4">48</h3>
<ul>
<li><ol type="1">
<li>控制连接是持久的。数据连接是非持久的。登录FTP服务器时，建立的TCP连接是控制连接。</li>
</ol></li>
<li><ol start="2" type="1">
<li>F的第一个字节的序号是101。在断开连接过程中，FTP服务器发送的第二次挥手ACK段的确认序号是18102。</li>
</ol></li>
<li><ol start="3" type="1">
<li>收到确认序号为2101的确认段时，H的拥塞窗口调整为3MSS。收到确认序号7101的确认段时，H的拥塞窗口调整为5MSS。</li>
</ol></li>
<li><ol start="4" type="1">
<li>至少需要6个RTT,即60ms。应用层数据平均发送速率是18000B/60ms=0.3MBps=2.4Mbps。</li>
</ol></li>
</ul>
<hr>
<h2 id="年-15">2022年</h2>
<h3 id="section-5">43</h3>
<ul>
<li><ol type="1">
<li><span class="math inline">\(SF=F_{15}\)</span>。</li>
</ol></li>
</ul>
<p>​ A加B时，真值表为：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"><span class="math inline">\(A_{15}\)</span></th>
<th style="text-align: center;"><span class="math inline">\(B_{15}\)</span></th>
<th style="text-align: center;"><span class="math inline">\(F_{15}\)</span></th>
<th style="text-align: center;"><span class="math inline">\(OF\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
</tr>
<tr class="even">
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
</tr>
<tr class="odd">
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
</tr>
<tr class="even">
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
</tr>
<tr class="odd">
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
</tr>
<tr class="even">
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
</tr>
<tr class="odd">
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
</tr>
<tr class="even">
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
</tr>
</tbody>
</table>
<p>所以，<span class="math inline">\(OF=\overline{A_{15}}\overline{B_{15}}F_{15}+A_{15}B_{15}\overline{F_{15}}\)</span></p>
<p>A减B时，真值表：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"><span class="math inline">\(A_{15}\)</span></th>
<th style="text-align: center;"><span class="math inline">\(B_{15}\)</span></th>
<th style="text-align: center;"><span class="math inline">\(F_{15}\)</span></th>
<th style="text-align: center;"><span class="math inline">\(OF\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
</tr>
<tr class="even">
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
</tr>
<tr class="odd">
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
</tr>
<tr class="even">
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
</tr>
<tr class="odd">
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
</tr>
<tr class="even">
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
</tr>
<tr class="odd">
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
</tr>
<tr class="even">
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
</tr>
</tbody>
</table>
<p><span class="math inline">\(OF=\overline{A_{15}}B_{15}F_{15}+A_{15}\overline{B_{15}}\overline{F_{15}}\)</span></p>
<ul>
<li><ol start="2" type="1">
<li>因为单总线结构中每一个时刻总线上总有一个数据有效，ALU有两个输入端和一个输出端，因而需要设置Y和Z两个暂存器，缓存ALU的一个输入端和输出端的数据。</li>
</ol></li>
<li><ol start="3" type="1">
<li>rd、rs为4为，因此GPRs中最多有<span class="math inline">\(2^4=16\)</span>个通用寄存器。rs和rd来自指令寄存器IR。rd应连接地址译码器。</li>
</ol></li>
<li><ol start="4" type="1">
<li>取指令阶段控制信号序列是1. PCout, MARin, 2. Read, 3. MDRout,
IRin。需要7个时钟周期。</li>
</ol></li>
<li><ol start="5" type="1">
<li>控制信号由控制段元CU产生。IR、FR的输出信号会连接到该部件的输入端。</li>
</ol></li>
</ul>
<h3 id="section-6">44</h3>
<ul>
<li><ol type="1">
<li>地址信息三个字段名称分别为磁道号、盘面号、扇区号。每个盘面有20000个磁道，因此磁道号至少为15位；有4个双面盘面，盘面号至少为3位；每个磁道有500个扇区，扇区号至少为9位。</li>
</ol></li>
<li><ol start="2" type="1">
<li>磁盘转速为7200RPM，一转用时<span class="math inline">\(\frac{60*1000}{7200}=\frac{25}{3}ms\)</span>，平均寻道时间是5ms，因此一个扇区的平均访问时间是<span class="math inline">\(5ms+\frac{25}{3}*\frac{1}{2}ms+\frac{25}{3}*\frac{1}{500}=9.18ms\)</span>。</li>
</ol></li>
<li><ol start="3" type="1">
<li>在一个扇区读写过程中，向CPU发送DMA总线请求次数为：<span class="math inline">\(\frac{512*8}{64}=64\)</span>次。</li>
</ol></li>
</ul>
<p>​
DMA控制器可以获得总线使用权，因为DMA控制的优先权比CPU高，否则会造成数据丢失。</p>
<h3 id="section-7">45</h3>
<ul>
<li><ol type="1">
<li>目录文件stu的目录项内容为：</li>
</ol></li>
</ul>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">文件名</th>
<th style="text-align: center;">索引节点号</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">course</td>
<td style="text-align: center;">2</td>
</tr>
<tr class="even">
<td style="text-align: center;">doc</td>
<td style="text-align: center;">10</td>
</tr>
</tbody>
</table>
<ul>
<li><ol start="2" type="1">
<li>文件doc和文件course1的索引节点号均为10，因此doc占用的磁盘块号和course1的相同，即x=30.</li>
</ol></li>
<li><ol start="3" type="1">
<li>需要读2个磁盘块。因为目录文件course的内容已经在内存中，因此可以在内存中找到文件course1的索引节点号10，然后存磁盘块30中读取索引节点信息，根据索引节点信息访问文件对应的磁盘块，因此需要访问2个磁盘块。</li>
</ol></li>
<li><ol start="4" type="1">
<li>文件系统磁盘块大小为4KB，目录项大小为4B。10个直接索引可表示的最大文件长度为40KB，直接索引和一级间接索引可表示的最大文件长度为：<span class="math inline">\(40KB+\frac{4KB}{4B}*4KB=40KB+4MB\)</span>;再加上二级间接索引可表示文件最大长度为：<span class="math inline">\(40KB+4MB+(\frac{4KB}{4B})^2*4KB=40KB+4MB+4GB\)</span>.因此存储6MB大小的文件需要用到一级和二级间接地址项。</li>
</ol></li>
</ul>
<h3 id="section-8">46</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Semaphore S_AC = <span class="number">0</span>; <span class="comment">// 实现A和C的同步</span></span><br><span class="line">Semaphore A_CE = <span class="number">0</span>; <span class="comment">// 实现C和E的同步</span></span><br><span class="line"></span><br><span class="line">T1 &#123; <span class="comment">// 线程T1</span></span><br><span class="line">    执行A;</span><br><span class="line">    <span class="built_in">signal</span>(S_AC);</span><br><span class="line">    <span class="built_in">wait</span>(S_CE);</span><br><span class="line">    执行E;</span><br><span class="line">    执行F；</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">T2 &#123; <span class="comment">// 线程T2</span></span><br><span class="line">    执行B;</span><br><span class="line">    <span class="built_in">wait</span>(S_AC);</span><br><span class="line">    执行C;</span><br><span class="line">    <span class="built_in">signa</span>(S_CE);</span><br><span class="line">    执行D;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="section-9">47</h3>
<ul>
<li><ol type="1">
<li>设备1选择100BaseT以太网交换机；设备2选择100BaseT集线器。</li>
</ol></li>
<li><ol start="2" type="1">
<li>最小帧发送时间为：<span class="math inline">\(\frac{64*8}{100*10^6}=5.12us\)</span>。因此征用期最小为<span class="math inline">\(2\tau=5.12us\)</span>，相距最远距离为：<span class="math inline">\(2*10^8 * (5.12 / 2 - 1.51)us=210m\)</span>。</li>
</ol></li>
<li><ol start="3" type="1">
<li>M是DHCP发现报文。路由器E0接口能够收到封装M的以太网帧。S向DHCP服务器转发的封装M的以太网帧的目的MAC地址是FF-FF-FF-FF-FF-FF-FF。</li>
</ol></li>
<li><ol start="4" type="1">
<li>地址1:00-11-11-11-11-E1，地址2: 00-11-11-11-11-C1,
地址3：00-11-11-11-11-D1。</li>
</ol></li>
</ul>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">去往AP</th>
<th style="text-align: center;">来自AP</th>
<th style="text-align: center;">地址1</th>
<th style="text-align: center;">地址2</th>
<th style="text-align: center;">地址3</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">接收地址=目的地址</td>
<td style="text-align: center;">发送地址=AP地址</td>
<td style="text-align: center;">源地址</td>
</tr>
<tr class="even">
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">接收地址=AP地址</td>
<td style="text-align: center;">发送地址=源地址</td>
<td style="text-align: center;">目的地址</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="年-16">2021年</h2>
<h3 id="section-10">43</h3>
<ul>
<li><ol type="1">
<li>ALU的宽度为16位。（ALU的宽度通常和机器字长相同）地址线为20位，因此可寻址主存空间大小为<span class="math inline">\(2^{20}B=1MB\)</span>。指令寄存器应有16位，主存地址寄存器应有20位，主存数据寄存器应有8位。</li>
</ol></li>
<li><ol start="2" type="1">
<li>R型格式最多可以定义<span class="math inline">\(2^4=16\)</span>种操作。I型和J型指令最多可定义<span class="math inline">\(2^6-1=63\)</span>种操作。通用寄存器最多有4个。</li>
</ol></li>
<li><ol start="3" type="1">
<li>01B2H二进制为：0000 0001 1011
0010B，op1=0010，为带符号整数减法，rs为01B，rt为10B，rd为11B，因此该指令的功能是<span class="math inline">\(R[3]\leftarrow R[1]-R[2]\)</span>
执行01B2H后，3号寄存器内容应为<span class="math inline">\(B052H-0008H=B04AH\)</span>，结果没有溢出。
执行01B3H后，3号寄存器内容应为<span class="math inline">\(B052H*0008H=8290H\)</span>,结果溢出。</li>
</ol></li>
<li>(4)<code>imm</code>应进行符号扩展。</li>
<li><ol start="5" type="1">
<li>无条件转移指令可以采用J型指令格式。</li>
</ol></li>
</ul>
<h3 id="section-11">44</h3>
<ul>
<li><ol type="1">
<li>页大小为4KB，按字节变址，因此页内地址占12位，所以虚拟地址的高18位是虚页号，低12位是页内地址。</li>
</ol></li>
<li><ol start="2" type="1">
<li>TLB采用2路组相连，有8组，因此组号占3位，TLB标记占18-3=15为，所以M的虚拟地址中高15位为TLB标记，低3位是TLB组号。</li>
</ol></li>
<li><ol start="3" type="1">
<li>虚页号10, 12, 16, 17, 26, 4, 12, 20对应TLB组号为2, 4, 0, 1, 2, 4, 4,
4。采用二路组相连时，先后访问虚页号12，4，12，20时会发生页面替换。才用LRU替换策略时，访问到续页号20时，组号4对应的TLB满，最近访问了12号虚页，因此应替换4号虚页，所以4号虚页对应的TLB表项被替换。</li>
</ol></li>
<li><ol start="4" type="1">
<li>虚拟地址位数增加到32位，TLB表项的位数应该增加2位。</li>
</ol></li>
</ul>
<h3 id="section-12">45</h3>
<ul>
<li><ol type="1">
<li>因为信号量S是被多个进程共享的变量，多个进程都能够通过wait()和signal()访问S，因此在wait()和signal()种需要互斥访问S。</li>
</ol></li>
<li><ol start="2" type="1">
<li>方法1错误，方法2正确。因为在方法1中wait()中，在<span class="math inline">\(S\le0\)</span>时，提前关闭了中断，由于signal()不能修改S，则会一直执行<span class="math inline">\(while(s\le0);\)</span>造成死循环。</li>
</ol></li>
<li><ol start="3" type="1">
<li>用户不能使用开关中断指令实现临界区互斥。因为开关中断指令是特权指令，只能运行在内核态，用户不能执行开关中断指令。</li>
</ol></li>
</ul>
<h3 id="section-13">46</h3>
<ul>
<li><ol type="1">
<li>执行顺序是<span class="math inline">\(ROM中的引导程序\rightarrow
磁盘引导程序 \rightarrow 分区引导程序 \rightarrow
操作系统初始化程序\)</span>。</li>
</ol></li>
<li><ol start="2" type="1">
<li>正确顺序是：<span class="math inline">\(磁盘的物理格式化 \rightarrow
对磁盘进行分区 \rightarrow 逻辑格式化 \rightarrow
操作系统的安装\)</span>。</li>
</ol></li>
<li><ol start="3" type="1">
<li>磁盘扇区的划分在对磁盘进行分区操作中完成。文件系统根目录建立在逻辑格式化中完成。</li>
</ol></li>
</ul>
<p>操作系统启动过程为:</p>
<ol type="1">
<li>激活CPU。激活的CPU读取ROM中的boot程序，将指令寄存器置为BIOS的第一条指令，开始执行BIOS的指令。</li>
<li>硬件自检。启动BIOS程序后，先进行硬件自检，检查硬件是否出现故障。</li>
<li>加载带有操作系统的硬盘。硬件自检后，BIOS开始读取Boot
Sequence，把控制权交给启动顺序排在第一位的存储设备，然后将该存储设备引导扇区的内容加载到内存中。</li>
<li>加载主引导记录MBR。硬盘以特定的标识符区分引导硬盘和非引导硬盘。如果发现一个存储设备不是引导盘，就检查下一个存储设备。主引导记录MBR的作用是告诉CPU去硬盘的哪个分区找操作系统。</li>
<li>扫描硬盘分区表，并加载硬盘活动分区。MBR包含硬盘分区表，硬盘分区表以特定的标识符区分活动分区和非活动分区。主引导记录扫描硬盘分区表，进而识别包含操作系统的硬盘分区。找到硬盘活动分区后，开始加载硬盘活动分区，将控制权交给活动分区。</li>
<li>加载分区引导记录PBR。读取活动分区的第一个扇区，这个扇区称为分区引导记录，作用是寻找并激活分区根目录下用于引导操作系统的程序。</li>
<li>加载启动管理器。</li>
<li>加载操作系统。</li>
</ol>
<h3 id="section-14">47</h3>
<ul>
<li><ol type="1">
<li>除HTTP外还运行了DNS协议。</li>
</ol>
<p>从应用层到数据链路层，该应用层协议报文逐层封装关系为: <span class="math inline">\(DNS报文 \rightarrow UDP数据报 \rightarrow IP数据报
\rightarrow CSMA/CD帧\)</span>。</p></li>
<li><ol start="2" type="1">
<li>t1时刻S交换表内容是:</li>
</ol></li>
</ul>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">MAC地址</th>
<th style="text-align: center;">端口</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">00-11-22-33-44-cc</td>
<td style="text-align: center;">4</td>
</tr>
<tr class="even">
<td style="text-align: center;">00-11-22-33-44-bb</td>
<td style="text-align: center;">1</td>
</tr>
<tr class="odd">
<td style="text-align: center;">00-11-22-33-44-aa</td>
<td style="text-align: center;">2</td>
</tr>
</tbody>
</table>
<ul>
<li><ol start="3" type="1">
<li>H2至少会收到2个与此次Web访问相关的帧。接收到的是封装ARP查询报文的以太网帧。帧的目的MAC地址是FF-FF-FF-FF-FF-FF。</li>
</ol></li>
</ul>
<hr>
<h2 id="年-17">2020年</h2>
<h3 id="section-15">43</h3>
<ul>
<li><ol type="1">
<li>因为乘法运算可以转换成多个数相加，编译器可以将乘法运算转换成一个循环代码段，在循环代码段中通过比较、加法、移位等指令实现乘法运算。</li>
</ol></li>
<li><ol start="2" type="1">
<li>控制逻辑的作用是控制循环的次数和加法以及移位操作。</li>
</ol></li>
<li><ol start="3" type="1">
<li>没有乘法指令的执行时间最长，使用阵列乘法器实现的乘法指令执行时间最短。因为没有乘法指令时，编译器会将乘法运算转换成多条加法、移位指令，而每条指令的执行都需要取指、译码、执行、写回等机器周期，在第二种情况中，有ALU和移位器实现的乘法指令，执行阶段需要进行多次移位和加法操作，需要多个机器周期，而第三种情况，执行时一个机器周期即可完成运算。因此第一种情况执行时间最长，第三种情况执行时间最短。</li>
</ol></li>
<li><ol start="4" type="1">
<li>带符号整数和无符号整数乘法指令执行得到的2n位乘积均为0000 0000 FFFFF
FFFEH。
函数<code>umul()</code>的返回结果没有溢出，imul()的返回结果溢出。
对于无符号整数乘法运算，进去乘积的低n位时，高n位全为0则没有溢出，反之溢出。</li>
</ol></li>
</ul>
<h3 id="section-16">44</h3>
<ul>
<li><ol type="1">
<li>主存按字节编址，主存块大小为64B，则块内偏移占6位。Cache采用8路组相联，数据区容量为32KB，Cache行数为<span class="math inline">\(\frac{32KB}{64B}=2^9\)</span>。组数为<span class="math inline">\(2^6\)</span>，所以组号占6位，则标记占32-6-6=20位。LRU位占3位。由于采用直写策略，所以没有修改位。</li>
</ol></li>
<li><ol start="2" type="1">
<li>int型数据占4B，一个Cache行可以存放16个数据元素。1024个数据占用Cache行为64行，由于s的起始地址后6位全为0，
在一个内存块的起始地址，因此访问数组s时，只有每次访问对应Cache行的第一个元素时缺失，所以缺失次数为64次。</li>
</ol></li>
<li><ol start="3" type="1">
<li>主存单元0001 0003H，二进制为0000 0000 0000 0001 0000 0000 0000
0011B，块内地址是00 0011B，组号为0000 00B，标记为0000 0000 0000 0001
0000B，即00010H。开始访问时，Cache为空，因此访问Cache缺失。此时从主存中取出对应地址的数据块，存入cache
0组的任意一行，将标记位置为00010H，有效位置1，LRU位置0，最后根据块内地址从该行中取出对应的内容。</li>
</ol></li>
</ul>
<h3 id="section-17">45</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Semaphore S_AC = <span class="number">0</span>; <span class="comment">// 实现操作A和操作C的同步</span></span><br><span class="line">Semaphore S_BC = <span class="number">0</span>; <span class="comment">// 实现操作B和操作C的同步</span></span><br><span class="line">Semaphore S_CE = <span class="number">0</span>; <span class="comment">// 实现操作C和操作E的同步</span></span><br><span class="line">Semaphore S_DE = <span class="number">0</span>; <span class="comment">// 实现操作D和操作E的同步</span></span><br><span class="line"></span><br><span class="line">CoBegin</span><br><span class="line">    Begin 操作A; signal(S_AC); End</span><br><span class="line">    Begin 操作B; signal(S_BC); End</span><br><span class="line">    Begin <span class="title function_">wait</span><span class="params">(S_AC)</span>; wait(S_BC); 操作C; signal(S_CE); End</span><br><span class="line">    Begin 操作D; signal(S_ED); End</span><br><span class="line">    Begin <span class="title function_">wait</span><span class="params">(S_CE)</span>; wait(S_DE); 操作E; End        </span><br><span class="line">CoEnd</span><br></pre></td></tr></table></figure>
<h3 id="section-18">46</h3>
<ul>
<li><ol type="1">
<li>数组元素a[1][2]的虚拟地址是<span class="math inline">\(1080\ 0000H +
(1 * 1024 + 2) * 4=1080 \ 1008H\)</span>。对应的页目录号是00 0100
0010B即042H，页号是001H。页目录的起始物理地址是0020
1000H，<strong>页目录项长度为4B</strong>，则其对应的页目录项的物理地址是<span class="math inline">\(0020 \ 1000H + 042H*4=0020 \
1108H\)</span>。该目录项中存放的也框号是00301H，<strong>页目录项大小为4B</strong>，所以该数组元素所在页对应的页表项物理地址是<span class="math inline">\(00301H &lt;&lt; 12 + 001H * 4=0030 \
1004H\)</span>。</li>
</ol></li>
<li><ol start="2" type="1">
<li>数组a在虚拟地址空间中所占的区域必须连续。在物理空间中所占的区域不必须连续。</li>
</ol></li>
<li><ol start="3" type="1">
<li>按行遍历局部性更好。</li>
</ol></li>
</ul>
<h3 id="section-19">47</h3>
<ul>
<li><ol type="1">
<li>需要在R2中配置NAT表项，配置为:</li>
</ol></li>
</ul>
<table>
<thead>
<tr class="header">
<th>外网</th>
<th></th>
<th>内网</th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>IP地址</td>
<td>端口号</td>
<td>IP地址</td>
<td>端口号</td>
</tr>
<tr class="even">
<td>203.10.2.2</td>
<td>80</td>
<td>192.168.1.3</td>
<td>80</td>
</tr>
</tbody>
</table>
<p>（只需在R2中配置Web服务器的
NAT表项，而不用在R3中配置H2和H3的NAT表项，原因在于我们只知道Web服务器的
端口号80,而客户端的端口号是随机分配的，无法做静态配置，只能通过自动动态配置实现。）</p>
<ul>
<li><ol start="2" type="1">
<li>H2发送的P的源地址是192.168.1.2，
目的IP地址是203.10.2.2；经过R3转发后，P的源IP地址是203.10.2.6，目的IP地址是203.10.2.2；经过R2转发后,
源IP地址是203.10.2.6，目的IP地址是192.168.1.2。</li>
</ol></li>
</ul>
<hr>
<h2 id="年-18">2019年</h2>
<h3 id="section-20">43</h3>
<p>首先可以利用信号量，限制同时请求资源的进程数，
哲学家问题中，限制最多有n-1个哲学家同时请求筷子可以防止死锁。这里还有一个碗的资源，因此可以用碗和n-1的最小值来实现同步与互斥。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Semaphore bowl; <span class="comment">// 用于协调哲学家对碗的使用</span></span><br><span class="line">Semaphore chopsticks[n]; <span class="comment">// 用于协调哲学家对筷子的使用</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    chopsticks[i] = <span class="number">1</span>;</span><br><span class="line">bowl = min(n<span class="number">-1</span>, m); <span class="comment">// 确保不死锁</span></span><br><span class="line"></span><br><span class="line">CoBegin</span><br><span class="line"><span class="title function_">while</span><span class="params">(TRUE)</span>&#123;</span><br><span class="line">    思考;</span><br><span class="line">    P(bowl);</span><br><span class="line">    P(chopsticks[i]);</span><br><span class="line">    P(chopsticks[(i+<span class="number">1</span>)%n]);</span><br><span class="line">    就餐;</span><br><span class="line">    V(chopsticka[i]);</span><br><span class="line">    V(chopsticks[(i+<span class="number">1</span>)%n]);</span><br><span class="line">    V(bowl);</span><br><span class="line">&#125;</span><br><span class="line">CoEnd</span><br></pre></td></tr></table></figure>
<p>也可以暴力的用一个大锁，用来实现一次请求所有资源，如果不能满足要求就释放锁继续循环。
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Semaphore mutex = <span class="number">1</span>; <span class="comment">// 用于实现不同哲学家互斥获取资源</span></span><br><span class="line"><span class="type">int</span> bowl = m;<span class="comment">// 记录碗的数量</span></span><br><span class="line"><span class="type">int</span> chopsticks[n];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    chopsticks[i] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">CoBegin</span><br><span class="line"><span class="title function_">while</span><span class="params">(TRUE)</span> &#123;</span><br><span class="line">    思考;</span><br><span class="line">    P(mutex);</span><br><span class="line">    <span class="keyword">if</span>(bowl &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        V(mutex);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(chopsticks[i] == <span class="number">0</span> &amp;&amp; chopsticks[(i+<span class="number">1</span>)%n] == <span class="number">0</span>) &#123;</span><br><span class="line">        V(mutex);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    bowl --;</span><br><span class="line">    chopsticks[i] = chopsticks[(i+<span class="number">1</span>)%n] = <span class="number">0</span>;</span><br><span class="line">    就餐;</span><br><span class="line">    bowl ++;</span><br><span class="line">    chopsticks[i] = chopsticks[(i+<span class="number">1</span>)%n] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="section-21">44</h3>
<ul>
<li>(1). 磁盘的容量为: <span class="math inline">\(300 \times 10 \times
200 \times 512B=3 \times 10^5 KB\)</span>。</li>
<li>(2). 每个柱面簇个数为:<span class="math inline">\(10\times 200 /
2=1000\)</span>.因此，簇号100260，60005，101660,110560对应的柱面号分别为:100,
60，101,110。按最短寻道时间优先调度算法时，访问簇的先后顺序是:
100260,101660,110560，60005。</li>
<li>(3). 100530对应的柱面号为:<span class="math inline">\(100530 \div
1000=100\)</span>，磁道号为:<span class="math inline">\(100530\%1000\div100=5\)</span>，簇号为30，则扇区号为60.将簇号转换成磁盘物理地址的过程由磁盘驱动程序完成。</li>
</ul>
<h3 id="section-22">45</h3>
<ul>
<li><p>(1). 计算<code>f(10)</code>需要调用函数<code>f1</code>
10次。执行第16行指令<code>call</code>指令会调用<code>f1</code>。</p></li>
<li><p>(2).
第12行jle指令是条件转移指令。第16行<code>call</code>指令、第20行<code>jmp</code>指令、第30行<code>ret</code>指令一定会使程序跳转执行。</p></li>
<li><p>(3). 第16行指令虚拟地址是00401025H，指令长度为5B，
根据相邻指令虚拟地址及指令长度可知计算机按字节编址，所以第17行指令的虚拟地址为<span class="math inline">\(00401025H+5=0040102AH\)</span>。
采用相对寻址方式，执行第16行指令后跳转到第一行的指令执行，其虚拟地址是00401000H，执行call指令时PC自动只想下一条指令即PC值为0040102AH，
<span class="math inline">\(0040102Ah-00401000H=2AH\)</span>。其负值用补码表示为D6H，因此便宜量是FFFF
FFD6H。根据指令中偏移量可知M采用小端方式。</p></li>
<li><p>(4).
因为<code>f1</code>函数中变量是<code>int</code>型，其能表示的最大整数为<span class="math inline">\(2^{31}-1\)</span>，执行f(13)时，结果溢出，因此两者不相等。要使返回结果正确，可以将<code>int</code>型变量改为<code>long long</code>型变量。</p></li>
</ul>
<h3 id="section-23">46</h3>
<p>采用分页管理方式，页大小为4KB，计算机M按字节编址，所以页内偏移占12位，第一行指令和第30行指令除去低12位，即虚页号均为00401H，因此二者在同一个也页里。</p>
<p>主存块大小为64B，则块内偏移占6位，因此32位主存地址中低6位表示块内地址。Cache有64行，采用4路组相连，有16组，所以组号占4位，因此主存地址中间4位即6-9位表示组号，高22位即10-31位表示标记信息。</p>
<p>第16行指令虚拟地址为00401025H，低12位为025H，二进制为0000 0010
0101B，对应组号为0000B，所以只能在Cache的0组中命中。</p>
<h3 id="section-24">47</h3>
<ul>
<li>(1). 设备1：路由器，设备2：以太网交换机，设备3：以太网交换机。</li>
<li>(2).
设备1的接口需要配置IP地址。IF1：192.168.1.254，IF2：192.168.1.1，IF3:192.168.1.65</li>
<li>(3). R需要提供NAT内网穿透服务。</li>
<li>(4).
IP数据报的目的地址为192.168.1.127,主机号全1,为本网络的广播地址，由于路由器可以
隔离广播域，因此只有主机H4会接收数据报</li>
</ul>
<hr>
<h2 id="年-19">2018年</h2>
<h3 id="section-25">43</h3>
<ul>
<li>(1). 设备A的数据传输速率是2MB/s，每秒查询次数至少是:<span class="math inline">\(\frac{2MB}{4B}=0.5\times10^6\)</span>次。因此查询时间间隔最长为:<span class="math inline">\(\frac{1}{0.5\times10^6}s=2\mu
s\)</span>。计算机的CPI为4，每次输入输出至少执行10条指令，因此每秒用于输入输出的CPU时钟周期数为:<span class="math inline">\(0.5\times 10^6\times 10 \times 4=2\times
10^7\)</span>，因此占cpu总时间的百分比为:<span class="math inline">\(\frac{2\times 10^7}{500M}\times
100\%=4\%\)</span>。</li>
<li>(2). 设备B的数据传输速率是40MB/s，因此每秒中断次数最少为:<span class="math inline">\(\frac{40MB}{4B}=10^7\)</span>次，每次中断处理的总时钟周期数至少是400，则每秒用于中断处理的时钟周期数是<span class="math inline">\(400\times
10^7=4000M\)</span>次，而计算机的主频为500MHz，即每秒最多有500M个时钟周期，因此设备B不能采用中断I/O方式。</li>
<li>(3). 每次DMA传送数据块大小为1000B，则每秒需要DMA次数至少为:<span class="math inline">\(\frac{40MB}{1000B}=4\times
10^4\)</span>次，每次DMA需要的总时钟周期数为500，所以设备B用于输入输出的时间占比为:<span class="math inline">\(\frac{4\times10^4\times 500}{500M}\times
100\%=4\%\)</span>。</li>
</ul>
<h3 id="section-26">44</h3>
<ul>
<li>(1). 主存物理地址占28位。</li>
<li>(2). TLB采用直接相联映射。TLB采用SRAM实现。</li>
<li>(3).
Cache采用2路组相联映射。Cache采用LRU替换算法和回写策略，除数据、Tag和有效位外，还应有LRU位和脏位。从图中可以得知，Cache行中Tag位占20位，块内偏移为5位，因此Cache行存放数据为32B，组号有3位，采用2路组相联映射，所以有16个Cache行，LRU位为1位，每个Cache行的组成为：20位Tag，1为有效位，1位脏位，1位LRU位，32B数据，因此Cache的总容量为:<span class="math inline">\((32B+\frac{20+1+1+1}{8})\times16=558B\)</span>。有效位的作用是指示Cache行中的数据是否有效。</li>
<li>(4). 虚拟地址0008 C040H的二进制为: 0000 0000 0000 1000 1100 0000
0100
0000B，页内地址为040H，虚页号为0008CH，根据图中TLB可知，虚页号0008CH对应有效位为1，TLB命中，实页号为0040H，因此物理地址为0040040H。其对应的Tag为00400H，组号为010B即2组，根据图中Cache组号2中标记是00400H对应的有效位为0，而另一个Cache行标记位不匹配，因此在Cache中没有命中。
虚拟地址0007 C260H低12位为0010 0110 0000B，因此组号为011B，即为3.</li>
</ul>
<h3 id="section-27">45</h3>
<ul>
<li>(1).
页目录号和页号均为10位，页内偏移为12位，因此此时页目录号和页号二进制是00
0000 0110B，页内偏移二进制是0000 0000 1000B，所以虚拟地址是0000 0001
1000 0000 0110 0000 0000 1000B，即0180 6008H。</li>
<li>(2).
寄存器PDBR保存的地址是物理地址。进程切换时PDBR的内容会变化，同一进程的线程切换时，PDBR的内容不会变化。每个进程的地址空间、页目录和PDBR的内容存在一一对应的关系。进程切换时,
地址空间发生了变化，对应的页目录及其起始地址也相应变化，因此需要用进程切换后当前进
程的页目录起始地址刷新PDBR。同一进程中的线程共享该进程的地址空间，其线程发生切换
时，地址空间不变，线程使用的页目录不变，因此PDBR的内容也不变。</li>
<li>(3).
为了支持改进型CLOCK置换算法，需要在页表项中设置访问位和修改位字段。</li>
</ul>
<h3 id="section-28">46</h3>
<ul>
<li>(1). 该文件系统能支持的最大文件长度是：<span class="math inline">\((8+\frac{4KB}{4B}+(\frac{4KB}{4B})^2+(\frac{4KB}{4B})^3)\times
4KB=32KB+4MB+4GB+4TB\)</span>。</li>
<li>(2).
存放一个5600B的文件需要占用两个簇，因此521M个簇最多可存放256M个这种图像文件。而文件系统用1M个簇存放文件索引节点，索引节点大小为64B，因此一个簇可以存放索引节点个数为<span class="math inline">\(\frac{4KB}{64B}=64\)</span>，因此该文件系统最多有64M个索引节点，即最多可存放64M个文件，因此该文件系统最多能存放64M个图像文件。</li>
<li>(3).
访问两个文件最后一个簇的时间不相同。因为获取文件F1的最后一个簇的簇号只需要访问索引节点的直接地址项，而
获取文件F2的最后一个簇的簇号还需要读一级索引表。</li>
</ul>
<h3 id="section-29">47</h3>
<ul>
<li>(1).
销售部子网的广播地址是192.168.1.127。技术部子网的子网地址是192.168.1.128/25。技术部还可以连接主机台数为:
<span class="math inline">\(126-1-(208-129+1)=45\)</span>台。</li>
<li>(2).
一个最大IP分片封装数据的字节数为776B。至少需要2个这样的分片。第一个分片的偏移量是0，
第二个分片的偏移量是97</li>
</ul>
<hr>
<h2 id="年-20">2017年</h2>
<h3 id="section-30">43</h3>
<ul>
<li>(1).
因为<code>f1</code>中数据为<code>unsigned</code>类型，当n=0时，n-1会发生溢出，其结果是二进制情况下全为1的无符号整数，即为32位无符号整数能表示的最大值，因此<span class="math inline">\(i\le
n-1\)</span>恒成立，所以<code>f1</code>会出现死循环。若将变量i和n改为<code>int</code>型，则不会出现死循环，因为<code>int</code>型变量可以表示负数，当n=0时，n-1=-1，<span class="math inline">\(i\le
n-1\)</span>不成立，直接跳出循环，所以不会出现死循环。</li>
<li>(2). <code>f1(23)</code>和<code>f2(23)</code>的返回值相等，均为<span class="math inline">\(2^{24}-1\)</span>。<code>f1(23)</code>的机器数是00FF
FFFFH。<code>f2(23)</code>的机器数是4B7FF FFFFH。</li>
<li>(3). 当n=24时，<code>f(24)</code>结果是<span class="math inline">\(2^{25}-1\)</span>，即25个1。而单精度浮点数有效位最多有24位，因此<code>f2(24)</code>返回值进行了舍入，所以与<code>f1(24)</code>不相等。</li>
<li>(4). 因为<code>f1()</code>中sum是int型数据，能表示的最大整数为<span class="math inline">\(2^{31}-1\)</span>，因为当n=31时，计算结过发生溢出，返回值变为-1。若使<code>f1(n)</code>的返回值与<code>f(n)</code>的返回值相等，则n的最大值为30。</li>
<li>(5). 7F80 0000H二进制表示为0111 1111 1000 0000 0000 0000 0000
0000B，阶码全1，尾数全0，因此表示的值是正无穷大。若使<code>f2(n)</code>的结果不溢出，最大的n是126。若使<code>f2(n)</code>的结果精确，最大的n是23。</li>
</ul>
<h3 id="section-31">44</h3>
<ul>
<li>(1). 计算机M是CISC。因为计算机M的指令长短不一。</li>
<li>(2).
<code>f1</code>的第一条指令的虚拟地址是00401020H，最后一条指令虚拟地址是0040107FH，最后一条指令长度是1B，因此<code>f1</code>的机器指令代码共占<span class="math inline">\(0040107FH-00401020H+1=5FH+1\)</span>即96B。</li>
<li>(3). 当<span class="math inline">\(i=0,
n=0\)</span>时，无符号整数n-1结果是1111 1111 1111 1111 1111 1111 1111
1111B，i二进制是0000 0000 0000 0000 0000 0000 0000 0000B，执行<span class="math inline">\(i-(n-1)\)</span>时，计算机的执行过程为<span class="math inline">\(i+[-(n-1)]_补\)</span>在硬件电路里相当于将(n-1)所有位取反，载荷i相加，最后加sub位的1，因为<span class="math inline">\(0000\ 0000H + 0000\ 0000H +1=0000 \
0001H\)</span>，进位C=0，所以<span class="math inline">\(CF=Sub \oplus
C=1\)</span>.</li>
<li>(4).
<code>f2</code>中不能用<code>shl</code>指令实现<code>power*2</code>。因为shi指令用来将一个整数的所有有效数位作为一个整体左移;而<code>f2</code>中的变量<code>power</code>是<code>float</code>
型，其机器数中不包含最高有效数位，但包含了阶码部分，将其作为一个整体左移时并不能
实现“乘2"的功能，因而f2中不能用shl指令实现<code>power*2</code>。</li>
</ul>
<h3 id="section-32">45</h3>
<ul>
<li>(1).
由于函数<code>f1</code>的机器指令的高20位，即虚页号均为00401H，所以其机器指令代码占一页。</li>
<li>(2). 第一条指令的虚拟地址是00401020H,二进制表示是0000 0000 0100 0000
0001 0000 0010 0000B，对应页目录号为0000 0000 01B，页表索引为00 0000
0001B，所以会访问页目录的1号页表项，在对应页表中访问1号表项。</li>
<li>(3).
在执行scanf（）的过程中，进程P因等待输入而从执行态变为阻塞态。输入结束时，P
被中断处理程序唤醒，变为就绪态。P被调度程序调度，变为运行态。CPU状
态会从用户态变为内核态。</li>
</ul>
<h3 id="section-33">46</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Semaphore mutex_y1 = <span class="number">1</span>; <span class="comment">// 用于thread1和thread3对y的互斥访问</span></span><br><span class="line">Semaphore mutex_y2 = <span class="number">1</span>; <span class="comment">// 用于thread2和thread3对y的互斥访问</span></span><br><span class="line">Semaphore mutex_z = <span class="number">1</span>; <span class="comment">// 用于thread2和thread3对z的互斥访问</span></span><br><span class="line"></span><br><span class="line">thread1</span><br><span class="line">&#123;</span><br><span class="line">    cnum w;</span><br><span class="line">    P(mutex_y1);</span><br><span class="line">    w = add(x, y);</span><br><span class="line">    V(mutex_y1);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">thread2</span><br><span class="line">&#123;</span><br><span class="line">    cnum w;</span><br><span class="line">    P(mutex_y2);</span><br><span class="line">    P(mutex_z);</span><br><span class="line">    w = add(y, z);</span><br><span class="line">    V(mutex_z);</span><br><span class="line">    V(mutex_y2);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">thread3</span><br><span class="line">&#123;</span><br><span class="line">    cnum w;</span><br><span class="line">    w.a = <span class="number">1</span>;</span><br><span class="line">    w.b = <span class="number">1</span>;</span><br><span class="line">    P(mutex_z);</span><br><span class="line">    z = add(z, w);</span><br><span class="line">    V(mutex_z);</span><br><span class="line">    P(mutex_y1);</span><br><span class="line">    P(mutex_y2);</span><br><span class="line">    y = add(y, w);</span><br><span class="line">    V(mutex_y2);</span><br><span class="line">    V(mutex_y1);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="section-34">47</h3>
<ul>
<li>(1). <span class="math inline">\(t_0\)</span>时刻到<span class="math inline">\(t_1\)</span>时刻，甲方可断定乙方已经正确接收3个数据帧，分别是<span class="math inline">\(S_{0, 0}, S_{1,0}, S_{2, 0}\)</span>。</li>
<li>(2). 从<span class="math inline">\(t_1\)</span>时刻起，甲方最多还可以发送5个数据帧。第一个数据帧是<span class="math inline">\(S_{5,2}\)</span>，最后一个数据帧是<span class="math inline">\(S_{1,2}\)</span></li>
<li>(3). 甲方需要重新发送3个数据帧。重发的第一个数据帧是<span class="math inline">\(S_{2,3}\)</span></li>
<li>(4).发送序号和确认序号均为3，因此甲方的发送窗口大小为7，则最大信道利用率是：<span class="math inline">\(\frac{7\times \frac{1000\times
8}{100Mbps}}{0.96\times 10^{-3}+\frac{1000\times 8}{100Mbps}\times
2}\times 100\%=50\%\)</span></li>
</ul>
<hr>
<h2 id="年-21">2016年</h2>
<h3 id="section-35">41</h3>
<ul>
<li>(1).
H3收到的S发送过来的第二次握手TCP段的SYN=1，ACK=1。确认序号是101。</li>
<li>(2).
H3收到的第8个确认段所通告的接收窗口是12KB。此时H3的拥塞窗口变为9KB。H3的发送窗口变为9KB。</li>
<li>(3).
当H3的发送窗口等于0时，下一个待发送的数据段序号是20581。H3从发送第一个数据段到发送窗口等于0，经过时间为5个RTT，所以平均数据传输速率是<span class="math inline">\(\frac{20KB}{200ms\times 5}=20KB/s\)</span>。</li>
<li>(4). S释放该连接的最短时间为1.5个RTT即300ms。</li>
</ul>
<h3 id="section-36">44</h3>
<ul>
<li>(1).
每传送一个字符，需要传输1位起始位，7位数据位，1位奇校验位和一位停止位，总共10位。从D接收到启动命令到字符送入I/O端口需要0.5ms，因此一秒最多可向I/O端口送入字符数为<span class="math inline">\(\frac{1s}{0.5ms}=2000\)</span>个。</li>
<li>(2). CPU主频为50MHz，则CPU时钟周期为<span class="math inline">\(\frac{1}{50M}=20ns\)</span>，设备D从启动到字符送入I/O需要0.5ms，即<span class="math inline">\(2.5\times
10^4\)</span>个时钟周期，中断响应需要10个时钟周期；CPI为4，中断服务程序共有20条指令，第15条指令启动D工作，因此在第一个字符传输完成后每隔<span class="math inline">\(2.5\times10^4+10+15\times 4=2.5\times
10^4+70\)</span>个时钟周期完成一个字符的传输，传输第一个字符用时为<span class="math inline">\(2.5\times 10^4 + 10 + 20\times
4=2.5\times10^4+70+20\)</span>个时钟周期，因此传输1000个字符需要的时钟周期数为<span class="math inline">\((2.5\times10^4+70)\times 1000 +
20=25070020\)</span>个，CPU用于完成这一任务的时间大约为<span class="math inline">\((10+80)\times
1000=90000\)</span>个时钟周期。在中断响应阶段，CPU进行的工作有关中断、保存断点和程序状态、引出中断服务程序。</li>
</ul>
<h3 id="section-37">45</h3>
<ul>
<li>(1).
计算机按字节编址，虚拟地址32位，物理地址24位，页大小为8KB，因此页内偏移为13位，虚页号19位，主存块大小为64B，则块内偏移占6位，Cache数据区大小为64KB，Cache行数为<span class="math inline">\(\frac{64KB}{64B}=1K\)</span>，采用2路组相联，因此组数为512，组号占9位，则标记位占24-9-6=9位。所以A：19位，B：19位，C：11位，D：13位，E：9位，F：9位，G：6位。TLB标记字段B中存放的是虚页号。</li>
<li>(2). 4099对应二进制为00 0001 0000 0000 0011,所以组号为0 0000
0011B，即3号，对应H字段为00 0001 000B，即008H。</li>
<li>(3). 缺页处理的时间开销大。因为缺页处理需要访问磁盘，而Cache
缺失只要访问主存。</li>
<li>(4).
因为采用直写策略时需要同时写快速存储器和慢速存储器，而写磁盘比写主存慢很多，所以,
在Cache-主存层次，Cache可以采用直写策略，而在主存-外存（磁盘）层次，修改页面内容时总是采用回写策略。</li>
</ul>
<h3 id="section-38">46</h3>
<ul>
<li>(1).
由于采用了静态优先数，当就绪队列中总有优先数较小的进程时，优先数较大的进程一直没
有机会运行，因而会出现饥饿现象。</li>
<li>(2). 优先数的计算公式为<span class="math inline">\(priority=nice+k_1\times cpuTime - k_2\times
waitTime\)</span>。式中,<span class="math inline">\(k_1 &gt;0, k_2
&gt;0\)</span>,分另0用来调整cpuTime和waitTime在priority中所占的比例。waitTime
可使长时间等待的进程优先数减小，从而避免出现饥饿现象。</li>
</ul>
<h3 id="section-39">47</h3>
<ul>
<li>(1). <code>dir</code>目录文件的内容为：</li>
</ul>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">文件名</th>
<th style="text-align: center;">第一个簇号</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">dir1</td>
<td style="text-align: center;">48</td>
</tr>
</tbody>
</table>
<p><code>dir1</code>目录文件内容为：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">文件名</th>
<th style="text-align: center;">第一个簇号</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">file1</td>
<td style="text-align: center;">100</td>
</tr>
<tr class="even">
<td style="text-align: center;">file2</td>
<td style="text-align: center;">200</td>
</tr>
</tbody>
</table>
<ul>
<li>(2). 簇号占2B，簇大小为4KB，所以FAT的最大长度是<span class="math inline">\(2^{16}\times
2B=128KB\)</span>。文件系统支持的单个文件长度最大为<span class="math inline">\(2^{16}\times 4KB=256MB\)</span>。</li>
<li>(3).
file1的106号簇存放在100号表项中，108号簇存放在106号表项中。</li>
<li>(4).
file1的第5000个字节存放在106号簇，仅FAT和dir目录已经读入内存，因此读文件file1的第5000个字节时，首先需要在内存中访问dir目录找到dir1目录文件对应的簇号为48，然后访问dir1目录文件找到file1的第一个簇号100，再在内存中访问FAT找到106号簇，将对应字节读入内存，因此要访问48号和106号簇。</li>
</ul>
<hr>
<h2 id="年-22">2015年</h2>
<h3 id="section-40">43</h3>
<ul>
<li>(1).
图中通用寄存器<code>R0-R3</code>，程序计数器PC程序员可见的。因为该计算机是单总线结构，ALU有两个输入端，若不设置暂存器T，则会导致ALU两端的运算数相同，导致运算出错。</li>
<li>(2). <code>ALUop</code>至少3位，<code>SRop</code>至少2位。</li>
<li>(3). 控制信号<code>SRout</code>所控制的部件的名称是三态门。</li>
<li>(4). 端点1,2,3,5,8须连接到控制部件的输出端。</li>
<li>(5). <span class="math inline">\(6 \rightarrow 9\)</span>，<span class="math inline">\(7 \rightarrow 4\)</span>。</li>
<li>(6).
因为计算机采用16位定长指令字，按字节编址，执行指令时PC需要自动指向下一条指令的地址，即执行PC+2，因此二路选择器的输入端2是为了实现PC自动加1的功能。</li>
</ul>
<h3 id="section-41">44</h3>
<ul>
<li><p>(1). 指令的操作码字段有7位，最多可以定义128条指令。</p></li>
<li><p>(2). <code>inc R1</code>，操作码为000
0001B，Md为0，Rd为01B，后6位为0，因此其机器代码为 0000 0010 0100
0000B，即0240H。 <code>shl R2,R1</code>，操作码为000 0010B,
Md为0，Rd为10B，Ms1为0，Rs1为01B，后三位为0，机器代码是0000 0100 1000
1000B，即0488H。 <code>sub R3, (R1), R2</code>，操作码是000
0011B，Md为0，Rd为11B，Ms1为1，Rs1为01B，Ms2为0，Rs2为10B，机器代码是0000
0110 1110 1010B，即 06EAH。</p></li>
<li><p>(3). 1. 0; 2. mov; 3. mova; 4. left; 5. read; 6. sub; 7. mov; 8.
SRout。</p></li>
<li><p>(4).
指令<code>sub R1,R3,(R2)</code>执行阶段需要4个时钟周期，指令<code>inc R1</code>执行阶段需要2个时钟周期。</p></li>
</ul>
<h3 id="section-42">45</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Semaphore full_A = x; <span class="comment">// A信箱邮件个数</span></span><br><span class="line">Semaphore full_B = y; <span class="comment">// B信箱邮件个数</span></span><br><span class="line">Semaphore empty_A = M - x; <span class="comment">// A信箱可放邮件个数</span></span><br><span class="line">Semaphore empty_B = N - y; <span class="comment">// B信箱可放邮件个数</span></span><br><span class="line">Semaphore mutex_A = <span class="number">1</span>, mutex_B = <span class="number">1</span>; <span class="comment">// 互斥访问A、B信箱</span></span><br><span class="line"></span><br><span class="line">A &#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE)</span><br><span class="line">    &#123;</span><br><span class="line">        P(full_A);</span><br><span class="line">        P(mutex_A);</span><br><span class="line">        从A的信箱中取一个邮件;</span><br><span class="line">        V(mutex_A);</span><br><span class="line">        V(empty_A);</span><br><span class="line">        回答问题并提出一个新问题;</span><br><span class="line">        P(empty_B);</span><br><span class="line">        P(mutex_B);</span><br><span class="line">        将新邮件放入B信箱;</span><br><span class="line">        V(mutex_B);</span><br><span class="line">        V(full_B);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">B &#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE)</span><br><span class="line">    &#123;</span><br><span class="line">        P(full_B);</span><br><span class="line">        P(mutex_B);</span><br><span class="line">        从B的信箱中取一个邮件;</span><br><span class="line">        V(mutex_B);</span><br><span class="line">        V(empty_B);</span><br><span class="line">        回答问题并提出一个新问题;</span><br><span class="line">        P(empty_A);</span><br><span class="line">        P(mutex_A);</span><br><span class="line">        将新邮件放入A信箱;</span><br><span class="line">        V(mutex_A);</span><br><span class="line">        V(full_A);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="section-43">46</h3>
<ul>
<li>(1).
页内偏移占12位，系统按字节编址，因此页和也框的大小均为4KB。虚拟地址32位，虚页号占20位，因此进程的虚拟地址空间大小为<span class="math inline">\(2^{20}\)</span>页。</li>
<li>(2). 页目录号和页表索引均为10位，因此页目录占用空间大小为<span class="math inline">\(4B\times
2^{10}=4KB\)</span>，占1页，每个页表也占4KB，有<span class="math inline">\(2^{10}\)</span>个页表，因此页表占1024页，所以页目录和页表共占1025页。</li>
<li>(3). 因为虚拟地址0100 0000H和0111 2048H的高10位即页目录号均为 0000
0001 00B，因此共访问一个二级页表。</li>
</ul>
<h3 id="section-44">47</h3>
<ul>
<li>(1).
DHCP服务器可为主机2-主机N动态分配的IP地址最大范围是111.123.15.5--111.123.15.254。发送封装DHCP发现报文的IP分组的源IP地址是0.0.0.0，目的IP地址是255.255.255.255</li>
<li>(2).
发出的第一个以太网帧的目的MAC地址是FF-FF-FF-FF-FF-FF。封装主机2发往Internet的IP分组的以太网帧的目的MAC地址是00-a1-a1-a1-a1-a1。</li>
<li>(3). 主机1能够访问WWW服务器，不能访问Internet。由于主机1的子网掩码配
置正确而默认网关IP地址被错误地配置为111.123.15.2
（正确IP地址是111.123.15.1）,所以
主机1可以访问在同一个子网内的WWW服务器，但当主机1访问Internet时，主机1发出
的IP分组会被路由到错误的默认网关（111.123.15.2）,从而无法到达目的主机。</li>
</ul>
<hr>
<h2 id="年-23">2014年</h2>
<h3 id="section-45">43</h3>
<ul>
<li>(1).</li>
</ul>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">目的网络</th>
<th style="text-align: center;">下一跳</th>
<th style="text-align: center;">接口</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">192.1.1.0/24</td>
<td style="text-align: center;">直连</td>
<td style="text-align: center;">E0</td>
</tr>
<tr class="even">
<td style="text-align: center;">192.1.5.0/24</td>
<td style="text-align: center;">10.1.1.10</td>
<td style="text-align: center;">L1</td>
</tr>
<tr class="odd">
<td style="text-align: center;">192.1.6.0/23</td>
<td style="text-align: center;">10.1.1.2</td>
<td style="text-align: center;">L0</td>
</tr>
</tbody>
</table>
<ul>
<li>(2).
R1通过接口L0转发该IP分组。主机192.1.7.211收到的IP分组TTL是61。</li>
<li>(3).
R1的LSI需要增加一条直连网络，增加Prefix：0.0.0.0/0；Metric为：10。</li>
</ul>
<h3 id="section-46">44</h3>
<ul>
<li>(1).
由于相邻两条机器代码的地址相差4，且指令字长为32位，因此M的存储器编址单位是字节。</li>
<li>(2).
表中<code>sll</code>指令左移2位，因此数组A中每个元素占32位。</li>
<li>(3).
表中<code>bne</code>指令<code>OFFSET</code>字段为FFFAH，补码表示，十进制值为-6。执行<code>bne</code>指令时，PC自动指向下一条指令，即PC值为0804
8118H，执行后跳转到第一条指令执行，则PC值应变为0804
8100H，二者相差18H，即24.而OFFSET值为-6，因此转移目标地址计算公式为<span class="math inline">\((PC)+4+OFFSET&lt;&lt;2\)</span>.</li>
<li>(4).
由于数据相关发生流水线阻塞的指令编号为2、3、4、6；编号6的指令会发生控制冒险。因为指令6会发生控制冒险，插入3个时钟周期的阻塞，消除了指令5和指令1的数据相关。</li>
</ul>
<h3 id="section-47">45</h3>
<ul>
<li>(1). 由于(R6)=1000,因此P执行结束时，R2的内容是1000.</li>
<li>(2).
因为指令Cache共有16行，和主存块交换的块大小是32B，因此数据区的容量是<span class="math inline">\(16\times32B=512B\)</span>。指令字长为4B，因此一个Cache行可存放8条指令，程序P有6条指令，只有在第一次访问第一条指令时发生Cache缺失，程序循环执行了1000次。因此Cache的命中率是<span class="math inline">\(\frac{1000\times6-1}{1000\times 6}\times 100
\%=99.98\%\)</span>。</li>
<li>(3).
第4条指令执行可能发生溢出异常。第3条指令执行可能发生缺页异常。因为只有第4条指令执行的是<code>sum+=A[i]</code>，可能会发生溢出。而数组元素存放一个页中，且磁盘同一扇区，因此只有第一次访问数组元素时发生缺页，所以第3条指令加载数组元素的值可能会发生缺页异常。由于只有第一次访问数组元素时会发生缺页，因此需要读磁盘一次。而进行1000次访问，每次都需要读TLB一次，且第一次读数组元素时发生缺页，进行缺页处理后重新执行指令需要读取一次TLB，因此一共读TLB
1001次。</li>
</ul>
<h3 id="section-48">46</h3>
<ul>
<li><p>(1).
因为文件系统采用连续分配方式，F存储区域前后均有足够的空闲磁盘空间，因此为使访问磁盘次数最少，则应在F存储区域的前边进行插入。首先需要将前29条记录进行前移，这个过程中读取记录内容访问一次磁盘，然后将内容重新写入前边的空闲区域访问一次磁盘，总共访问58次磁盘，最后将新记录查如第30条记录的位置，访问一次磁盘，因此一共访问59次磁盘。<strong>F的文件控制块的起始块号和文件长度会发生改变</strong>。</p></li>
<li><p>(2).
文件系统采用链接分配时，首先需要访问前29条记录找到新记录要插入的位置，访问了29次磁盘，然后需要将第29条记录读入内存，修改其链接指针内容为新记录的地址，而新记录的指针内容是原来第29条记录的指针内容，最后将第29条记录写回磁盘，将第30条记录存入磁盘分配的空闲区域，访问2次磁盘，因此一共访问31次磁盘。</p>
<p>每个存储块的大小为1KB，链接指针为4B，因此文件系统支持的文件最大长度是<span class="math inline">\((1024B-4B)\times 2^{32}=4080GB\)</span>。</p></li>
</ul>
<h3 id="section-49">47</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Semaphore mutex = <span class="number">1</span>; <span class="comment">// 实现互斥访问缓冲区</span></span><br><span class="line">Semaphore full = <span class="number">0</span>; <span class="comment">// 缓冲区中产品数量</span></span><br><span class="line">Semaphore empty = <span class="number">1000</span>; <span class="comment">// 缓冲区空闲位置数量</span></span><br><span class="line">Semaphore mutex1 = <span class="number">1</span>; <span class="comment">// 用于实现消费者互斥连续取10件产品</span></span><br><span class="line"></span><br><span class="line">生产者 &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        生产一个产品;</span><br><span class="line">        P(empty);</span><br><span class="line">        P(mutex);</span><br><span class="line">        将产品放入缓冲区;</span><br><span class="line">        V(mutex);</span><br><span class="line">        V(full);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">消费者 &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        P(mutex1); <span class="comment">// 连续取10次</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            P(full);</span><br><span class="line">            P(mutex);</span><br><span class="line">            取一件产品;</span><br><span class="line">            V(mutex);</span><br><span class="line">            V(empty);</span><br><span class="line">        &#125;</span><br><span class="line">        V(mutex1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="年-24">2013年</h2>
<h3 id="section-50">43</h3>
<ul>
<li>(1). CPU的主频是800MHz，则CPU的时钟周期是<span class="math inline">\(\frac{1}{800M}s=1.25ns\)</span>；总线时钟频率是200MHz，则总线时钟周期是<span class="math inline">\(\frac{1}{200M}s=5ns\)</span>。总线宽度为32位，因此总线带宽是<span class="math inline">\(\frac{32b}{5ns}=800MB/s\)</span>。</li>
<li>(2).
Cache的块大小为32B，一次突发传送32B数据，因此需要用一个读突发传送事务来完成一个主存块的读取。</li>
<li>(3).
存储器完成一次读突发传送总线事务过程中，传送地址用一个总线周期，存储器准备数据用40ns，之后连续传输8次，花费8个总线周期，因此所需的时间为<span class="math inline">\(5ns+40ns+5ns\times8=85ns\)</span>。</li>
<li>(4). Cache命中时的CPI为4，因此访问Cache命中时执行一条指令时间为<span class="math inline">\(1.25ns\times4=5ns\)</span>。BP的CPU执行时间为<span class="math inline">\(100\times 5ns + 100\times 1.2 \times 0.05 \times
85ns=1100ns\)</span>。（<mark>命中的时候CPI是4，也就是说一条指令执行的所有时间是4个时钟周期，未命中的时候需要进行Cache缺失处理，处理完还要去Cache里访问，所以就是100条指令的执行时间加上Cache缺失的处理时间</mark>）</li>
</ul>
<h3 id="section-51">44</h3>
<ul>
<li>(1). 指令为16位定长指令，转移目标地址计算公式为<span class="math inline">\((PC)+2+2\times
OFFSET\)</span>，因此该计算机存储器按字节编址。<code>OFFSET</code>字段占8位，补码表示范围为-128~127,
转移指令执行是PC自动指向下一条指令，因此该条件转移指令反向最多可跳转127条指令。</li>
<li>(2). 指令中C=0, Z=1,
N=1，因此需要检查ZF和NF，当CF=0，ZF=0，NF=1时，发生转移，指令执行后PC的值为<span class="math inline">\(200CH+2+11100011B\times2=1FD4H\)</span>。当CF=1，ZF=0，NF=0时，指令不发生转移，因此指令执行后PC的值为<span class="math inline">\(200CH+2=200EH\)</span>。</li>
<li>(3). 实现无符号数比较小于等于转移时，C=1，Z=1，N=0。</li>
<li>(4). <span style="font-size:17.5px; ">①</span>：指令寄存器；<span style="font-size:17.5px; ">②</span>：移位寄存器；<span style="font-size:17.5px; ">③</span>：加法器。</li>
</ul>
<h3 id="section-52">45</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Semaphore mutex = <span class="number">1</span>; <span class="comment">// 实现互斥进出门</span></span><br><span class="line">Semaphore empty = <span class="number">500</span>; <span class="comment">// 博物馆可容纳的人数</span></span><br><span class="line"></span><br><span class="line">cobegin</span><br><span class="line">    参观者进程i</span><br><span class="line">	&#123;</span><br><span class="line">    	...</span><br><span class="line">        P(empty);</span><br><span class="line">    	P(mutex);</span><br><span class="line">    	进门;</span><br><span class="line">    	V(mutex);</span><br><span class="line">    	参观;</span><br><span class="line">    	P(mutex);</span><br><span class="line">    	出门;</span><br><span class="line">    	V(mutex);</span><br><span class="line">    	V(empty);</span><br><span class="line">    	...</span><br><span class="line">	&#125;</span><br><span class="line">coend</span><br></pre></td></tr></table></figure>
<h3 id="section-53">46</h3>
<ul>
<li>(1). 页内偏移量占12位，主存按字节编址，因此页的大小是<span class="math inline">\(2^{12}B=4KB\)</span>。页号占20位，页表项大小为4字节，所以页表最大占用空间为<span class="math inline">\(2^{20}\times 4B=4MB\)</span>。</li>
<li>(2). 页目录号表达式为：<span class="math inline">\(((LA) \ &gt;&gt;
\ 22) \ \&amp; \ 0x3FF\)</span>;页表索引的表达式为：<span class="math inline">\(((LA) \ &gt;&gt; \ 12) \ \&amp;\
0x3FF\)</span>。</li>
<li>(3). 起始逻辑地址是0000 8000H，所以页内偏移为000H，页号为0000
8H，因为一个页表项大小为4B，所以第一个页表项的物理地址是<span class="math inline">\(0020\ 0000H + 8 \times 4=0020 \ 0020H\)</span>
,则第二个页表项的物理地址是<span class="math inline">\(0020 \ 0020H +
4=0020\ 0024H\)</span>。由于第一个代码页面的物理地址是0090
0000H，对应的也框号为00900H，所以页框号1为00900H，一个页面大小为4KB，所以代码页面2的起始物理地址是0090
1000H，则页框号2为00901H。</li>
</ul>
<h3 id="section-54">47</h3>
<ul>
<li>(1). R2的路由表为</li>
</ul>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">目的网络</th>
<th style="text-align: center;">下一跳</th>
<th style="text-align: center;">接口</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">194.17.20.128/25</td>
<td style="text-align: center;">直连</td>
<td style="text-align: center;">E0</td>
</tr>
<tr class="even">
<td style="text-align: center;">194.17.20.0/23</td>
<td style="text-align: center;">194.17.24.2</td>
<td style="text-align: center;">S1</td>
</tr>
<tr class="odd">
<td style="text-align: center;">153.14.5.0/24</td>
<td style="text-align: center;">153.14.3.2</td>
<td style="text-align: center;">S0</td>
</tr>
</tbody>
</table>
<ul>
<li>(2).
根据最长匹配原则，该IP地址与194.17.20.128/25匹配，因此通过E0接口转发该分组。</li>
<li>(3).
R1和R2之间利用BGP协议交换路由信息。该路由协议被封装到TCP的分组中进行传输。</li>
</ul>
<hr>
<h2 id="年-25">2012年</h2>
<h3 id="section-55">43</h3>
<ul>
<li>(1).
计算机的CPU主频为80MHz，CPI为4，则一秒可以执行指令条数为20M条，所以MIPS数是20。平均每条指令访存1.5次，Cache的命中率为99%，所以平均每秒Cache缺失次数是<span class="math inline">\(20\times 10^6 \times1.5 \times 1\%=3\times
10^5\)</span>次。主存与Cache之间交换的块大小是16B，因此主存带宽至少为<span class="math inline">\(16B\times 3\times 10^5B/s=4.8MB/s\)</span>。</li>
<li>(2). CPU每秒Cache缺失次数为<span class="math inline">\(3\times
10^5\)</span>，所以平均每秒产生缺页异常次数为<span class="math inline">\(3\times 10^5 \times
0.0005\%=1.5\)</span>次。平均每秒需要从磁盘传送数据为<span class="math inline">\(4KB\times 1.5=6KB\)</span>,
每次DMA请求传送数据32位，因此每秒I/O接口发出的DMA请求次数至少是<span class="math inline">\(\frac{6KB}{4B}=1536\)</span>次。</li>
<li>(3).
DMA控制器的优先级更高。因为如果DMA请求不能得到及时响应，可能会造成数据丢失。</li>
<li>(4). 主存能提供的最大带宽是<span class="math inline">\(4\times
\frac{4B}{50ns}=320MB/s\)</span></li>
</ul>
<h3 id="section-56">44</h3>
<ul>
<li>(1). <code>int</code>型变量-513二进制表示为：1111 1101 1111
1111B，执行算数右移指令后，结果是1111 1110 1111
1111B，所以R1的内容是FEFFH。</li>
<li>(2). 所需的时钟周期数是8</li>
<li>(3). <span class="math inline">\(I_3\)</span>的<code>ID</code>段阻塞是因为<span class="math inline">\(I_3\)</span>与<span class="math inline">\(I_2、I_1\)</span>发生数据相关，需要等数据写会寄存器后才能继续执行。<span class="math inline">\(I_4\)</span>的<code>IF</code>段阻塞是因为<span class="math inline">\(I_3\)</span>的<code>ID</code>段阻塞，需要等其执行完后才能执行<code>IF</code>段。</li>
<li>对应指令序列为：</li>
</ul>
<p>​ <span class="math inline">\(I_1\)</span> LOAD R1, [x]</p>
<p>​ <span class="math inline">\(I_2\)</span> LOAD R2, [a]</p>
<p>​ <span class="math inline">\(I_3\)</span> SHL R1</p>
<p>​ <span class="math inline">\(I_4\)</span> ADD R1, R2</p>
<p>​ <span class="math inline">\(I_5\)</span> STORE R2, [x]</p>
<p>流水线执行过程为：</p>
<table>
<colgroup>
<col style="width: 6%">
<col style="width: 5%">
<col style="width: 5%">
<col style="width: 5%">
<col style="width: 5%">
<col style="width: 5%">
<col style="width: 5%">
<col style="width: 5%">
<col style="width: 5%">
<col style="width: 5%">
<col style="width: 5%">
<col style="width: 5%">
<col style="width: 5%">
<col style="width: 5%">
<col style="width: 5%">
<col style="width: 5%">
<col style="width: 5%">
<col style="width: 5%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
<th style="text-align: center;">时</th>
<th style="text-align: center;">间</th>
<th style="text-align: center;">单</th>
<th style="text-align: center;">元</th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">指令</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">5</td>
<td style="text-align: center;">6</td>
<td style="text-align: center;">7</td>
<td style="text-align: center;">8</td>
<td style="text-align: center;">9</td>
<td style="text-align: center;">10</td>
<td style="text-align: center;">11</td>
<td style="text-align: center;">12</td>
<td style="text-align: center;">13</td>
<td style="text-align: center;">14</td>
<td style="text-align: center;">15</td>
<td style="text-align: center;">16</td>
<td style="text-align: center;">17</td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(I_1\)</span></td>
<td style="text-align: center;">IF</td>
<td style="text-align: center;">ID</td>
<td style="text-align: center;">EX</td>
<td style="text-align: center;">M</td>
<td style="text-align: center;">WB</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(I_2\)</span></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">IF</td>
<td style="text-align: center;">ID</td>
<td style="text-align: center;">EX</td>
<td style="text-align: center;">M</td>
<td style="text-align: center;">WB</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(I_3\)</span></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">IF</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">ID</td>
<td style="text-align: center;">EX</td>
<td style="text-align: center;">M</td>
<td style="text-align: center;">WB</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(I_4\)</span></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">IF</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">ID</td>
<td style="text-align: center;">EX</td>
<td style="text-align: center;">M</td>
<td style="text-align: center;">WB</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(I_5\)</span></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">IF</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">ID</td>
<td style="text-align: center;">EX</td>
<td style="text-align: center;">M</td>
<td style="text-align: center;">WB</td>
</tr>
</tbody>
</table>
<p>所以，至少需要17个时钟周期。</p>
<h3 id="section-57">45</h3>
<ul>
<li>(1). 访问&lt;0, 4&gt;时，对应的页框号是21.</li>
<li>(2). 访问&lt;1,
11&gt;时，对应的页框号是32。因为，在时刻11，发生了第三轮扫描，虚页号1对应的页框在第一轮中分配了页框32，上轮中没有访问，存储到了空闲链表中，因此此时可以从空闲链表中取回，对应的页框号是32.</li>
<li>(3). 访问&lt;2,
14&gt;时，对应的页框号是41。因为按照题中访问顺序，在第一轮中&lt;1,
1&gt;, &lt;3, 2&gt;, &lt;0, 4&gt;依次分配页框号为32，
15，21，在第二轮中访问了虚拟页号0，第三轮访问了虚拟页号1，此时空闲链表头对应的也框号是41，因此分配给2号虚页。</li>
<li>(4).
适合。如果程序的时间局部性越好，从空闲页框链表中重新取回的机会越大，该策略的优势越明显。</li>
</ul>
<h3 id="section-58">46</h3>
<ul>
<li>(1).
文件系统的最大容量是4TB，磁盘块大小是1KB，所以磁盘块个数为：<span class="math inline">\(\frac{4TB}{1KB}=2^{32}\)</span>，所以块号至少占32位，即索引表项总块号最少占4字节。索引表区大小为512B，所以索引表项最多有<span class="math inline">\(\frac{512B}{4B}=128\)</span>个，因此单个文件最大长度是128KB。</li>
<li>(2).
块数占2B，504B直接索引，一个索引表项占6B，所以单个文件最大长度是<span class="math inline">\((2^{16} +
\frac{504B}{6B})\times1KB=64MB+84KB=65620KB\)</span>。文件系统最多有<span class="math inline">\(2^{32}\)</span>个磁盘块，因此当块数可表示所有磁盘块，即块数占4B时，可表示的单个文件长度最大，此时起始块号占4B。</li>
</ul>
<h3 id="section-59">47</h3>
<ul>
<li>(1).
编号1,3,4是由H发送的。编号1,2,3IP分组完成了TCP连接建立过程。编号3,5的IP分组在通过快速以太网传输时进行了填充。</li>
<li>(2).
表中前三条IP分组完成了TCP连接的建立，从第3条分组开始可以向S发送数据，其中，第5个分组是S发送的分组，其确认序号是846b
41d6H，对应H发送的分组中序号是846b 41c6H，<span class="math inline">\(846B\ 41D6H - 846B \
41C6H=10H\)</span>,所以S已经收到应用层数据为16B。</li>
<li>(3).
该IP分组发出前TTL字段为40H，H收到后对应的TTL字段为31H，40H-31H=15。所以经过了15个路由器。</li>
</ul>
<hr>
<h2 id="年-26">2011年</h2>
<h3 id="section-60">43</h3>
<ul>
<li>(1). R1内容是86H；R5内容是90H；R6的内容是7CH。</li>
<li>(2). 变量m的二进制为1000
0110B，补码表示的十进制数为-122；k1结果是m-n，n的二进制数为1111
0110，所以k1计算结果是1000 0110 + 0000 1001 + 1 = 1001
0000B，十进制数为-112。</li>
<li>(3). 能用一个加法器辅助电路实现。n位加法器实现的是模<span class="math inline">\(2^n\)</span>无符号整数加法运算。对于无符号整数a和b,
a + b可以直接用加法器实现，而a-b可用a加b的补数实现，即<span class="math inline">\(a-b = a +[-b]_补 mod(2^n)\)</span> ,所以n位无符
号整数加/减运算都可在n位加法器中实现。
由于带符号整数用补码表示，补码加/减运算公式为<span class="math inline">\([a+b]_补=[a]_补+[b]_补,
[a-b]_补=a_补+[-b]_补\)</span>,所以n位带符号整数加减运算都可在n位加法器中实现。</li>
<li>(4).
计算机内部判断是否溢出：加法器最高位进位和次高位进位相异或，结果是1发生溢出，结果是0没有溢出。上述程序段中，最后一条运算语句执行结果发生溢出。</li>
</ul>
<h3 id="section-61">44</h3>
<ul>
<li>(1).
存储器按字节编址，虚拟地址空间大小是16MB，所以虚拟地址共24位，页面大小为4KB，则页内偏移占12位，所以高12位表示虚页号。物理地址空间大小是1MB，所以物理地址20位，高8位表示页框号。</li>
<li>(2).
访问Cache时，物理地址应划分为标记字段、Cache行号、块内偏移3个字段。主存与Cache交换的块大小是32B，所以块内偏移占5位，即0-4位表示块内偏移，Cache有8行，采用直接映射，因此行号占3位，即5-7位表示Cache行号，那么，标记占12位，所以8-19位表示Cache行号。</li>
<li>(3). 虚拟地址001C60H二进制表示为0000 0000 0001 1100 0110
0000B，所以页内偏移为C60H,
虚页号为001H，从页表可知对应的页表项有效位为1，页框号为04H，因此该页面在主存中，对应的物理地址是04C60H，即0000
0100 1100 0110 0000B，对应的块内偏移为00000B，Cache行号为011B，即为3,
标记为0000 0100 1100B，即04CH,
而Cache中行号3对应的标记为105H，因此该地址内容不在Cache中。</li>
<li>(4).
TLB采用4路组相联，有8个页表项时，TLB组号占1位，虚拟地址024BACH对应的页内偏移为BACH，高12位二进制为0000
0010 0100B，对应TLB组号为0，标记为0000 0010
010B，即012H，从TLB中可知，0组中标记012H对应的有效位为1，TLB命中，所以该页面在主存中。</li>
</ul>
<h3 id="section-62">45</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Semaphore mutex = <span class="number">1</span>; <span class="comment">// 互斥使用取号机</span></span><br><span class="line">Semaphore empty = <span class="number">10</span>; <span class="comment">// 空座位个数</span></span><br><span class="line">Semaphore full = <span class="number">0</span>; <span class="comment">// 等待服务的顾客</span></span><br><span class="line">Semaphore service = <span class="number">0</span>; <span class="comment">// 等待叫号</span></span><br><span class="line"></span><br><span class="line">cobegin</span><br><span class="line">&#123;</span><br><span class="line">    process 顾客i</span><br><span class="line">    &#123;</span><br><span class="line">        P(empty);</span><br><span class="line">        p(mutex);</span><br><span class="line">        从取号机获取一个号码;</span><br><span class="line">        V(mutex);</span><br><span class="line">        V(full);</span><br><span class="line">        P(service); <span class="comment">// 等待叫号</span></span><br><span class="line">    &#125;</span><br><span class="line">    process 营业员</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            P(full);</span><br><span class="line">            V(empty);</span><br><span class="line">            V(service); <span class="comment">// 叫号</span></span><br><span class="line">            为顾客服务;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="section-63">46</h3>
<ul>
<li>(1).
采用连续存放合适，因为文件数据一次性写入数据，已经写入的数据不可以修改，但可以多次创建新文件，因此采用连续存储寻道时间更短，随机访问效率更高。在FCB中设计起始块号和块数字段</li>
<li>(2).
FCB集中存储好。因为FCB集中存储时，访问对应的文件时，只需要根据文件名查询FCB找到对应的块，可以减少访问磁盘的次数，访问效率高。</li>
</ul>
<h3 id="section-64">47</h3>
<ul>
<li>(1).
Web服务器的IP地址是64.176.98.32，默认网关的MAC地址是00-21-27-21-51-ee。</li>
<li>(2).
使用ARP协议确定目的MAC地址。封装该协议请求报文的以太网帧的目的MAC地址是ff-ff-ff-ff-ff-ff。</li>
<li>(3). 需要7个RTT。</li>
<li>(4). 需要修改IP分组头中的源IP地址、TTL和头部校验和。</li>
</ul>
<hr>
<h2 id="年-27">2010年</h2>
<h3 id="section-65">43</h3>
<ul>
<li>(1).
指令的OP字段占4位，因此该指令系统最多可有16条指令。指令中寄存器编号占3位，因此最多有8个通用寄存器。主存地址空间大小为128KB，按字编址，字长为2B，因此MAD至少需要16位，MDR至少需要16位。</li>
<li>(2). 转移地址计算公式为<span class="math inline">\((PC)+(Rn)\)</span>，通用寄存器有16位，可表示的补码数据范围为<span class="math inline">\(-2^{15}\)</span>到<span class="math inline">\(2^{15}-1\)</span>，而PC的内容可以是0到<span class="math inline">\(2^{16}-1\)</span>，主存地址空间为<span class="math inline">\(2^{16}\)</span>，所以转移目标指令的目标地址
范围为0000H-FFFFH。</li>
<li>(3). 对应的机器码为0010 0011 0001
0101B，即2315H。该指令执行后，R5的内容和存储单元5678H的内容会改变。R5的内容变为5679H，内存单元5678的内容变为68ACH。</li>
</ul>
<h3 id="section-66">44</h3>
<ul>
<li>(1).
不考虑用于Cache一致性维护和替换算法的控制位，Cache行大小为64B，数据位64B，则块内偏移占6位，主存地址空间大小为256MB，所以地址长度为28位，Cache采用直接映射，有8个Cache行，则行号占3位，标记位占28-6-3=19位，所以一个Cache行的组成包括：一位有效位，19位标记，64B数据；Cache的总容量为<span class="math inline">\((\frac{19+1}{8}B+64B)\times8=532B\)</span>。</li>
<li>(2).
数组a的首地址为320，一个<code>int</code>型数据元素占4B，所以a[0][31]的地址为<span class="math inline">\(320 + (0\times 256+31)\times
4=444\)</span>，对应的Cache行号为<span class="math inline">\((444/64)\%8=6\)</span>；a[1][1]的地址为<span class="math inline">\(320+(1\times256+1)\times4=1348\)</span>，对应的Cache行号为<span class="math inline">\((1348/64)\%8=5\)</span>。</li>
<li>(3).
Cache行大小为64B，一个Cache可存放数组元素16个，程序A按行优先访问数组a，则只有每次访问对应Cache行的第一个元素时发生缺失，存放数组元素需要的Cache行数为<span class="math inline">\(\frac{256\times256}{16}=2^{12}\)</span>,即缺失<span class="math inline">\(2^{12}\)</span>次，所以A的命中率为<span class="math inline">\(\frac{256\times256-2^{12}}{256\times256}\times
100\%=93.75\%\)</span>。程序B按列优先访问数组，因此每次访问时都不命中，所以命中率为0。所以程序A的执行比程序B执行快得多。</li>
</ul>
<h3 id="section-67">45</h3>
<ul>
<li>(1). 因为<span class="math inline">\(2KB=2\times 1024 \times
8b=16384b\)</span>，所以采用位示图法管理磁盘空闲状态，即用一位表示一个磁盘的状态，0表示空闲，1表示占用。</li>
<li>(2). 磁盘转一圈时间为<span class="math inline">\(\frac{60s}{6000}=10ms\)</span>，每个磁道有100个扇区，所以读取一个磁道中随机一个扇区需要的时间为<span class="math inline">\(5ms+\frac{10ms}{100}=5.1ms\)</span>，俺请求顺序50,90,30,120移动磁道个数为170，因此读完4个扇区总共需要时间为<span class="math inline">\(5.1ms\times 4+
170\times1ms=190.4ms\)</span>。</li>
<li>(3).
有，采用先来先服务调度策略更高效。因为Flash半导体存储器的物理结构不需要考虑寻道时间和旋转延迟，可直接按IO请求的先后顺序服务。</li>
</ul>
<h3 id="section-68">46</h3>
<ul>
<li>(1).
页大小为1KB，按字节编址，因此页内偏移占10位，虚拟地址和物理地址空间均为64KB，因此虚拟地址和物理地址长度均为16位，所以虚页号占6位。虚拟地址17CAH的二进制为0001
0111 1100 1010B，对应虚页号为000101B，所以页号为5。</li>
<li>(2).
采用先进先出的置换算法，最早进入的为0号页，因此0号页发生替换，对应的页框号为7，所以物理地址是0001
1111 1100 1010B，十六进制表示为1FCAH。</li>
<li>(3).
采用时钟置换算法时，当前指向2号页，从2号页开始，前4次查找也框号顺序为2,4,7,9，并将对应页框的使用位清零，在第5次查找中指针指向2号页，使用位为0，因此淘汰2号页，对应页框号为2，所以物理地址是0000
1011 1100 1010B，十六进制表示为0BCAH。</li>
</ul>
<h3 id="section-69">47</h3>
<ul>
<li><p>(1). 主机甲和主机乙之间单向传播延迟时间：10us。</p>
<p>两台主机均检测到冲突时，最短所需时间和最长所需时间对应下面两种极端情况。</p>
<p>①
主机甲和主机乙同时各发送一个数据帧，信号在信道中发生冲突后，冲突信号继续向两个方向传播。因此，甲乙两台主机均检测到冲突时，最短需经过10us。</p>
<p>②
主机甲（或主机乙）先发送一个数据帧，当该数据帧即将到达主机乙（或主机甲）时，主机乙（或主机甲）也开始发送一个数据帧。这时，主机乙（或主机甲）将立即检测到冲突;
而主机甲（或主机乙）要检测到冲突，冲突信号还需要从主机乙（或主机甲）传播到主机甲（或主机乙），因此,甲乙两台主机均检测到冲突时，最长需经过20us。</p></li>
<li><p>(2). 发送1518B的数据帧传输时间为<span class="math inline">\(\frac{1518\times 8}{10M}=1214.4us\)</span></p>
<p>发送64B数据传输时间为<span class="math inline">\(\frac{64\times
8}{10M}=51.2us\)</span></p>
<p>所以主机甲的有效数据传输速率是<span class="math inline">\(\frac{1500\times8b}{20us+1214.4us+51.2us}=9.33Mbps\)</span>。</p></li>
</ul>
<hr>
<h2 id="年-28">2009年</h2>
<h3 id="section-70">43</h3>
<ul>
<li>(1).
在中断方式下，数据传输率为0.5MB/s，以32位为单位进行传输，则每秒需要传输次数至少为<span class="math inline">\(\frac{0.5M}{4}=1.25\times
10^5\)</span>，CPI为4，一次中断处理开销指向时间相当于20条指令，所以每秒中断处理需要时钟周期数为<span class="math inline">\(1.25\times 10^5\times 20\times
5=12.5M\)</span>，CPU的主频为500MHz，所以用于外设IO的时间占整个CPU时间的百分比是<span class="math inline">\(\frac{12.5M}{500M}\times 100
\%=2.5\%\)</span>。</li>
<li>(2). 采用DMA传送，每秒DMA请求次数至少是<span class="math inline">\(\frac{5M}{5000}=1000\)</span>次，DMA的总开销是500个时钟周期，所以用于IO的时间占比是<span class="math inline">\(\frac{1000 \times500}{500M}\times
100\%=0.1\%\)</span>。】</li>
</ul>
<h3 id="section-71">44</h3>
<p>执行阶段的每个节拍的功能和有效控制信号为：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">时钟</th>
<th style="text-align: center;">功能</th>
<th style="text-align: center;">有效控制信号</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">C5</td>
<td style="text-align: center;">MAR <span class="math inline">\(\leftarrow\)</span> (R1)</td>
<td style="text-align: center;">R1out, MARin</td>
</tr>
<tr class="even">
<td style="text-align: center;">C6</td>
<td style="text-align: center;">MDR <span class="math inline">\(\leftarrow\)</span> M(MAR)</td>
<td style="text-align: center;">MemR, MDRinE</td>
</tr>
<tr class="odd">
<td style="text-align: center;">C7</td>
<td style="text-align: center;">A <span class="math inline">\(\leftarrow\)</span> (MDR)</td>
<td style="text-align: center;">MDRout, Ain</td>
</tr>
<tr class="even">
<td style="text-align: center;">C8</td>
<td style="text-align: center;">AC <span class="math inline">\(\leftarrow\)</span> (A) + (R0)</td>
<td style="text-align: center;">R0out, Add, ACin</td>
</tr>
<tr class="odd">
<td style="text-align: center;">C9</td>
<td style="text-align: center;">MDR <span class="math inline">\(\leftarrow\)</span> (AC)</td>
<td style="text-align: center;">ACout, MDRin</td>
</tr>
<tr class="even">
<td style="text-align: center;">C10</td>
<td style="text-align: center;">M(MAR) <span class="math inline">\(\leftarrow\)</span> (MDR)</td>
<td style="text-align: center;">MDRoutE, MemW</td>
</tr>
</tbody>
</table>
<h3 id="section-72">45</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Semaphore mutex = <span class="number">1</span>; <span class="comment">// 互斥访问缓冲区</span></span><br><span class="line">Semaphore empty = N; <span class="comment">// 缓冲区空闲位置</span></span><br><span class="line">Semaphore full_odd = <span class="number">0</span>; <span class="comment">// 奇数个数</span></span><br><span class="line">Semaphore full_even = <span class="number">0</span>; <span class="comment">// 偶数个数</span></span><br><span class="line"></span><br><span class="line">P1 &#123;</span><br><span class="line">    <span class="type">int</span> x = produce();</span><br><span class="line">    P(empty);</span><br><span class="line">    P(mutex);</span><br><span class="line">  	put();</span><br><span class="line">    V(mutex);</span><br><span class="line">    <span class="keyword">if</span>(x % <span class="number">2</span> == <span class="number">0</span>) V(full_even);</span><br><span class="line">    <span class="keyword">else</span> V(full_odd);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">P2 &#123;</span><br><span class="line">    P(full_odd);</span><br><span class="line">    P(mutex);</span><br><span class="line">    getodd();</span><br><span class="line">    countodd();</span><br><span class="line">    V(empty);</span><br><span class="line">    V(mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">P3 &#123;</span><br><span class="line">    P(full_even);</span><br><span class="line">    P(mutex);</span><br><span class="line">    geteven();</span><br><span class="line">    counteven();</span><br><span class="line">    V(empty);</span><br><span class="line">    V(mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="section-73">46</h3>
<ul>
<li>(1). 页面大小为4KB，则页内偏移占12位
访问虚拟地址2362H，页内偏移为362H，页号为2，初识时TLB为空，因此查询TLB未命中，花费10ns，然后查询页表花费100ns，页表中页号2对应的表项有效位1，页框号为254H，因此物理地址为254362H，然后根据物理地址访问内存中的数据，花费100ns，总共需要时间为210ns。
访问虚拟地址1565H，页内偏移为565H，页号为1，先查询TLB，未命中，花费10ns，难后查询内存中的页表，对应页表项的有效位为0，因此发生缺页，需要进行缺页处理，处理后再次执行该命令，访问TLB命中，分配的页号为0，对应也框号为101H，最后根据物理地址访问内存中的数据，因此总共需要时间为10ns
+ 100ns + <span class="math inline">\(10^8\)</span>ns + 10ns + 100ns =
10000 0220ns。
访问虚拟地址25A5H时，对应的页号为2，在访问2362H时，已将对应的页表项存入TLB，因此查询TLB命中，转换成物理地址后访问内存中的数据，因此总共需要时间为110ns。</li>
<li>(2).
访问虚拟地址1565H时，页内偏移为565H，页号为1，查询页表发生缺页，因为进程的驻留集为2，所以采用最近最少使用替换策略应将0号页替换，对应的页框号为101H，所以物理地址为101565H。</li>
</ul>
<h3 id="section-74">47</h3>
<ul>
<li>(1).
每个局域网的IP地址数不少于120个，因此主机号为7位，网络号为1位，两个子网分别为202.118.1.0/25,
202.118.1.128/25。因此局域网1与局域网2可以分别为202.118.1.0/25，子网掩码是255.255.255.128，局域网2：子网地址为202.118.1.128/25，子网掩码是255.255.255.128。</li>
<li>(2). R1的路由表如下：</li>
</ul>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">目的网络IP地址</th>
<th style="text-align: center;">子网掩码</th>
<th style="text-align: center;">下一跳IP地址</th>
<th style="text-align: center;">接口</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">202.118.1.0/25</td>
<td style="text-align: center;">255.255.255.128</td>
<td style="text-align: center;">——</td>
<td style="text-align: center;">E1</td>
</tr>
<tr class="even">
<td style="text-align: center;">202.118.1.128/25</td>
<td style="text-align: center;">255.255.255.128</td>
<td style="text-align: center;">——</td>
<td style="text-align: center;">E2</td>
</tr>
<tr class="odd">
<td style="text-align: center;">202.118.3.2/32</td>
<td style="text-align: center;">255.255.255.255</td>
<td style="text-align: center;">202.118.2.2</td>
<td style="text-align: center;">L0</td>
</tr>
<tr class="even">
<td style="text-align: center;">0.0.0.0/0</td>
<td style="text-align: center;">0.0.0.0</td>
<td style="text-align: center;">202.118.2.2</td>
<td style="text-align: center;">L0</td>
</tr>
</tbody>
</table>
<ul>
<li>(3). 局域网1与局域网2可以聚合为202.118.1.0/24，
子网掩码为255.255.255.0，所以R2到局域网1和局域网2的路由为</li>
</ul>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">目的网络IP地址</th>
<th style="text-align: center;">子网掩码</th>
<th style="text-align: center;">吓一跳IP地址</th>
<th style="text-align: center;">接口</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">202.118.1.0/24</td>
<td style="text-align: center;">255.255.255.0</td>
<td style="text-align: center;">202.118.2.1</td>
<td style="text-align: center;">L0</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>研究生入学考试</category>
        <category>真题n刷</category>
      </categories>
      <tags>
        <tag>408</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL学习</title>
    <url>/2024/04/22/MySQL%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h3 id="创建数据库">创建数据库</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE [IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] db_name [create_specification [, create_specification]...]</span><br></pre></td></tr></table></figure>
<p>create_specification:
默认<code>CHARACTER SET</code>指定数据集采用的字符集，如果不指定字符集，默认<code>utf8</code>;<code>COLLATE</code>指定数据库字符集的校对规则(常用的<code>utf8_bin</code>区分大小写、<code>utf8_general_ci</code>不区分大小写)</p>
<h3 id="查看删除数据库">查看、删除数据库</h3>
<ul>
<li>显示数据库语句：<code>SHOW DATABASES</code></li>
<li>显示数据库创建语句：<code>SHOWCREATE DATABASE db_name</code></li>
<li>数据库删除语句：<code>DROP DATABASE [IF EXISTS] db_name</code></li>
</ul>
<h3 id="备份恢复数据库">备份恢复数据库</h3>
<ul>
<li><p>备份数据库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysqldump -u 用户名 -p -B 数据库1 数据库2 数据库n &gt; 文件名.sql</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">备份库的表</span></span><br><span class="line">mysqldump -u 用户名 -p密码 数据库 表1 表2 表n &gt; 文件名.sql</span><br></pre></td></tr></table></figure></li>
<li><p>恢复数据库</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">Source 文件名.<span class="keyword">sql</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="创建表">创建表</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name</span><br><span class="line">(</span><br><span class="line">    field1 datatype,</span><br><span class="line">    field2 datatype,</span><br><span class="line">    field3 datatype</span><br><span class="line">)<span class="type">character</span> <span class="keyword">set</span> 字符集 <span class="keyword">collate</span> 校对规则 engine 引擎</span><br><span class="line"></span><br><span class="line"># 创建<span class="keyword">user</span>表的指令</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `<span class="keyword">user</span>` (</span><br><span class="line">	id <span class="type">INT</span>,</span><br><span class="line">	`name` <span class="type">VARCHAR</span>(<span class="number">255</span>),</span><br><span class="line">	`password` <span class="type">VARCHAR</span>(<span class="number">32</span>),</span><br><span class="line">	birthday <span class="type">DATE</span>)</span><br><span class="line">	<span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_bin ENGINE INNODB;</span><br></pre></td></tr></table></figure>
<p><code>field</code>:
指定列名，<code>collate</code>：如不指定则为所在数据库校对规则</p>
<p><code>datatype</code>：指定列类型(字段类型),
<code>character set</code>：如不指定则为所在数据库字符集</p>
<p><code>engine</code>：引擎</p>
<h4 id="常用数据类型">常用数据类型</h4>
<p><a href="https://www.runoob.com/mysql/mysql-data-types.html">MySQL
数据类型 | 菜鸟教程 (runoob.com)</a></p>
<h3 id="修改表">修改表</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 添加列</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tablename <span class="keyword">ADD</span> (<span class="keyword">column</span> datatype [<span class="keyword">DEFAULT</span> expr] [, <span class="keyword">column</span> datatype]...);</span><br><span class="line"></span><br><span class="line"># 修改列</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tablename MODIFY (<span class="keyword">column</span> datatype [<span class="keyword">DEFAULT</span> expr] [, <span class="keyword">column</span> datatype]...);</span><br><span class="line"></span><br><span class="line"># 删除列</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tablename <span class="keyword">DROP</span> (<span class="keyword">column</span>);</span><br><span class="line"></span><br><span class="line"># 查看表的结构</span><br><span class="line"><span class="keyword">desc</span> 表名;</span><br><span class="line"></span><br><span class="line"># 修改表名</span><br><span class="line">Rename <span class="keyword">table</span> 表名 <span class="keyword">to</span> 新表名</span><br><span class="line"></span><br><span class="line"># 修改字符集</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="type">character</span> <span class="keyword">set</span> 字符集;</span><br><span class="line"></span><br><span class="line"># 改变列名</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> employee CHANGE `name` user_name <span class="type">VARCHAR</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h3 id="crud语句">CRUD语句</h3>
<ul>
<li><p>insert语句</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name [(<span class="keyword">column</span> [, column...])] <span class="keyword">VALUES</span>(<span class="keyword">value</span> [,value...]), (...);</span><br></pre></td></tr></table></figure></li>
<li><p>update语句</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> table_name <span class="keyword">SET</span> col_name1<span class="operator">=</span>expr1 [, col_name2<span class="operator">=</span>expr2 ...] [<span class="keyword">WHERE</span> where_definition]</span><br><span class="line"><span class="keyword">WHERE</span> 指定更新哪些行</span><br></pre></td></tr></table></figure></li>
<li><p>delete语句</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> tbl_name [<span class="keyword">WHERE</span> where_definition]</span><br></pre></td></tr></table></figure></li>
<li><p>select语句</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> [<span class="keyword">DISTINCT</span>] <span class="operator">*</span><span class="operator">|</span>&#123;column1, column2, column3....&#125; <span class="keyword">FROM</span> tablename;</span><br><span class="line"></span><br><span class="line"># 使用表达式对查询的列进行运算</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span><span class="operator">|</span>&#123;column1 <span class="operator">|</span> expression, column2 <span class="operator">|</span> expression,...&#125; <span class="keyword">FROM</span> tablename;</span><br><span class="line"></span><br><span class="line"># 使用<span class="keyword">as</span>语句起别名</span><br><span class="line"><span class="keyword">SELECT</span> column_name <span class="keyword">as</span> 别名 <span class="keyword">FROM</span> tablename;</span><br><span class="line"></span><br><span class="line"># 使用<span class="keyword">order</span> <span class="keyword">by</span>子句排序查询结果</span><br><span class="line"><span class="keyword">SELECT</span> column1, column2, ... <span class="keyword">FROM</span> tablename <span class="keyword">order</span> <span class="keyword">by</span> columnx <span class="keyword">asc</span><span class="operator">|</span><span class="keyword">desc</span>, ...</span><br></pre></td></tr></table></figure>
<p>在<code>where</code>子句中经常使用的运算符</p>
<ul>
<li><p>比较运算符</p>
<p><code>&gt; &lt; &lt;= &gt;= = &lt;&gt; !=</code></p>
<p><code>BETWEEN...AND...</code>显示在某一区间的值</p>
<p><code>IN(set)</code>显示在in列表中的值，例如in(100,200)</p>
<p><code>LIKE NOT LIKE</code>模糊查询</p>
<p><code>IS NULL</code>判断是否为空</p></li>
<li><p>逻辑运算符</p>
<p><code>and or not</code></p></li>
</ul>
<p><strong>统计函数</strong><code>count</code>，返回行的总数</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="operator">|</span> <span class="built_in">count</span>(列名) <span class="keyword">from</span> tablename [<span class="keyword">WHERE</span> where_definition]</span><br><span class="line"><span class="built_in">count</span>(列) 统计满足条件的某列有多少个，会排除<span class="keyword">null</span></span><br></pre></td></tr></table></figure>
<p><strong>合计函数</strong><code>sum</code>,
返回满足where条件的行的和</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">sum</span>(列名) &#123;, <span class="built_in">sum</span>(列名)...&#125; <span class="keyword">from</span> tablename [<span class="keyword">WHERE</span> where_definition]</span><br></pre></td></tr></table></figure>
<p><strong>合计函数</strong><code>avg</code>，返回满足where条件的一列的平均值</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">avg</span>(列名) &#123;, <span class="built_in">avg</span>(列名)...&#125; <span class="keyword">from</span> tablename [<span class="keyword">WHERE</span> where_definition]</span><br></pre></td></tr></table></figure>
<p><strong>合计函数</strong><code>max/min</code>，返回满足where条件的一列d的最大值/最小值</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">max</span>(列名) &#123;, <span class="built_in">max</span>(列名)...&#125; <span class="keyword">from</span> tablename [<span class="keyword">WHERE</span> where_definition]</span><br></pre></td></tr></table></figure>
<p><strong>分组统计</strong></p>
<ul>
<li><p>使用<code>group by</code>子句对列进行分组</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2, column3 ...<span class="keyword">FROM</span> tablename <span class="keyword">group</span> <span class="keyword">by</span> columnx</span><br></pre></td></tr></table></figure></li>
<li><p>使用<code>having</code>子句对分组后的结果进行过滤</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2, column3,..., <span class="keyword">FROM</span> tablename <span class="keyword">group</span> <span class="keyword">by</span> columnx <span class="keyword">having</span> ...</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>字符串函数</strong></p>
<p><code>CHARSET(str)</code>返回字符串的字符集</p>
<p><code>CONCAT(s1,s2...)</code>拼接字符串</p>
<p><code>INSTR(str, substr)</code>返回substr在str中出现的位置，没有返回0</p>
<p><code>UCASE(str)</code>转换成大写</p>
<p><code>LCASE(str)</code>转换成小写</p>
<p><code>LEFT(str, len)</code>从str左起取len个字符</p>
<p><code>LENGTH(str)</code>str的长度</p>
<p><code>REPLACE(str, search_str, replace_str)</code>在str中替换字符串</p>
<p><code>STRCMP(str1, str2)</code>比较两个字符的大小</p>
<p><code>SUBSTRING(str, pos, len)</code>取子串</p>
<p><code>LTRIM(str) RTRIM(str)</code>去除空格</p>
<p><strong>数学函数</strong></p>
<p><code>ABS(num)</code>绝对值</p>
<p><code>BIN(num)</code>十进制转二进制</p>
<p><code>CEILING(num)</code>向上取整</p>
<p><code>CONV(num, from, to)</code>进制转换</p>
<p><code>FLOOR(num)</code>向下取整</p>
<p><code>FORMAT(num, decimal_places)</code>保留小数位</p>
<p><code>HEX(num)</code>转十六进制</p>
<p><code>LEAST(num1, num2,...)</code>求最小值</p>
<p><code>MOD(num, den)</code>求余</p>
<p><code>RAND([seed])</code>随机数</p>
<p><strong>日期函数</strong></p>
<p><code>CURRENT_DATE()</code>当前日期</p>
<p><code>CURRENT_TIME()</code>当前时间</p>
<p><code>CURRENT_TIMESTAMP()</code>当前时间戳</p>
<p><code>DATE(datetime)</code>返回datetime的日期部分</p>
<p><code>DATE_ADD(date, INTERVAL d_value d_type)</code>在date中加上日期或时间</p>
<p><code>DATE_SUB(date, INTERVAL d_value d_type)</code>在date中减去一个时间</p>
<p><code>DATEDIFF(date1, date2)</code>两个日期差(结果是天)</p>
<p><code>TIMEDIFF(date1, date2)</code>两个时间差(多少小时多少分钟多少秒)</p>
<p><code>NOW()</code>当前时间</p>
<p><code>YEAR|Month|DATE(datetime) FROM_UNIXTIME() unix_timestamp()</code>年月日</p>
<p><strong>加密和系统函数</strong></p>
<p><code>USER()</code>查询用户</p>
<p><code>DATABASE()</code>数据库名称</p>
<p><code>MD5(str)</code>为字符串算出一个MD5 32的字符串，加密</p>
<p><code>PASSWORD(str)</code>从原文密码str计算并返回密码字符串，通常用于对mysql数据库的用户密码加密</p>
<p><strong>流程控制函数</strong></p>
<p><code>IF(expr1, expr2, expr3)</code>如果expr1为True，则返回expr2,
否则返回wxpr3</p>
<p><code>IFNULL(expr1, expr2)</code>如果expr1不为NULL则返回expr1，否则返回expr2</p>
<p><code>SELECT CASE WHEN expr1 THEN expr2 WHEN expr3 THEN expr4 ELSE expr5 END;</code>如果expr1为True，则返回expr2，如果expr3为True，则返回expr4，否则返回expr5。</p></li>
<li><p><strong>分页查询</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ... limit <span class="keyword">start</span>, <span class="keyword">rows</span> 表示从<span class="keyword">start</span><span class="operator">+</span><span class="number">1</span>行开始取，取出<span class="keyword">rows</span>行，<span class="keyword">start</span>从<span class="number">0</span>开始计算</span><br></pre></td></tr></table></figure></li>
<li><p><strong>多子句查询</strong></p>
<p>顺序为：<code>group by</code>, <code>having</code>,
<code>order by</code>, <code>limit</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> c <span class="keyword">GROUP</span> <span class="keyword">BY</span> col <span class="keyword">HAVING</span> conditio <span class="keyword">order</span> <span class="keyword">by</span> col limit <span class="keyword">start</span>, <span class="keyword">rows</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="多表查询">多表查询</h3>
<p><strong>笛卡尔积</strong>：两个集合A集合和B集合的所有组合情况（在多表查询时，需要消除无效的笛卡尔积）</p>
<ul>
<li><p>自连接：在同一张表连接查询，将同一张表看做两张表。表取别名实现</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	worker.ename <span class="keyword">AS</span> <span class="string">&#x27;职员名&#x27;</span>, boss.ename <span class="keyword">AS</span> <span class="string">&#x27;上级名&#x27;</span></span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">	emp worker, emp boss</span><br><span class="line"><span class="keyword">WHERE</span> </span><br><span class="line">	worker.mgr <span class="operator">=</span> boss.empno;</span><br></pre></td></tr></table></figure></li>
<li><p>多行子查询</p>
<p>子查询是指嵌入在其他sql语句中的select语句，也叫嵌套查询</p>
<p>单行子查询：只返回一行数据的子查询语句</p>
<p>多行子查询：返回多行数据的子查询，使用关键字<code>in</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 单行子查询</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	emp</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">	deptno <span class="operator">=</span> (<span class="keyword">SELECT</span></span><br><span class="line">                deptno</span><br><span class="line">            <span class="keyword">FROM</span></span><br><span class="line">                emp</span><br><span class="line">            <span class="keyword">WHERE</span></span><br><span class="line">                ename <span class="operator">=</span> <span class="string">&#x27;SMITH&#x27;</span>);</span><br><span class="line">                </span><br><span class="line"># 多行子查询</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> job <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> deptno <span class="operator">=</span> <span class="number">10</span>; # 返回多行数据</span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">	ename, job, sal, deptno </span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">	emp </span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">	job <span class="keyword">IN</span> (<span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> job <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> deptno <span class="operator">=</span> <span class="number">10</span>) <span class="keyword">AND</span> deptno <span class="operator">!=</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>子查询临时表</p>
<p>子查询当做临时表来使用</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">-</span> 子查询当做临时表使用练习题subquery.sql</span><br><span class="line"><span class="comment">-- 查询ecshop中各个类别中，价格最高的商品.</span></span><br><span class="line"><span class="comment">-- 老韩提示，可以将子查询当做一张临时表使用</span></span><br><span class="line"><span class="keyword">SELECT</span> goods_id, cat_id,goods_name,shop_price <span class="keyword">FROM</span> ecs_goods</span><br><span class="line">#查询最高的商品价格,把商品价格和源表对照获取其中商品信息</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> goods_id, cat_id,goods_name,<span class="built_in">MAX</span>(shop_price)</span><br><span class="line"> <span class="keyword">FROM</span> ecs_goods <span class="keyword">GROUP</span> <span class="keyword">BY</span> cat_id</span><br><span class="line"> #细节:有个错误就是以为上面这样子查询就得到结果</span><br><span class="line"> #    但是货物的名字和货物id是对照不上的</span><br><span class="line"> #    原因是goods_name没有进行筛选,返回的是表中cat_id对应最先出现的数据</span><br><span class="line"> #所以要进行条件匹配,匹配到每一个要查询的字段</span><br><span class="line"> </span><br><span class="line"><span class="comment">-- 查询最高价格和cat_id</span></span><br><span class="line"><span class="keyword">SELECT</span> cat_id,<span class="built_in">MAX</span>(shop_price)</span><br><span class="line"> <span class="keyword">FROM</span> ecs_goods <span class="keyword">GROUP</span> <span class="keyword">BY</span> cat_id</span><br><span class="line"> </span><br><span class="line"> #思路:</span><br><span class="line"> #就是把要查询的两个东西查出来再和原表匹配即可</span><br><span class="line"> #在获得最高价格的的查询结果当做临时表,然后作为被查询的表的之一</span><br><span class="line"> #同时查询两个表就可以获取两个表的信息</span><br><span class="line"> #通过<span class="keyword">where</span>子句进行条件判断匹配原表数据</span><br><span class="line"> #temp.cat_id <span class="operator">=</span> ecs_goods.cat_id ,查到临时表的id和原表的id进行匹配</span><br><span class="line"> #max_price<span class="operator">=</span>ecs_goods.shop_price ,临时表的最高价格和原表的价格进行匹配</span><br><span class="line"> #细节:<span class="keyword">select</span> 的字段要清晰写明是哪个表的<span class="operator">!</span></span><br><span class="line"> <span class="keyword">SELECT</span> goods_id, ecs_goods.cat_id,goods_name,max_price <span class="keyword">FROM</span> (</span><br><span class="line"> <span class="keyword">SELECT</span> cat_id,<span class="built_in">MAX</span>(shop_price) <span class="keyword">AS</span> max_price</span><br><span class="line"> <span class="keyword">FROM</span> ecs_goods <span class="keyword">GROUP</span> <span class="keyword">BY</span> cat_id) temp,ecs_goods</span><br><span class="line"> <span class="keyword">WHERE</span> temp.cat_id <span class="operator">=</span> ecs_goods.cat_id <span class="keyword">AND</span> max_price<span class="operator">=</span>ecs_goods.shop_price</span><br></pre></td></tr></table></figure></li>
<li><p><code>all</code>和<code>any</code>操作符</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 显示工资比部门<span class="number">30</span>的所有员工的工资高的员工的姓名、工资和部门号</span><br><span class="line"><span class="keyword">SELECT</span> ename, sal, deptno <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> sal <span class="operator">&gt;</span> <span class="keyword">ALL</span>(<span class="keyword">SELECT</span> sal <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> deptno <span class="operator">=</span> <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line"># 显示工资比部门<span class="number">30</span>的其中一个员工的工资高的员工的姓名、工资和部门号</span><br><span class="line"><span class="keyword">SELECT</span> ename, sal, deptno <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> sal <span class="operator">&gt;</span> <span class="keyword">ANY</span>(<span class="keyword">SELECT</span> sal <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> deptno <span class="operator">=</span> <span class="number">30</span>);</span><br><span class="line"># 等价于</span><br><span class="line"><span class="keyword">SELECT</span> ename, sal, deptno <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> sal <span class="operator">&gt;</span> (<span class="keyword">SELECT</span> <span class="built_in">MIN</span>(sal) <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> deptno <span class="operator">=</span> <span class="number">30</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>多列子查询</p>
<p>查询<strong>返回多个列</strong>数据的子查询语句。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> (deptno, job) <span class="operator">=</span> (<span class="keyword">SELECT</span> deptno, job <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> ename <span class="operator">=</span> <span class="string">&#x27;ALLEN&#x27;</span>) <span class="keyword">AND</span> ename <span class="operator">!=</span> <span class="string">&#x27;ALLEN&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>表复制和去重</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 自我复制</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> my_table01</span><br><span class="line">	<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> my_table01;</span><br><span class="line"></span><br><span class="line"># 去重</span><br><span class="line"># 创建一个临时表</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> my_temp <span class="keyword">LIKE</span> my_table02;</span><br><span class="line"># <span class="keyword">DISTINCT</span>查询后插入到临时表</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> my_temp <span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> <span class="operator">*</span> <span class="keyword">FROM</span> my_table02;</span><br><span class="line"># 原表数据删除</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> my_table02;</span><br><span class="line"># 插入到原表中</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> my_table02 <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> my_temp;</span><br><span class="line"># 删除临时表</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> my_temp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> my_table02;</span><br></pre></td></tr></table></figure></li>
<li><p>合并查询</p>
<p>合并多个select语句的结果，使用集合操作符<code>union</code>,
<code>union all</code>进行合并。<code>uinon all</code>不会取消重复行。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ename, sal, job <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> sal <span class="operator">&gt;</span> <span class="number">2500</span> <span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> ename, sal, job <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> job <span class="operator">=</span> <span class="string">&#x27;MANAGER&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="外连接">外连接</h3>
<p>左外连接：左侧的表完全显示；右外连接：右侧的表完全显示。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 使用方法</span><br><span class="line"><span class="keyword">select</span> ... <span class="keyword">from</span> t1 <span class="keyword">left</span> <span class="keyword">join</span> t2 <span class="keyword">on</span> ...</span><br><span class="line"><span class="keyword">select</span> ... <span class="keyword">from</span> t1 <span class="keyword">right</span> <span class="keyword">join</span> t2 <span class="keyword">on</span> ...</span><br></pre></td></tr></table></figure>
<h3 id="约束">约束</h3>
<p>约束用于确保数据库的数据满足特定的商业规则，在mysql中，约束包括<code>not null</code>,
<code>unique</code>, <code>primary key</code>, <code>foreign key</code>,
<code>check</code></p>
<h4 id="主键primary-key">主键<code>primary key</code></h4>
<p>基本使用：字段名 字段类型 primary key,
用于唯一的标识表行的数据，当定义主键约束后，该列不能重复。</p>
<ul>
<li>主键不能重复且不能为null</li>
<li>一张表最多只能有一个主键，但可以是复合主键</li>
</ul>
<h4 id="其他">其他</h4>
<ul>
<li><p><code>not null</code>：定义后，当插入数据后必须为列提供数据</p></li>
<li><p><code>unique</code>：定义后，该列值不能重复。如果没有指定not
null，unique字段可以有多个null</p></li>
<li><p>外键<code>foreign key</code>：用于定义主表和从表之间的关系，外键约束要定义在从表上，主表则必须具有主键约束或是<code>unique</code>约束，当定义外键约束后，要求外键列数据必须在主表的主键存在或为null。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> my_class (</span><br><span class="line">	id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">	`name` <span class="type">VARCHAR</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">	</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 	my_stu (</span><br><span class="line">	id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">	`name` <span class="type">VARCHAR</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">	class_id <span class="type">INT</span>,</span><br><span class="line">	<span class="comment">-- 指定外键关系</span></span><br><span class="line">	<span class="keyword">FOREIGN</span> KEY (class_id) <span class="keyword">REFERENCES</span> my_class(id));</span><br><span class="line">	</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> my_class <span class="keyword">VALUES</span>(<span class="number">100</span>, <span class="string">&#x27;java&#x27;</span>), (<span class="number">200</span>, <span class="string">&#x27;web&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> my_stu <span class="keyword">VALUES</span>(<span class="number">1</span>, <span class="string">&#x27;tom&#x27;</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> my_stu <span class="keyword">VALUES</span>(<span class="number">2</span>, <span class="string">&#x27;jack&#x27;</span>, <span class="number">200</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> my_stu <span class="keyword">VALUES</span>(<span class="number">3</span>, <span class="string">&#x27;hsp&#x27;</span>, <span class="number">300</span>);</span><br></pre></td></tr></table></figure></li>
<li><p><code>check</code>：用于强制行数据必须满足的条件，假定在sal列上定义了check约束，并要求sal列值在1000-2000之间，如果不在1000-2000之间就会提示错误。</p>
<p>基本语法：列名 类型 check (check条件)。</p></li>
</ul>
<h3 id="自增长">自增长</h3>
<p>基本语法</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">字段名 整形 <span class="keyword">primary</span> key auto_increment</span><br><span class="line"># 添加自增长字段方式</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> xxx (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3.</span>..) <span class="keyword">values</span>(<span class="keyword">null</span>, ....)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> xxx (<span class="number">2</span>, <span class="number">3</span>, ...) <span class="keyword">values</span>()</span><br></pre></td></tr></table></figure>
<p>自增长也可以配合<code>unique</code>使用</p>
<p>如果添加数据时，给自增长字段指定的有值，则以指定的值为准</p>
<h3 id="索引">索引</h3>
<ul>
<li><p>创建索引</p>
<p><strong>索引的类型</strong></p>
<ul>
<li>主键索引，主键自动为主索引</li>
<li>唯一索引</li>
<li>普通索引</li>
<li>全文索引</li>
</ul>
<p><strong>索引使用</strong></p>
<ul>
<li><p>添加索引</p>
<p><code>create [UNIQUE] index index_name on table_name (col_name[(length)] [ASC | DESC], ...)</code></p>
<p><code>ALTER TABLE xxx ADD INDEX index_name (col)</code></p></li>
<li><p>添加主键索引</p>
<p><code>alter table tal_name add primary key(col,...)</code></p></li>
<li><p>删除索引</p>
<p><code>drop index index_name on tal_name</code></p></li>
<li><p>删除主键索引</p>
<p><code>alter table t_b drop primary key</code></p></li>
<li><p>查询索引</p>
<p><code>SHOW INDEXES FROM xxx</code></p></li>
</ul></li>
</ul>
<h3 id="事务">事务</h3>
<p>事务是用于保证数据的一致性的，它由一组相关的dml语句组成，该组的dml语句要么全部成功，要么全部失败。如转账要用事务来处理，用以保证数据的一致性。</p>
<p>事务和锁：当执行事务操作时，mysql会在表上加锁，防止其他用户修改表的数据。</p>
<p><strong>事务的常用操作</strong></p>
<ul>
<li>start transaction：开始一个事务</li>
<li>savepoint 保存点名：设置保存点</li>
<li>rollback to 保存点名：回退事务</li>
<li>rollback：回退全部事务</li>
<li>commit：提交事务，所有的操作生效，不能回退</li>
</ul>
<p><strong>事务细节</strong></p>
<ul>
<li>如果不开始事务，默认情况下，dml操作是自动提交的，不能回滚。</li>
<li>如果开始一个事务，你没有创建保存点,，你可以执行<code>rollback</code>,默认就是回退到你事务开始的状态。</li>
<li>你也可以在这个事务中(还没有提交时)，创建多个保存点.比如:
<code>savepoint aaa</code>; 执行<code>dml</code> ,
<code>savepoint bbb</code>;。</li>
<li>你可以在事务没有提交前，选择回退到哪个保存点。</li>
<li>mysql的事务机制需要innodb的存储引擎才可以使用，myisam不好使。</li>
<li>开始一个事务的两种语法：<code>start transaction</code>；<code>set autocommit= off</code>;</li>
</ul>
<p><strong>事务的隔离级别</strong></p>
<p>多个连接开启各自事务操作数据库中数据时，数据库系统要负责隔离操作，以保证连接在获取数据时的准确性。</p>
<p>如果不考虑隔离性，可能引发脏读、不可重复读、幻读等问题。</p>
<ul>
<li>脏读：当一个事务读取另一个事务尚未提交修改时，产生脏读</li>
<li>不可重复读：同一个查询在同一事务中多次进行，由于其他提交事务所做的修改或删除，每次返回不同的结果集，发生不可重复读。</li>
<li>幻读：同一查询在同一事务中多次进行，由于其他提交事务所做的插入操作，每次返回不同的结果集，此时发生幻读。</li>
</ul>
<p>隔离级别：定义了事务与事务之间的隔离程度</p>
<table>
<thead>
<tr class="header">
<th>MySQL隔离级别(4种)</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
<th>加锁读</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>读未提交(Read uncommitted)</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>不加锁</td>
</tr>
<tr class="even">
<td>读已提交(Read committed)</td>
<td>×</td>
<td>√</td>
<td>√</td>
<td>不加锁</td>
</tr>
<tr class="odd">
<td>可重复读(Repeatable read)</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>不加锁</td>
</tr>
<tr class="even">
<td>可串行化(Serializable)</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>加锁</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>开发</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Python补充</title>
    <url>/2024/04/18/Python%E8%A1%A5%E5%85%85/</url>
    <content><![CDATA[<h2 id="魔术方法">魔术方法</h2>
<ul>
<li><code>__getattr__</code>与<code>__getattribute__</code>对属性进行拦截</li>
</ul>
<p>​
当我们访问一个不存在的属性的时候，会抛出异常，提示我们不存在这个属性。而这个异常就是<code>__getattr__</code>方法抛出的，其原因在于他是访问一个不存在的属性的最后落脚点。Python
解释器会首先调用<code>__getattribute__</code>,
如果该实例中有需要获取的属性值, 就返回属性值, 如果没有, 则会抛出
<code>AttributeError</code>，如果在定义类的时候实现了
<code>__getattr__</code>方法, 那么在 <code>__getattribute__</code> 抛出
<code>AttributeError</code> 后, 就会执行 <code>__getattr__</code>，如果
<code>__getattribute__</code> 获取到了属性值, <code>__ getattr__</code>
就不会被调用.</p>
<ul>
<li><p><code>__setattr__</code></p>
<p>在对一个属性设置值的时候，会调用到这个函数，每个设置值的方式都会进入这个方法。</p>
<p>在实例化的时候，会进行初始化，在__init__里，对value的属性值进行了设置，这时候会调用<code>__setattr__</code>方法。</p>
<p>在重写<code>__setattr__</code>的方法的时候要避免重复调用，避免死循环</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, value</span>):</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;into __init__&quot;</span></span><br><span class="line">        self.value = value</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__setattr__</span>(<span class="params">self, name, value</span>):</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;into __setattr__&quot;</span></span><br><span class="line">        <span class="keyword">if</span> value == <span class="number">10</span>:</span><br><span class="line">            <span class="built_in">print</span> <span class="string">&quot;from __init__&quot;</span></span><br><span class="line">        <span class="built_in">object</span>.__setattr__(self, name, value)</span><br><span class="line">        <span class="comment"># self.__dict__[name] = value</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, value</span>):</span><br><span class="line">        self.value = value</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__setattr__</span>(<span class="params">self, name, value</span>):</span><br><span class="line">        self.name = value <span class="comment"># 会死循环</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>__delattr__</code></p>
<p>删除属性的方法，也要避免死循环</p></li>
</ul>
<h2 id="设计模式">设计模式</h2>
<h3 id="简单工厂模式">简单工厂模式</h3>
<p>不直接向客户暴露对象创建的实现细节，而是通过一个工厂类来负责创建产品类的实例。</p>
<p>包括<strong>工厂角色</strong>、<strong>抽象产品角色</strong>、<strong>具体产品角色</strong></p>
<ul>
<li>优点：隐藏了对象创建的实现细节；客户端不需要修改代码</li>
<li>缺点：违反了单一职责原则，将创建逻辑集中到一个工厂类里；当添加新产品时，需要修改工厂类代码，违反了开闭原则。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABCMeta, abstractmethod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Payment</span>(metaclass=ABCMeta):</span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pay</span>(<span class="params">self, money</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Alipay</span>(<span class="title class_ inherited__">Payment</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, use_huabei=<span class="literal">False</span></span>):</span><br><span class="line">        self.use_huabei = use_huabei</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pay</span>(<span class="params">self, money</span>):</span><br><span class="line">        <span class="keyword">if</span> self.use_huabei:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;支付宝花呗支付&#123;&#125;元&quot;</span>.<span class="built_in">format</span>(money))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;支付宝余额支付&#123;&#125;元&quot;</span>.<span class="built_in">format</span>(money))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WechatPay</span>(<span class="title class_ inherited__">Payment</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pay</span>(<span class="params">self, money</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;微信支付&#123;&#125;元&quot;</span>.<span class="built_in">format</span>(money))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PaymentFactory</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">create_payment</span>(<span class="params">self, method</span>):</span><br><span class="line">        <span class="keyword">if</span> method == <span class="string">&#x27;alipay&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> Alipay()</span><br><span class="line">        <span class="keyword">elif</span> method == <span class="string">&#x27;wechat&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> WechatPay()</span><br><span class="line">        <span class="keyword">elif</span> method == <span class="string">&#x27;huabei&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> Alipay(use_huabei=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">&quot;No such payment named &#123;&#125;&quot;</span>.<span class="built_in">format</span>(method))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pf = PaymentFactory()</span><br><span class="line">p = pf.create_payment(<span class="string">&#x27;huabei&#x27;</span>)</span><br><span class="line">p.pay(<span class="number">100</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="工厂方法模式">工厂方法模式</h3>
<p>定义一个用于创建对象的接口(工厂接口)，让子类决定实例化哪一个产品类。</p>
<p>角色包括<strong>抽象工厂角色、具体工厂角色、抽象产品角色、具体产品角色</strong></p>
<ul>
<li>优点：每个产品都对应一个具体工厂类，不需要修改工厂类代码；隐藏了对象创建的实现细节</li>
<li>缺点：每增加一个具体产品类，就必须增加一个相应的具体工厂类。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABCMeta, abstractmethod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Payment</span>(metaclass=ABCMeta):</span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pay</span>(<span class="params">self, money</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Alipay</span>(<span class="title class_ inherited__">Payment</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, use_huabei=<span class="literal">False</span></span>):</span><br><span class="line">        self.use_huabei = use_huabei</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pay</span>(<span class="params">self, money</span>):</span><br><span class="line">        <span class="keyword">if</span> self.use_huabei:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;支付宝花呗支付&#123;&#125;元&quot;</span>.<span class="built_in">format</span>(money))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;支付宝余额支付&#123;&#125;元&quot;</span>.<span class="built_in">format</span>(money))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WechatPay</span>(<span class="title class_ inherited__">Payment</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pay</span>(<span class="params">self, money</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;微信支付&#123;&#125;元&quot;</span>.<span class="built_in">format</span>(money))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PaymentFactory</span>(metaclass=ABCMeta):</span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">create_payment</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AlipayFactory</span>(<span class="title class_ inherited__">PaymentFactory</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">create_payment</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> Alipay()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WechatPayFactory</span>(<span class="title class_ inherited__">PaymentFactory</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">create_payment</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> WechatPay()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HuabeiFactory</span>(<span class="title class_ inherited__">PaymentFactory</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">create_payment</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> Alipay(use_huabei=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pf = HuabeiFactory()</span><br><span class="line">p = pf.create_payment()</span><br><span class="line">p.pay(<span class="number">100</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="抽象工厂模式">抽象工厂模式</h3>
<p>定义一个工厂类接口，让工厂子类来创建一系列相关或相互依赖的对象</p>
<p>角色包括:
<strong>抽象工厂角色、具体工厂角色、抽象产品角色、具体产品角色、客户端</strong></p>
<p>例如，一个手机有CPU、OS、手机壳等组件，一个工厂可以同时生产这些组件，不同的手机工厂生产该品牌手机对应的所有手机组件</p>
<ul>
<li>优点：将客户端与类的具体实现相分离；每个工厂创建了一个完整的产品系列，使得易于交换产品系列；有利于产品的一致性(产品之间的约束关系)</li>
<li>缺点：难以支持新种类(抽象类)的产品。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> abstractmethod, ABCMeta</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 抽象产品</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PhoneShell</span>(metaclass=ABCMeta):</span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">show_shell</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPU</span>(metaclass=ABCMeta):</span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">show_cpu</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OS</span>(metaclass=ABCMeta):</span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">show_os</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 抽象工厂</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PhoneFactory</span>(metaclass=ABCMeta):</span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">make_shell</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">make_cpu</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">make_os</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 具体产品</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SmallShell</span>(<span class="title class_ inherited__">PhoneShell</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">show_shell</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;普通小手机壳&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BigShell</span>(<span class="title class_ inherited__">PhoneShell</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">show_shell</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;普通大手机壳&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AppleShell</span>(<span class="title class_ inherited__">PhoneShell</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">show_shell</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;苹果手机壳&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SnapDragonCPU</span>(<span class="title class_ inherited__">CPU</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">show_cpu</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;晓龙CPU&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AppleCPU</span>(<span class="title class_ inherited__">CPU</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">show_cpu</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;苹果CPU&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MTKCPU</span>(<span class="title class_ inherited__">CPU</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">show_cpu</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;联发科CPU&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Android</span>(<span class="title class_ inherited__">OS</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">show_os</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;安卓系统&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IOS</span>(<span class="title class_ inherited__">OS</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">show_os</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;IOS系统&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 具体工厂</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MiFactory</span>(<span class="title class_ inherited__">PhoneFactory</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">make_cpu</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> SnapDragonCPU()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">make_os</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> Android()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">make_shell</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> SmallShell()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AppleFactory</span>(<span class="title class_ inherited__">PhoneFactory</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">make_shell</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> AppleShell()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">make_os</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> IOS()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">make_cpu</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> AppleCPU()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 客户端</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, cpu, os, shell</span>):</span><br><span class="line">        self.cpu = cpu</span><br><span class="line">        self.os = os</span><br><span class="line">        self.shell = shell</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">show_info</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;手机信息: &quot;</span>)</span><br><span class="line">        self.cpu.show_cpu()</span><br><span class="line">        self.os.show_os()</span><br><span class="line">        self.shell.show_shell()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 做手机</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">make_phone</span>(<span class="params">factory</span>):</span><br><span class="line">    cpu = factory.make_cpu()</span><br><span class="line">    os = factory.make_os()</span><br><span class="line">    shell = factory.make_shell()</span><br><span class="line">    <span class="keyword">return</span> Phone(cpu, os, shell)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p1 = make_phone(MiFactory())</span><br><span class="line">p1.show_info()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="建造者模式">建造者模式</h3>
<p>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p>
<p>角色包括：<strong>抽象建造者、具体建造者、指挥者、产品</strong></p>
<ul>
<li>优点：隐藏了一个产品的内部结构和装配过程；将构造代码与表示代码分开；可以对构造过程进行更精细的控制</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABCMeta, abstractmethod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, face=<span class="literal">None</span>, body=<span class="literal">None</span>, arm=<span class="literal">None</span>, leg=<span class="literal">None</span></span>):</span><br><span class="line">        self.face = face</span><br><span class="line">        self.body = body</span><br><span class="line">        self.arm = arm</span><br><span class="line">        self.leg = leg</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;&quot;</span>.<span class="built_in">format</span>(self.face, self.body, self.arm, self.leg)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PlayerBuilder</span>(metaclass=ABCMeta):</span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">build_face</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">build_body</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">build_arm</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">build_leg</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SexyGirlBuilder</span>(<span class="title class_ inherited__">PlayerBuilder</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.player = Player()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">build_face</span>(<span class="params">self</span>):</span><br><span class="line">        self.player.face = <span class="string">&quot;漂亮脸蛋&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">build_body</span>(<span class="params">self</span>):</span><br><span class="line">        self.player.body = <span class="string">&quot;苗条&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">build_arm</span>(<span class="params">self</span>):</span><br><span class="line">        self.player.arm = <span class="string">&quot;漂亮胳膊&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">build_leg</span>(<span class="params">self</span>):</span><br><span class="line">        self.player.leg = <span class="string">&quot;大长腿&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Monster</span>(<span class="title class_ inherited__">PlayerBuilder</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.player = Player()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">build_face</span>(<span class="params">self</span>):</span><br><span class="line">        self.player.face = <span class="string">&quot;怪兽脸&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">build_body</span>(<span class="params">self</span>):</span><br><span class="line">        self.player.body = <span class="string">&quot;怪兽身材&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">build_arm</span>(<span class="params">self</span>):</span><br><span class="line">        self.player.arm = <span class="string">&quot;胳膊&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">build_leg</span>(<span class="params">self</span>):</span><br><span class="line">        self.player.leg = <span class="string">&quot;腿&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PlayerDirector</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">build_player</span>(<span class="params">self, builder</span>):</span><br><span class="line">        builder.build_body()</span><br><span class="line">        builder.build_face()</span><br><span class="line">        builder.build_arm()</span><br><span class="line">        builder.build_leg()</span><br><span class="line">        <span class="keyword">return</span> builder.player</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">builder = Monster()</span><br><span class="line">director = PlayerDirector()</span><br><span class="line">p = director.build_player(builder)</span><br><span class="line"><span class="built_in">print</span>(p)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="单例模式">单例模式</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, *args, **kwargs</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">hasattr</span>(cls, <span class="string">&quot;_instance&quot;</span>):</span><br><span class="line">            cls._instance = <span class="built_in">super</span>(Singleton, cls).__new__(cls)</span><br><span class="line">        <span class="keyword">return</span> cls._instance</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>(<span class="title class_ inherited__">Singleton</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, a</span>):</span><br><span class="line">        self.a = a</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = MyClass(<span class="number">10</span>)</span><br><span class="line">b = MyClass(<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a.a)</span><br><span class="line"><span class="built_in">print</span>(b.a)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(a), <span class="built_in">id</span>(b))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="适配器模式">适配器模式</h3>
<p>将一个类的接口转换成客户希望的另一个接口。使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p>
<p>实现方式：类适配器使用多继承；对象适配器使用组合</p>
<p>角色包括：<strong>目标接口，待适配的类，适配器</strong></p>
<p>适用于使用一个已经存在的类，它的接口不符合需求；(对象适配器)想使用一些已经存在的子类，但不可能对每一个都进行子类化以匹配它们的接口。对象适配器可以适配它的父类接口。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABCMeta, abstractmethod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Payment</span>(metaclass=ABCMeta):</span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pay</span>(<span class="params">self, money</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Alipay</span>(<span class="title class_ inherited__">Payment</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, use_huabei=<span class="literal">False</span></span>):</span><br><span class="line">        self.use_huabei = use_huabei</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pay</span>(<span class="params">self, money</span>):</span><br><span class="line">        <span class="keyword">if</span> self.use_huabei:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;支付宝花呗支付&#123;&#125;元&quot;</span>.<span class="built_in">format</span>(money))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;支付宝余额支付&#123;&#125;元&quot;</span>.<span class="built_in">format</span>(money))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WechatPay</span>(<span class="title class_ inherited__">Payment</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pay</span>(<span class="params">self, money</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;微信支付&#123;&#125;元&quot;</span>.<span class="built_in">format</span>(money))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BankPay</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">cost</span>(<span class="params">self, money</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;银联支付&#123;&#125;元&quot;</span>.<span class="built_in">format</span>(money))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ApplePay</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">cost</span>(<span class="params">self, money</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;苹果支付&#123;&#125;元&quot;</span>.<span class="built_in">format</span>(money))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 多继承适配, 类适配器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NewBankPay</span>(Payment, BankPay):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pay</span>(<span class="params">self, money</span>):</span><br><span class="line">        self.cost(money)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对象适配器，通过组合, 将一个对象传给适配器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PaymentAdapter</span>(<span class="title class_ inherited__">Payment</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, payment</span>):</span><br><span class="line">        self.payment = payment</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pay</span>(<span class="params">self, money</span>):</span><br><span class="line">        self.payment.cost(money)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p = PaymentAdapter(ApplePay())</span><br><span class="line">p.pay(<span class="number">100</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="桥模式">桥模式</h3>
<p>将一个事物的两个维度分离，使其都可以独立地变化。适用于有两个维度，两个维度都可以扩展时。</p>
<p>角色：<strong>抽象、细化抽象、实现者、具体实现者</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABCMeta, abstractmethod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span>(metaclass=ABCMeta):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, color</span>):</span><br><span class="line">        <span class="comment"># 组合的方式</span></span><br><span class="line">        self.color = color</span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">draw</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Color</span>(metaclass=ABCMeta):</span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">paint</span>(<span class="params">self, shape</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span>(<span class="title class_ inherited__">Shape</span>):</span><br><span class="line">    name = <span class="string">&quot;长方形&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">draw</span>(<span class="params">self</span>):</span><br><span class="line">        self.color.paint(self)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span>(<span class="title class_ inherited__">Shape</span>):</span><br><span class="line">    name = <span class="string">&quot;圆形&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">draw</span>(<span class="params">self</span>):</span><br><span class="line">        self.color.paint(self)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Line</span>(<span class="title class_ inherited__">Shape</span>):</span><br><span class="line">    name = <span class="string">&quot;直线&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">draw</span>(<span class="params">self</span>):</span><br><span class="line">        self.color.paint(self)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Red</span>(<span class="title class_ inherited__">Color</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">paint</span>(<span class="params">self, shape</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;红色的&#123;&#125;&quot;</span>.<span class="built_in">format</span>(shape.name))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Green</span>(<span class="title class_ inherited__">Color</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">paint</span>(<span class="params">self, shape</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;绿色的&#123;&#125;&quot;</span>.<span class="built_in">format</span>(shape.name))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">shape = Rectangle(Red())</span><br><span class="line">shape.draw()</span><br><span class="line"></span><br><span class="line">s2 = Circle(Green())</span><br><span class="line">s2.draw()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="组合模式">组合模式</h3>
<p>将对象组合成树形结构以表示整体-部分的层次结构，组合模式使得用户对单个对象和组合对象的使用具有一致性。适用于对象的"部分-整体"层次结构，希望用户忽略组合对象与单个对象的不同，用户统一地使用组合结构中的所有对象。</p>
<p>角色：<strong>抽象组件、叶子组件、复合组件、客户端</strong></p>
<ul>
<li>优点：定义了包含基本对象和组合对象的层次结构；简化客户端代码，
客户端可以一致地使用组合对象和单个对象；更容易增加新类型的组件</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABCMeta, abstractmethod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Graphic</span>(metaclass=ABCMeta):</span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">draw</span>(<span class="params">self, *args, **kwargs</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 叶子组件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span>(<span class="title class_ inherited__">Graphic</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x, y</span>):</span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;点(&#123;&#125;, &#123;&#125;)&quot;</span>.<span class="built_in">format</span>(self.x, self.y)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">draw</span>(<span class="params">self, *args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">str</span>(self))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 叶子组件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Line</span>(<span class="title class_ inherited__">Graphic</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, p1, p2</span>):</span><br><span class="line">        self.p1 = p1</span><br><span class="line">        self.p2 = p2</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;线段[&#123;&#125;, &#123;&#125;]&quot;</span>.<span class="built_in">format</span>(self.p1, self.p2)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">draw</span>(<span class="params">self, *args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">str</span>(self))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 复合组件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Picture</span>(<span class="title class_ inherited__">Graphic</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, iterable</span>):</span><br><span class="line">        self.children = []</span><br><span class="line">        <span class="keyword">for</span> g <span class="keyword">in</span> iterable:</span><br><span class="line">            self.add(g)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, graphic</span>):</span><br><span class="line">        self.children.append(graphic)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">draw</span>(<span class="params">self, *args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;复杂图形&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> g <span class="keyword">in</span> self.children:</span><br><span class="line">            g.draw()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p1 = Point(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">l1 = Line(Point(<span class="number">3</span>, <span class="number">4</span>), Point(<span class="number">6</span>, <span class="number">7</span>))</span><br><span class="line">l2 = Line(Point(<span class="number">1</span>, <span class="number">5</span>), Point(<span class="number">2</span>, <span class="number">8</span>))</span><br><span class="line">pic1 = Picture([p1, l1, l2])</span><br><span class="line"><span class="comment"># pic1.draw()</span></span><br><span class="line">p2 = Point(<span class="number">4</span>, <span class="number">4</span>)</span><br><span class="line">l3 = Line(Point(<span class="number">1</span>, <span class="number">1</span>), Point(<span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">pic2 = Picture([p2, l3])</span><br><span class="line"></span><br><span class="line">pic = Picture([pic1, pic2])</span><br><span class="line">pic.draw()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="外观模式">外观模式</h3>
<p>为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</p>
<p>角色：<strong>外观、子系统类</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CPU</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;cpu开始运行&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">stop</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;cpu停止运行&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Disk</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;disk开始运行&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">stop</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;disk停止运行&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Memery</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;memery开始运行&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">stop</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;memery停止运行&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 相当于外观，封装了高层接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cumputer</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.cpu = CPU()</span><br><span class="line">        self.disk = Disk()</span><br><span class="line">        self.memory = Memery()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        self.cpu.run()</span><br><span class="line">        self.disk.run()</span><br><span class="line">        self.memory.run()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">stop</span>(<span class="params">self</span>):</span><br><span class="line">        self.cpu.stop()</span><br><span class="line">        self.disk.stop()</span><br><span class="line">        self.memory.stop()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cp = Cumputer()</span><br><span class="line">cp.run()</span><br><span class="line">cp.stop()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="代理模式">代理模式</h3>
<p>为其他对象提供一种代理控制对这个对象的访问，适用于远程代理(远程的对象的代理)、虚代理(根据需要创建很大的对象)、保护代理(控制对原始对象的访问，用于对象有不同访问权限时)</p>
<p>角色：<strong>抽象实体、实体、代理</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABCMeta, abstractmethod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Subject</span>(metaclass=ABCMeta):</span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_content</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_content</span>(<span class="params">self, content</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RealSubject</span>(<span class="title class_ inherited__">Subject</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, filename</span>):</span><br><span class="line">        self.filename = filename</span><br><span class="line">        f = <span class="built_in">open</span>(filename, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">        self.content = f.read()</span><br><span class="line">        f.close()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_content</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.content</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_content</span>(<span class="params">self, content</span>):</span><br><span class="line">        f = <span class="built_in">open</span>(self.filename, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">        f.write(content)</span><br><span class="line">        f.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 虚代理</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VirtualProxy</span>(<span class="title class_ inherited__">Subject</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, filename</span>):</span><br><span class="line">        self.filename = filename</span><br><span class="line">        self.subj = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_content</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.subj:</span><br><span class="line">            self.subj = RealSubject(self.filename)</span><br><span class="line">        <span class="keyword">return</span> self.subj.get_content()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_content</span>(<span class="params">self, content</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.subj:</span><br><span class="line">            self.subj = RealSubject(self.filename)</span><br><span class="line">        <span class="keyword">return</span> self.subj.set_content(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 保护代理</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProtectedProxy</span>(<span class="title class_ inherited__">Subject</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, filename</span>):</span><br><span class="line">        self.subj = RealSubject(filename)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_content</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.subj.get_content()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_content</span>(<span class="params">self, content</span>):</span><br><span class="line">        <span class="keyword">raise</span> PermissionError(<span class="string">&quot;无写入权限&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># subj = VirtualProxy(&quot;test.txt&quot;)</span></span><br><span class="line"><span class="comment"># print(subj.get_content())</span></span><br><span class="line">subj = ProtectedProxy(<span class="string">&quot;test.txt&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(subj.get_content())</span><br><span class="line">subj.set_content(<span class="string">&quot;1111&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="责任链模式">责任链模式</h3>
<p>使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。</p>
<p>角色：抽象处理者、具体处理者、客户端</p>
<p>适用于有多个对象可以处理一个请求，哪个对象处理由运行时决定或者在不明确接收者的情况下，向多个对象中的一个提交一个请求，可以降低耦合度，一个对象无需知道是其他哪一个对象处理其请求。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABCMeta, abstractmethod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Handler</span>(metaclass=ABCMeta):</span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">handle_leave</span>(<span class="params">self, day</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GeneralManger</span>(<span class="title class_ inherited__">Handler</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">handle_leave</span>(<span class="params">self, day</span>):</span><br><span class="line">        <span class="keyword">if</span> day &lt; <span class="number">10</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;总经理准假&#123;&#125;天&quot;</span>.<span class="built_in">format</span>(day))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;离职吧&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DepartmentManger</span>(<span class="title class_ inherited__">Handler</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.<span class="built_in">next</span> = GeneralManger()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">handle_leave</span>(<span class="params">self, day</span>):</span><br><span class="line">        <span class="keyword">if</span> day &lt;= <span class="number">5</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;部门经理准假&#123;&#125;天&quot;</span>.<span class="built_in">format</span>(day))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;部门经理职权不足&quot;</span>)</span><br><span class="line">            self.<span class="built_in">next</span>.handle_leave(day)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProjectDirector</span>(<span class="title class_ inherited__">Handler</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.<span class="built_in">next</span> = DepartmentManger()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">handle_leave</span>(<span class="params">self, day</span>):</span><br><span class="line">        <span class="keyword">if</span> day &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;项目主管准假&#123;&#125;天&quot;</span>.<span class="built_in">format</span>(day))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;项目主管职权不足&quot;</span>)</span><br><span class="line">            self.<span class="built_in">next</span>.handle_leave(day)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">day = <span class="number">4</span></span><br><span class="line">h = ProjectDirector()</span><br><span class="line">h.handle_leave(day)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="观察者模式">观察者模式</h3>
<p>定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖它的对象都得到通知并被自动更新。观察者模式又称为"发布-订阅"模式。</p>
<p>角色：<strong>抽象主题、具体主题（发布者）、抽象观察者、具体观察者（订阅者）</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABCMeta, abstractmethod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Observer</span>(metaclass=ABCMeta):</span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">self, notice</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Notice</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.observers = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">attach</span>(<span class="params">self, obs</span>):</span><br><span class="line">        self.observers.append(obs)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">detach</span>(<span class="params">self, obs</span>):</span><br><span class="line">        self.observers.remove(obs)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">notify</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">for</span> obs <span class="keyword">in</span> self.observers:</span><br><span class="line">            obs.update(self)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 具体的发布者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StaffNotice</span>(<span class="title class_ inherited__">Notice</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, company_info=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.__company_info = company_info</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">company_info</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.__company_info</span><br><span class="line"></span><br><span class="line"><span class="meta">    @company_info.setter</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">company_info</span>(<span class="params">self, info</span>):</span><br><span class="line">        self.__company_info = info</span><br><span class="line">        self.notify()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 具体的订阅者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Staff</span>(<span class="title class_ inherited__">Observer</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.company_info = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">self, notice</span>):</span><br><span class="line">        self.company_info = notice.company_info</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">notice = StaffNotice(<span class="string">&quot;初始公司信息&quot;</span>)</span><br><span class="line">s1 = Staff()</span><br><span class="line">s2 = Staff()</span><br><span class="line">notice.attach(s1)</span><br><span class="line">notice.attach(s2)</span><br><span class="line">notice.company_info = <span class="string">&quot;发奖金&quot;</span></span><br><span class="line">notice.detach(s1)</span><br><span class="line"><span class="built_in">print</span>(s1.company_info)</span><br><span class="line">notice.company_info = <span class="string">&quot;放假&quot;</span></span><br><span class="line"><span class="built_in">print</span>(s1.company_info, s2.company_info)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="策略模式">策略模式</h3>
<p>定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换。使得算法可独立于使用它的客户而变化。</p>
<p>角色：抽象策略、具体策略、上下文</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABCMeta, abstractmethod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Strategy</span>(metaclass=ABCMeta):</span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">execute</span>(<span class="params">self, data</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FastStrategy</span>(<span class="title class_ inherited__">Strategy</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">execute</span>(<span class="params">self, data</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;快速处理策略&quot;</span>, data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SlowStrategy</span>(<span class="title class_ inherited__">Strategy</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">execute</span>(<span class="params">self, data</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;慢速处理策略&quot;</span>, data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Context</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, strategy, data</span>):</span><br><span class="line">        self.data = data</span><br><span class="line">        self.strategy = strategy</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_strategy</span>(<span class="params">self, strategy</span>):</span><br><span class="line">        self.strategy = strategy</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">do_strategy</span>(<span class="params">self</span>):</span><br><span class="line">        self.strategy.execute(self.data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">data = <span class="string">&quot;hello world&quot;</span></span><br><span class="line">s = FastStrategy()</span><br><span class="line">context = Context(s, data)</span><br><span class="line">context.do_strategy()</span><br></pre></td></tr></table></figure>
<h3 id="模板方法模式">模板方法模式</h3>
<p>定义一个操作中的算法骨架，将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p>
<p>角色：<strong>抽象类、具体类</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABCMeta, abstractmethod</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Window</span>(metaclass=ABCMeta):</span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">start</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">repaint</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">stop</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        self.start()</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                self.repaint()</span><br><span class="line">                time.sleep(<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        self.stop()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyWindow</span>(<span class="title class_ inherited__">Window</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, msg</span>):</span><br><span class="line">        self.msg = msg</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">start</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;mywindow start&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">stop</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;mywindow stop&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">repaint</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.msg)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">w = MyWindow(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">w.run()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>开发</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>魔术方法</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>async异步编程</title>
    <url>/2024/04/18/async%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="协程">协程</h2>
<p>协程(Coroutine)，也称为微线程，是一种用户态内的上下文切换技术，就是通过一个线程实现代码块相互切换执行。</p>
<p>Python实现协程的几种方法:</p>
<ul>
<li>greenlet, 早期的模块</li>
<li>yield关键字</li>
<li>asyncio装饰器(py3.4引入)</li>
<li>async、await关键字(py3.5之后)</li>
</ul>
<h3 id="asyncio事件循环">asyncio事件循环</h3>
<p>事件循环可以看做一个死循环，去检测并执行某些代码。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">任务列表 = [任务<span class="number">1</span>, 任务<span class="number">2</span>, 任务<span class="number">3</span>, ...]</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    可执行的任务列表, 已完成的任务列表 = 在任务列表中检查所有的任务， 将<span class="string">&#x27;可执行&#x27;</span>和<span class="string">&#x27;已完成&#x27;</span>的任务返回</span><br><span class="line">    <span class="keyword">for</span> 就绪任务 <span class="keyword">in</span> 已准备就绪的任务列表:</span><br><span class="line">        执行已就绪的任务</span><br><span class="line">    <span class="keyword">for</span> 已完成的任务 <span class="keyword">in</span> 已完成的任务列表:</span><br><span class="line">        在任务列表中移除 已完成的任务</span><br><span class="line">    如果 任务列表 中的任务都已完成，则终止循环</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成或获取一个事件循环</span></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line"><span class="comment"># 将任务放到&quot;任务列表&quot;</span></span><br><span class="line">loop.run_until_complete(tasks)</span><br><span class="line">asyncio.run()</span><br></pre></td></tr></table></figure>
<h3 id="await关键字">await关键字</h3>
<p>用法: <code>await</code> +
可等待的对象(协程对象、Future、Task对象)</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;world&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;return x&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;main&quot;</span>)</span><br><span class="line">    res = <span class="keyword">await</span> func()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;func return&quot;</span>, res)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">main</span></span><br><span class="line"><span class="string">hello</span></span><br><span class="line"><span class="string">world</span></span><br><span class="line"><span class="string">func return return x</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="task对象">task对象</h3>
<p>实现在事件循环中添加多个任务</p>
<p>创建 Task，意思就是把协程封装成 Task 实例，并追踪协程的 <strong>运行
/ 完成状态</strong>，用于未来获取协程的结果。</p>
<p>具体来说，是通过 <code>asyncio.create_task()</code> 创建
Task，让协程对象加入时事件循环中，等待被调度执行。协程封装为 Task
后不会立马启动，当某个代码 <code>await</code> 这个 Task
的时候才会被执行。</p>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;xxxx&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;main start&quot;</span>)</span><br><span class="line"></span><br><span class="line">    task1 = asyncio.create_task(func(), name=<span class="string">&quot;n1&quot;</span>)</span><br><span class="line">    task2 = asyncio.create_task(func(), name=<span class="string">&#x27;n2&#x27;</span>)</span><br><span class="line">    task_list = [task1, task2]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;main end&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># res1 = await task1</span></span><br><span class="line">    <span class="comment"># res2 = await task2</span></span><br><span class="line">    <span class="comment"># task列表等待</span></span><br><span class="line">    done, pending = <span class="keyword">await</span> asyncio.wait(task_list, timeout=<span class="literal">None</span>)</span><br><span class="line">    <span class="built_in">print</span>(done)</span><br><span class="line">    <span class="keyword">for</span> task_d <span class="keyword">in</span> done:</span><br><span class="line">        <span class="built_in">print</span>(task_d.get_name(),task_d.result())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure></p>
<h3 id="future对象">Future对象</h3>
<p>Future 相较于 Task 属于更底层的概念，在开发过程中用到的并不多。</p>
<p>urture 对象内部封装了一个 <code>_state</code>，这个
<code>_state</code>
维护着四种状态：<strong>Pending</strong>、<strong>Running</strong>、<strong>Done</strong>，<strong>Cancelled</strong>，如果变成
<code>Done</code>
完成，就不再等待，而是往后执行，这四种状态的存在其实类似与进程的
运行态、就绪态、阻塞态，事件循环凭借着四种状态对 Future进行调度。</p>
<p>Task继承Future，task对象内部await结果的处理基于future对象</p>
<h3 id="异步迭代器">异步迭代器</h3>
<p><strong>迭代器：在其内部实现yield方法和next方法的对象。可迭代对象：在类内部实现一个iter方法，并返回一个迭代器。</strong></p>
<p><strong>异步迭代器：实现了__aiter__()和__anext__()方法的对象，必须返回一个awaitable对象。sync_for支持处理异步迭代器的__anext__()方法返回的可等待对象，直到引发一个stopAsyncIteration异常</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Reader</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.count = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">readline</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># await asyncio.sleep(1)</span></span><br><span class="line">        self.count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self.count == <span class="number">100</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> self.count</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__aiter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">__anext__</span>(<span class="params">self</span>):</span><br><span class="line">        val = <span class="keyword">await</span> self.readline()</span><br><span class="line">        <span class="keyword">if</span> val == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> StopAsyncIteration</span><br><span class="line">        <span class="keyword">return</span> val</span><br><span class="line">    </span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    obj = Reader()</span><br><span class="line">    <span class="comment"># async for 必须写在协程函数里边</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">for</span> item <span class="keyword">in</span> obj:</span><br><span class="line">        <span class="built_in">print</span>(item)</span><br><span class="line"></span><br><span class="line">asyncio.run(func())</span><br></pre></td></tr></table></figure>
<h3 id="异步和非异步模块混合使用">异步和非异步模块混合使用</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requets</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">download_image</span>(<span class="params">url</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Downloading......&quot;</span>)</span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    future = loop.run_in_executor(<span class="literal">None</span>,requets.get,url)</span><br><span class="line">    response = <span class="keyword">await</span> future</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;OK!&quot;</span>)</span><br><span class="line">    filename=</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(filename,<span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> file_object:</span><br><span class="line">        file_object.write(response.content)</span><br><span class="line"></span><br><span class="line">url_list = []</span><br><span class="line">tasks = [download_image(url) <span class="keyword">for</span> url <span class="keyword">in</span> url_list]</span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(asyncio.wait(tasks))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
        <category>异步编程</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>asyncio</tag>
        <tag>异步编程</tag>
      </tags>
  </entry>
  <entry>
    <title>一些数学知识</title>
    <url>/2024/04/17/%E4%B8%80%E4%BA%9B%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h2 id="矩阵求导">矩阵求导</h2>
]]></content>
      <categories>
        <category>杂货</category>
        <category>数学知识</category>
      </categories>
      <tags>
        <tag>数学知识</tag>
      </tags>
  </entry>
  <entry>
    <title>政治选择题</title>
    <url>/2023/12/08/%E6%94%BF%E6%B2%BB%E9%80%89%E6%8B%A9%E9%A2%98/</url>
    <content><![CDATA[<ol type="1">
<li><p><span style="font-weight: bold">《论十大关系》</span>是以毛泽东为主要代表的中国共产党人<span style="color: red"><strong>开始探索适合中国国情的社会主义建设道路的标志</strong></span>，在新的历史条件下从经济方面和政治方面提出了新的指导方针，为中共八大的召开做了理论准备。</p></li>
<li><p><span style="color: green; font-weight: bold">《关于正确处理人民内部矛盾的问题》</span></p></li>
</ol>
<ul>
<li>提出了<strong>中国工业化道路问题，主要是重工业和轻工业、农业的发展关系问题</strong>，强调走一条有别与苏联的中国工业化道路。</li>
<li>所谓<strong>专政方式</strong>，就是运用人民民主专政的国家机器
，对于国家内部那些反抗社会主义改造、破坏社会主义建设的敌对分子和严重犯罪分子依法治罪，剥夺他们的政治权利，强迫他们从事劳动，并在劳动中尽量使他们改造成为新人</li>
<li>所谓<strong>民主方法</strong>，就是<strong>讨论</strong>的方法、<strong>批评</strong>的方法、<strong>说服教育</strong>的方法。</li>
</ul>
<ol start="3" type="1">
<li><p><span style="color:red"><strong>军政军民团结</strong></span>是实现富国和强军相统一的<span style="color: red"><strong>重要政治保障</strong></span>。</p></li>
<li><p><span style="color: red"><strong>矛盾的统一性</strong></span>规定着事物转化和发展的趋势</p></li>
<li><p>中国革命必须走农村包围城市、武装夺取政权的道路，是由中国所处的时代特点和具体国情决定的。<strong>一方面</strong>，在半殖民地半封建的中国社会，内无民主制度而受封建主义的压迫，外无民族独立而受帝国主义压迫。<strong>另一方面</strong>，近代中国是一个农业大国，农民占全国人口的绝大多数，是无产阶级可靠的同盟军和革命的主力军。（双选）</p></li>
<li><p><span style="color: red"><strong>宣传思想文化工作</strong></span>，<strong>事关</strong>党的前途命运，<strong>事关</strong>国家长治久安，<strong>事关</strong>民族凝聚力和向心力。宣传思想文化工作的<span style="color: red"><strong>首要政治任务</strong></span>是用党的<span style="color: red"><strong>创新理论武装全党、教育人民</strong></span>。</p></li>
<li><p>全面深化改革<span style="color: red"><strong>总目标</strong></span>是<strong>完善和发展中国特色社会主义制度、推进国家治理体系和治理能力现代化</strong>。全面深化改革<span style="color: red"><strong>总目标是引领</strong></span>。<span style="color: red"><strong>制度建设是主线</strong></span>。<span style="color: red"><strong>经济体质改革是重点</strong></span>。<span style="color: red"><strong>重要领域和关键环节改革是突破口</strong></span>。</p></li>
<li><p>党带领人民在伟大斗争中孕育的<span style="color: red"><strong>革命文化</strong></span>和<span style="color: red"><strong>社会主义先进文化</strong></span>是我们<strong>坚定文化自信的坚强</strong><span style="color: red"><strong>基石</strong></span>。</p></li>
</ol>
<ul>
<li><p>中华民族<span style="color: red"><strong>优秀传统文化</strong></span>是我们坚定文化自信的<span style="color: red"><strong>深厚基础</strong></span>。</p></li>
<li><p>中国特色<span style="color: red"><strong>社会主义伟大实践</strong></span>是坚定文化自信的<span style="color: red"><strong>现实基础</strong></span>。</p></li>
</ul>
<ol start="9" type="1">
<li><p><span style="color: red"><strong>全面贯彻实施宪法</strong></span>是建设社会主义法治国家的<span style="color: red"><strong>首要任务和基础性工程</strong></span>，也是坚持和完善人民代表大会制度的必然要求。</p></li>
<li><p><span style="color: red"><strong>构建新发展格局</strong></span>是把握未来发展主动权的<span style="color: red"><strong>战略性布局和先手棋</strong></span>。</p></li>
<li><p><span style="color: red"><strong>贯彻新发展理念</strong></span>是<strong>新时代我国发展壮大</strong>的必由之路。</p></li>
<li><p>三三制：<strong>共产党员</strong>：<strong>工人和农民</strong>；<strong>党外进步人士</strong>：小资产阶级；中间派：民族资产阶级、开明绅士</p></li>
<li><p><span style="color: green; font-weight: bold">巩固抗日民族统一战线的策略方针：</span></p></li>
</ol>
<ul>
<li><p>总方针：<strong>发展进步势力，争取中间势力，孤立顽固势力</strong></p></li>
<li><p>进步势力：主要指<strong>工人、农民和城市小资产阶级</strong></p></li>
<li><p>中间势力：<strong>民族资产阶级、开明绅士和地方实力派</strong></p></li>
<li><p>顽固势力：大地主、大资产阶级的抗日派，即以蒋介石为代表的国民党亲英美派。（<strong>又联合又斗争</strong>政策，坚持<strong>有理、有利、有节</strong>的斗争原则）</p></li>
</ul>
<ol start="14" type="1">
<li><p><span style="color: red; font-weight: bold">近代化</span>开端：洋务运动；<span style="color: red; font-weight: bold">近代史</span>开端：鸦片战争。</p></li>
<li><p>构建统筹各领域安全的新格局，必须把维护<span style="color: red; font-weight: bold">政治安全</span>作为应对各领域安全与风险挑战的<span style="color: red; font-weight: bold">首要任务</span>；<span style="color: red; font-weight: bold">维护重点领域国家安全</span>是<span style="color: red; font-weight: bold">主阵地、主战场</span>；<span style="color: red; font-weight: bold">经济安全</span>是国家安全的<span style="color: red; font-weight: bold">基础</span>；<span style="color: red; font-weight: bold">牢牢守住安全发展这条底线</span>是构建新发展格局的<span style="color: red; font-weight: bold">重要前提和保障</span>。</p></li>
<li><p>以邓小平<strong>南方谈话</strong>和党的<strong>十四大</strong>为标志，改革开放和现代化建设事业进入从计划经济体制向社会主义市场经济体制转变的<strong>新阶段</strong>。</p></li>
<li><p>党的<strong>十四届二中全会</strong>，将党的十四大提出的社会主义市场经济体制改革的目标和基本原则具体化，<strong>进一步勾画了建立社会主义市场经济体制的基本框架</strong>。</p></li>
<li><p><strong>集体主义</strong>是社会主义道德的<strong>原则</strong>。</p></li>
<li><p><strong>教育</strong>是国家经济社会发展的<strong>支撑力量</strong>，在国家发展中始终具有<strong>基础性先导性全局性地位</strong>。</p></li>
<li><p>社会主义发展道路多样性的<span style="color: red; font-weight: bold">现实原因</span>是<strong>时代和实践的不断发展</strong>；<span style="color: red; font-weight: bold">根本原因</span>是<strong>生产力发展状况和社会发展阶段</strong>。</p></li>
<li><p>中国特色社会主义<strong>最本质的特征</strong>和中国<span style="color: red; font-weight: bold">最大的国情</span>是<strong>党的领导</strong>；<strong>社会主义初级阶段</strong>是我国的<span style="color: red; font-weight: bold">基本国情</span>、<strong>最大实际</strong>。</p></li>
<li><p>建设农业强国<strong>基本要求</strong>是实现<strong>农业现代化</strong></p></li>
<li><p><span style="color: green; font-weight: bold">乡村振兴战略</span></p></li>
</ol>
<ul>
<li><span style="color: red; font-weight: bold">农业农村现代化</span>是<strong>总目标</strong></li>
<li><span style="color: red; font-weight: bold">坚持农业农村优先发展</span>是<strong>总方针</strong></li>
<li>产业兴旺、生态宜居、乡风文明、治理有效、生活富裕是<span style="color: red; font-weight: bold">总要求</span></li>
<li><span style="color: red; font-weight: bold">建立健全城乡融合发展体制机制和政策体系</span>是<strong>制度保障</strong></li>
</ul>
<ol start="24" type="1">
<li><p><span style="color: red; font-weight: bold">自主创新</span>是攀登世界科技高峰的必由之路。</p></li>
<li><p>道德最基本的功能是<strong>认识功能</strong>、<strong>规范功能</strong>、<strong>调节功能</strong>。</p></li>
<li><p>习说的新时代文化使命是<strong>继续推动文化繁荣、建设文化强国、建设中华民族现代文明</strong>。要<strong>坚定文化自信</strong>、<strong>秉持开放包容</strong>、<strong>坚持守正创新</strong>（三点）。</p></li>
<li><p>科学发展观：推动经济社会发展是<span style="color: red; font-weight: bold">第一要义</span>；以人为本是<span style="color: red; font-weight: bold">核心立场</span>；统筹兼顾是<span style="color: red; font-weight: bold">根本方法</span>；全面协调可持续发展是<span style="color: red; font-weight: bold">基本要求</span>。</p></li>
<li><p>推动高质量发展的必由之路是<strong>加快实现高水平科技自立自强</strong>。（高科技）</p></li>
<li><p><strong>走自己的路</strong>是党全部理论和实践的立足点。</p></li>
<li><p><span style="color:green"><strong>新民主主义革命的领导力量</strong></span></p></li>
</ol>
<ul>
<li><p>无产阶级及其政党实现对各革命阶级的领导，必须建立以工农联盟为基础的广泛的<strong>统一战线</strong>，这是实现领导权的<strong>关键</strong>。</p></li>
<li><p>坚持独立自主的原则，保持党在思想上、政治上、组织上的对独立性，实行又联合又斗争的方针，是坚持领导权的<strong>基本方略</strong>。</p></li>
<li><p>建立无产阶级以农民为主体的强大的<strong>革命武装</strong>，是保证领导权的<strong>坚强支柱</strong>。</p></li>
<li><p>加强无产阶级政党的建设，是实现领导权的<strong>根本保证</strong>。</p></li>
<li><p>无产阶级领导权的<strong>中心问题</strong>是<strong>农民问题</strong>，农民问题也是中国革命的<strong>基本问题</strong>。无产阶级的<strong>领导权是中国革命的中心问题</strong>，也是新民主主义革命理论的<strong>核心问题</strong>。<strong>分清敌友</strong>是中国革命的<strong>首要问题</strong>。</p></li>
</ul>
<p><img src="/2023/12/08/%E6%94%BF%E6%B2%BB%E9%80%89%E6%8B%A9%E9%A2%98/image1.png" style="zoom:60%;"></p>
<ol start="30" type="1">
<li><p>社会主义工商业改造中，第一步实行初级形式的国家资本主义。
在<strong>私营工业</strong>中实行<strong>委托加工</strong>、<strong>计划订货</strong>、<strong>统购包销</strong>；在<strong>私营商业</strong>中采取委托<strong>经销、代销</strong>等形式。</p></li>
<li><p><span style="color: green; font-weight: bold">现代化产业体系</span></p></li>
</ol>
<ul>
<li><p><strong>保持优势产业的领先地位</strong>，是支撑我国国际竞争力的<strong>基石</strong>。</p></li>
<li><p><strong>战略性新兴产业</strong>具有<strong>先导性</strong>，代表新一轮科技革命和产业变革的方向，是引领国家未来产业发展的<strong>决定性力量</strong>。</p></li>
<li><p><strong>现代服务业</strong>是现代化产业体系的<strong>重要支撑</strong>。</p></li>
<li><p><strong>基础设施</strong>是经济社会发展的<strong>重要支撑</strong>。</p></li>
</ul>
<ol start="32" type="1">
<li><p>中国革命<strong>道德的灵魂</strong>是为<strong>实现社会主义和共产主义的理想信念</strong>而奋斗。</p></li>
<li><p>垄断利润的形成<strong>关键</strong>在于<strong>垄断组织在经济生活中起了决定性作用</strong>,从而阻碍了资本在各部门之间的自由转移,限制了利润平均化的趋势。</p></li>
<li><p>构建新发展格局的关键在于实现经济循环的畅通无阻。能否实现,主要<strong>取决于供给和需求两端是否动力强劲、总体匹配,动态平衡、良性互动</strong>。</p></li>
<li><p>太平天国运动是中国近代史上<strong>第一次反对国内封建势力和外国侵略</strong>的斗争。
三元里人民抗英是中国近代史上中国人民<strong>第一次大规模的反侵略</strong>武装斗争。</p></li>
<li><p><strong>抽象劳动</strong>是价值的<strong>唯一源泉</strong>。剩余价值是资本积累的源泉，<strong>资本积累</strong>是资本主义<strong>扩大再生产的源泉</strong>。</p></li>
<li><p><span style="color: green; font-weight: bold">六个坚持</span></p></li>
</ol>
<ul>
<li><p>坚持人民至上是<span style="color: red; font-weight: bold">根本价值立场</span>，体现唯物主义群众史观</p></li>
<li><p>坚持自信自立是<span style="color: red; font-weight: bold">内在精神特质</span>，体现了客观规律性和主观能动性的有机结合</p></li>
<li><p>坚持守正创新是<span style="color: red; font-weight: bold">鲜明理论品格</span>，体现了变与不变、继承与发展的内在联系</p></li>
<li><p>坚持问题导向是<span style="color: red; font-weight: bold">重要实践要求</span>，体现了矛盾的普遍性和客观性</p></li>
<li><p>坚持系统观念是<span style="color: red; font-weight: bold">基本思想和工作方法</span>，体现了辩证唯物主义普遍联系的原理</p></li>
<li><p>坚持胸怀天下是<span style="color: red; font-weight: bold">中国共产党人境界格局</span>，体现了马克思主义追求人类进步和解放的崇高理想</p></li>
</ul>
<ol start="38" type="1">
<li><p>建设高水平自贸试验区：坚持党的全面领导，坚持以<strong>高水平开放</strong>为<strong>引领</strong>、以<strong>制度创新</strong>为<strong>核心</strong>，统筹发展和安全，高标准对接国际经贸规则，深入推进制度型开放，加强改革整体谋划和系统集成，推动全产业链创新发展，让自贸试验区更好发挥示范作用。</p></li>
<li><p>东北全面振兴：<strong>根基</strong>在<strong>实体经济</strong>，<strong>关键</strong>在<strong>科技创新</strong>，<strong>方向</strong>是<strong>产业升级</strong>；以<strong>发展现代化大农业</strong>为<strong>主攻方向</strong>，加快推进农业农村现代化；当好国家粮食稳产保供“<strong>压舱石</strong>”,是东北的<strong>首要担当</strong>。</p></li>
<li><p><span style="color: green; font-weight: bold">当代资本主义变化的新特征——资产阶级内部层级结构日趋复杂</span></p></li>
</ol>
<ul>
<li><p><strong>最高层</strong>是<strong>极少数国际金融垄断寡头阶层</strong>；</p></li>
<li><p>第二层是与前者联合，以<strong>能源、军工、高科技</strong>利益集团为主体的<strong>国际金融-产业垄断阶层</strong>；</p></li>
<li><p>第三层是占据各产业垄断地位的<strong>产业垄断资本家</strong>阶层</p></li>
<li><p>第四层是由<strong>经理资本家、食利者阶层、中小企业资本家</strong>等构成的<strong>一般资产阶级阶层</strong>。</p></li>
</ul>
<ol start="41" type="1">
<li><span style="color: green; font-weight: bold">长江经济带高质量发展座谈会</span></li>
</ol>
<ul>
<li><p>坚持把<strong>强化区域协同融通</strong>作为<span style="color: red; font-weight: bold">着力点</span></p></li>
<li><p>把<strong>产业绿色转型升级作</strong>为<span style="color: red; font-weight: bold">重中之重</span>；坚持创新引领发展，把长江经济带的科研优势、人才优势转化为发展优势</p></li>
<li><p>推动长江经济带高质量发展<strong>根本上</strong>依赖于<strong>长江流域高质量的生态环境</strong></p></li>
</ul>
<ol start="42" type="1">
<li><span style="color: green; font-weight: bold">《党和国家机构改革方案》</span></li>
</ol>
<ul>
<li><p>深化党和国家机构改革，<span style="color: red; font-weight: bold">目标</span>是<strong>构建系统完备、科学规范、运行高效的党和国家机构职能体系</strong></p></li>
<li><p>以习思想为<span style="color: red; font-weight: bold">指导</span></p></li>
<li><p>以<strong>加强党中央集中统一领导</strong>为<span style="color: red; font-weight: bold">统领</span></p></li>
<li><p>以推进国家<strong>治理体系和治理能力现代化</strong>为<span style="color: red; font-weight: bold">导向</span></p></li>
<li><p>坚持<strong>稳中求进</strong>工作<span style="color: red; font-weight: bold">总基调</span></p></li>
</ul>
<ol start="43" type="1">
<li><span style="color: green; font-weight: bold">资本主义生产关系产生途径</span></li>
</ol>
<ul>
<li><p>从小商品经济分化出来</p></li>
<li><p>从商人和高利贷者转化而成</p></li>
</ul>
<ol start="44" type="1">
<li><span style="color: green; font-weight: bold">无产阶级要实现对同盟者的领导必须具备的条件</span></li>
</ol>
<ul>
<li><p>率领同盟者向着共同的敌人作坚决的斗争，并取得胜利</p></li>
<li><p>对同盟者给予物质福利，至少不损害其利益，同时给予政治教育</p></li>
</ul>
<ol start="45" type="1">
<li><span style="color: green; font-weight: bold">独立自主是党百年奋斗的十大历史经验之一</span></li>
</ol>
<ul>
<li><span style="color: red;  font-weight: bold">独立自主</span>是<strong>中华民族精神之魂</strong>，是我们<strong>立党立国的重要原则</strong></li>
<li><span style="color: red; font-weight: bold">密切联系群众</span>是中国共产党的<strong>最大政治优势</strong></li>
<li><span style="color: red; font-weight: bold">人民立场</span>是我们党<strong>区别于其他政党的显著标志</strong>，是<strong>根本立场</strong></li>
</ul>
<ol start="46" type="1">
<li><p><span style="color: green; font-weight: bold">党的七大</span></p>
<p>党的七大标志着我们党在政治上、思想上、组织上走向了成熟。</p></li>
</ol>
<ul>
<li>在政治上，党通过延整风，使全党团结在毛泽东的旗帜下，实现了党的空前统一和团结</li>
<li>在思想上，党确立了毛泽东思想在全党的指导地位，把毛泽东思想写入党章</li>
<li>在组织上，党形成了一支高举毛泽东旗帜的久经考验的政治家集团</li>
</ul>
<ol start="47" type="1">
<li><span style="color: green; font-weight: bold">中国特色社会主义法治道路核心要义</span></li>
</ol>
<ul>
<li>坚持党的领导</li>
<li>坚持中国特色社会主义制度</li>
<li>贯彻中国特色社会主义法治理论</li>
</ul>
<ol start="48" type="1">
<li><span style="color: green; font-weight: bold">金融工作会议</span></li>
</ol>
<ul>
<li>金融工作必须坚持党中央对金融工作的集中统一领导（<span style="color: red; font-weight: bold">根本保证</span>），坚持<strong>以人民为中心</strong>的<span style="color: red; font-weight: bold">价值取向</span></li>
<li>把金融<strong>服务实体经济</strong>作为<span style="color: red; font-weight: bold">根本宗旨</span></li>
<li>坚持把<strong>防控风险</strong>作为金融工作的<span style="color: red; font-weight: bold">永恒主题</span></li>
<li>坚持在市场化法治化轨道上推进⾦融创新发展，坚持深化⾦融供给侧结构性改⾰（<span style="color: red; font-weight: bold">主线</span>），坚持统筹⾦融开放和安全，坚持<strong>稳中求进</strong>⼯作<span style="color: red; font-weight:bold">总基调</span>(8个坚持)</li>
</ul>
<ol start="49" type="1">
<li><span style="color: green; font-weight: bold">第三届“一带一路”国际合作高峰论坛</span></li>
</ol>
<ul>
<li><span style="color: red; font-weight: bold">最清晰信号</span>是团结合作、开放共赢</li>
<li><span style="color: red; font-weight: bold">最重要共识</span>是开启高质量共建“一带一路”新阶段</li>
<li><span style="color: red; font-weight: bold">最宏伟愿景</span>是携手实现世界现代化</li>
<li><span style="color: red; font-weight: bold">最鲜明特色</span>是行动导向高效务实</li>
</ul>
<ol start="50" type="1">
<li><span style="color: green; font-weight: bold">价值规律在市场配置资源过程中的作用</span></li>
</ol>
<ul>
<li>自发地调节生产资料和劳动力在社会各生产部门之间的分配比例</li>
<li>自发地刺激社会生产力的发展</li>
<li>自发地调节社会收入分配</li>
</ul>
<ol start="51" type="1">
<li>法律至上具体表现为<strong>法律的普遍适用</strong>、<strong>优先适用</strong>和<strong>不可违反</strong></li>
<li><span style="color: red; font-weight: bold">《在晋绥干部会议上的讲话》完整总结概括了新民主主义革命总路线的内容</span>，即物产阶级领导的，人民大众的，反对帝国主义、封建主义和官僚资本主义的革命。
<span style="color: red; font-weight: bold">《中国革命和中国共产党》第一次提出了“新民主主义的革命”的科学概念</span><br>
</li>
<li><span style="color: green; font-weight: bold">党的领导制度是我国的根本领导制度</span></li>
</ol>
<ul>
<li>党的领导制度是中国特色社会主义<strong>制度建设</strong>的<span style="color:red; font-weight: bold">关键</span>；是国家治理体系的核心。</li>
<li>健全党的全面领导制度、确保党在各种组织中发挥领导作用是<span style="color:red; font-weight: bold">主体内容</span></li>
</ul>
<ol start="54" type="1">
<li><span style="color:red; font-weight: bold">协商民主</span>是中国特色社会主义民主政治中<strong>独特的、独有的、独到的</strong>民主形式</li>
<li><span style="color: green; font-weight: bold">全面抗战的路线和持久战的战略总方针</span></li>
</ol>
<ul>
<li>在陕北<span style="color: red; font-weight: bold">洛川</span>召开政治局扩大会议，制定了抗日救国十大纲领，强调要打倒日本帝国主义关键在于使已经发动的抗战成为<strong>全面的全民族的抗战</strong>。</li>
<li>会议强调了
<ul>
<li>坚持统一战线中无产阶级的<strong>领导权</strong></li>
<li>在敌人后方放手发动独立自主的<strong>山地游击战</strong></li>
<li>在国民党统治区放手发动抗日的群众运动</li>
</ul></li>
<li><mark>（在<span style="color: red; font-weight: bold">瓦窑堡会议</span>上提出了党的基本策略任务是建立广泛的抗日民族统一战线）</mark></li>
</ul>
<ol start="56" type="1">
<li><span style="color: green; font-weight: bold">邓小平改革开放坚持的根本原则</span></li>
</ol>
<ul>
<li>社会主义公有制经济为主体</li>
<li>共同富裕</li>
</ul>
<ol start="57" type="1">
<li><span style="color: green; font-weight: bold">中国加入世界贸易组织</span></li>
</ol>
<p><img src="/2023/12/08/%E6%94%BF%E6%B2%BB%E9%80%89%E6%8B%A9%E9%A2%98/image-20231210195251321.png" alt="image-20231210195251321" style="zoom:67%;"></p>
<ol start="58" type="1">
<li><p>社会主义核心价值观的<strong>基础和首要要求</strong>是<span style="color: red; font-weight: bold">爱国</span></p></li>
<li><p><span style="color: red; font-weight: bold">个人品德建设</span>在社会道德建设中具有<strong>基础性</strong>作用</p></li>
<li><p><span style="color: green; font-weight: bold">世界互联网大会乌镇峰会</span></p></li>
</ol>
<ul>
<li><strong>主题</strong>：建设<span style="color: red; font-weight: bold">包容</span>、<span style="color: red; font-weight: bold">普惠</span>、<span style="color: red; font-weight: bold">有韧性</span>的数字世界——携手构建网络空间命运共同体。</li>
<li>致辞：倡导<span style="color: red; font-weight: bold">发展优先</span>，构建更加<strong>普惠繁荣</strong>的网络空间；倡导<span style="color: red; font-weight: bold">安危与共</span>，构建更加<strong>和平安全</strong>的网络空间；倡导<span style="color: red; font-weight: bold">文明互鉴</span>，构建更加<strong>平等包容</strong>的网络空间。</li>
</ul>
<ol start="61" type="1">
<li><p>中国式现代化的关键是<span style="color: red; font-weight: bold">科技现代化</span></p></li>
<li><p>亚洲价值观的核心是<span style="color:red; font-weight: bold">和平、合作、包容、融合</span></p></li>
<li><p>社会主义民主政治的<strong>本质属性</strong>是<span style="color: red; font-weight: bold">全过程人民民主</span></p></li>
<li><p>社会经济权利：劳动权，休息权，社会保障权，物质帮助权。<mark>(私有财产权、继承权是财产权利)</mark></p></li>
<li><p><span style="color: green; font-weight: bold">当代资本主义变化的新特征</span></p></li>
</ol>
<p><img src="/2023/12/08/%E6%94%BF%E6%B2%BB%E9%80%89%E6%8B%A9%E9%A2%98/image-20231217100303766.png" alt="image-20231217100303766" style="zoom:80%;"></p>
<p><img src="/2023/12/08/%E6%94%BF%E6%B2%BB%E9%80%89%E6%8B%A9%E9%A2%98/image-20231217100331618.png" alt="image-20231217100331618" style="zoom:80%;"></p>
<ol start="66" type="1">
<li><span style="color: red; font-weight: bold">全面深化改革开放</span>，是<strong>新时代坚持和发展中国特色社会主义的根本动力</strong>。</li>
<li><span style="color: red; font-weight: bold">党性原则</span>是新闻舆论工作的<strong>根本原则</strong>，坚持党性原则<strong>最根本</strong>的是<strong>坚持党对新闻舆论工作的领导</strong>。</li>
<li><span style="color: green; font-weight: bold">主题教育</span></li>
</ol>
<ul>
<li><span style="color: red; font-weight: bold">总要求</span>：学思想、强党性、重实践、建新功</li>
<li><span style="color: red; font-weight: bold">根本任务</span>：坚持学思用贯通、知信行统一</li>
</ul>
<ol start="69" type="1">
<li><p>社会发展进步<strong>集中表现</strong>为<span style="color: red; font-weight: bold">社会形态的更替</span>。<strong>人的发展</strong>，<strong>最根本</strong>的是人的<span style="color: red; font-weight: bold">自由程度的提高</span>，人的发展程度构成了社会进步的重要标志。物质资料的生产方式发展变化决定整个社会历史的发展变化和社会形态的更替。</p></li>
<li><p><strong>公正</strong>是人类社会进步的<strong>标尺</strong>，是社会主义制度的本质要求。法治是现代社会的主要特征。<mark>诚信是社会存续和发展的重要价值基石</mark>。</p></li>
<li><p><span style="color: green; font-weight: bold">统战工作</span></p></li>
</ol>
<ul>
<li><strong>本质要求</strong>是<span style="color: red; font-weight: bold">大团结大联合</span></li>
<li><strong>关键</strong>是坚持<span style="color: red; font-weight: bold">求同存异</span></li>
<li><strong>党的领导</strong>是统一战线<span style="color: red; font-weight: bold">最鲜明的特征</span></li>
</ul>
]]></content>
      <categories>
        <category>研究生入学考试</category>
        <category>政治选择题</category>
      </categories>
      <tags>
        <tag>政治</tag>
      </tags>
  </entry>
  <entry>
    <title>经验贴</title>
    <url>/2024/04/04/%E7%BB%8F%E9%AA%8C%E8%B4%B4/</url>
    <content><![CDATA[<p>首先挂一个我拉的QQ考研交流群<strong>433955962</strong>，想接点答疑赚点零花钱。</p>
<hr>
]]></content>
      <categories>
        <category>研究生入学考试</category>
        <category>记录贴</category>
      </categories>
      <tags>
        <tag>考研的句号</tag>
      </tags>
  </entry>
  <entry>
    <title>统计学习方法</title>
    <url>/2024/04/19/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h2 id="机器学习分类">机器学习分类</h2>
<h3 id="监督学习">监督学习</h3>
<p>监督学习(Supervised Learning)
是指从<strong>标注数据</strong>中学习<strong>预测模型</strong>的机器学习问题，<strong>本质是学习输入到输出的映射的统计规律</strong>。</p>
<ul>
<li>输入空间：输入的所有可能取值的集合</li>
<li>实例：每一个具体的输入，通常由特征向量表示</li>
<li>特征空间：所有特征向量存在的空间</li>
<li>输出空间：输出的所有可能取值的集合</li>
</ul>
<p>根据变量类型不同，可分为不同的问题：</p>
<ul>
<li>回归问题：输入变量和输出变量均为连续变量的预测问题</li>
<li>分类问题：输出变量为有限个离线变量的预测问题</li>
<li>标注问题：输入变量与输出变量均为变量序列的预测问题</li>
</ul>
<p>监督学习流程图：</p>
<p><img src="/2024/04/19/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/image-20240419174842251.png" alt="image-20240419174842251" style="zoom:67%;"></p>
<h3 id="无监督学习">无监督学习</h3>
<p>无监督学习(Unsupervised
Learning)是指从<strong>无标注数据</strong>中学习<strong>预测模型</strong>的机器学习问题，<strong>本质是学习数据中的统计规律或潜在结构</strong>。</p>
<p>无监督学习流程图：</p>
<p><img src="/2024/04/19/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/image-20240419175607134.png" alt="image-20240419175607134" style="zoom:67%;"></p>
<h3 id="强化学习">强化学习</h3>
<p>强化学习流程图</p>
<p><img src="/2024/04/19/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/image-20240419175722038.png" alt="image-20240419175722038" style="zoom:67%;"></p>
<h3 id="统计学学习方法三要素">统计学学习方法三要素</h3>
<p>三要素包括<strong>模型、策略和算法</strong></p>
<h4 id="监督学习三要素">监督学习三要素</h4>
<p><strong>假设空间</strong>：所有可能得条件概率分布或决策函数，用<span class="math inline">\(\mathcal{F}\)</span>表示。</p>
<ul>
<li><p>模型：监督学习模型可表示为条件概率分布或决策函数</p></li>
<li><p>策略</p>
<p>损失函数：度量模型一次预测的好坏，记作<span class="math inline">\(L(Y, f(X))\)</span></p>
<p>风险函数：度量平均意义下模型预测的好坏，<span class="math inline">\(R_{exp}(f) = E_p[L(Y, f(X))]=\int_{x × y}L(y,
f(x))P(x, y)dxdy\)</span></p>
<p>经验风险：模型<span class="math inline">\(f(X)\)</span>关于训练集的平均损失，<span class="math inline">\(R_{emp}(f) =
\frac{1}{N}\sum\limits_{i=1}\limits^{N}L(y_i,f(x_i))\)</span></p>
<p>在N趋向于无穷的时候，经验风险趋向于exp风险。但是在实际中，N的范围不可能趋向无穷，会出现过拟合的情况，因此引入惩罚项得到结构风险<span class="math inline">\(R_{srm}=\frac{1}{N}\sum\limits_{i=1}\limits^{N}L(y_i,
f(x_i)) + \lambda J(f)\)</span></p></li>
<li><p>算法</p>
<p>算法就是如何求解最优模型的问题。</p>
<p>如果最优模型存在显式解析解，算法简单，通常不存在解析解，需要数值计算方法，比如梯度下降法。</p></li>
</ul>
<h4 id="无监督学习的三要素">无监督学习的三要素</h4>
<ul>
<li>模型：函数<span class="math inline">\(z=g_\theta
(x)\)</span>，条件概率分布<span class="math inline">\(P_\theta(z|x)\)</span>或条件概率分布<span class="math inline">\(P_\theta(x|z)\)</span></li>
<li>策略：优化目标函数</li>
<li>算法：通常是迭代算法</li>
</ul>
<h3 id="泛化能力">泛化能力</h3>
<ul>
<li><p>泛化误差：如果学习到的模型是<span class="math inline">\(\hat{f}\)</span>，那么这个模型对于未知数据预测的误差即为泛化误差。<span class="math inline">\(R_{exp}(\hat{f}) = E_p[L(Y, \hat{f}(X))]=\int_{x ×
y}L(y, \hat{f}(x))P(x, y)dxdy\)</span></p></li>
<li><p>泛化误差上界：指泛化误差的概率上界。两种学习方法的优劣，通常通过它们的泛化误差上界进行比较。</p>
<p>泛化误差上届具有的性质：</p>
<ul>
<li>样本容量的函数：当样本容量增加时，泛化上界趋于0</li>
<li>假设空间容量的函数：假设空间容量越大，模型就越难学，泛化误差上界就越大。</li>
</ul></li>
</ul>
<h2 id="感知机">感知机</h2>
<h3 id="模型介绍">模型介绍</h3>
<p>感知机是二分类的线性模型。</p>
<ul>
<li><p>输入空间：<span class="math inline">\(\mathcal{X} \subseteq
R^n\)</span>；输入<span class="math inline">\(x=(x^{1},x^{2},...,
x^{n})^T\in \mathcal{X}\)</span></p></li>
<li><p>输出空间：<span class="math inline">\(\mathcal{Y}=\{+1,-1\}\)</span>; 输出<span class="math inline">\(y\in\mathcal{Y}\)</span></p></li>
<li><p>感知机：<span class="math display">\[f(x)=sign(wx+b)=\begin{cases} +1, wx+b\ge0 \\ -1,
wx+b &lt; 0 \end{cases}\]</span></p>
<p>其中，<span class="math inline">\(w=(w^{1},w^{2},..., w^{n})\in
R^n\)</span>称为权值，b称为偏置</p></li>
<li><p>假设空间：<span class="math inline">\(\mathcal{F}=\{f|f(x)=wx+b\}\)</span></p></li>
</ul>
<p><span class="math inline">\(wx+b=0\)</span>是特征空间<span class="math inline">\(R^n\)</span>中的一个超平面S，法向量为w，
截距为b。</p>
<p><strong>超平面</strong>是指n维线性空间中维度为n-1的子空间。它可以把线性空间分割成不相交的两部分。比如二维空间中，一条直线是一维的，它把平面分成了两块；三维空间中，一个平面是二维的，它把空间分成了两块。</p>
<p>模型流程图:</p>
<p><img src="/2024/04/19/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/image-20240421211708923.png" alt="image-20240421211708923" style="zoom:67%;"></p>
<h3 id="学习策略">学习策略</h3>
<p>感知机模型的数据集要具有线性可分性。可分性即给定数据集，存在某个超平面可以将数据集的正负实例点完全正确的划分到超平面的两侧。</p>
<ul>
<li>误分类点<span class="math inline">\(x_i\)</span>到<strong>S</strong>的距离：<span class="math inline">\(-\frac{1}{||w||}y_i(wx_i+b)\)</span></li>
<li>所有误分类点到<strong>S</strong>的距离：<span class="math inline">\(-\frac{1}{||w||}\sum\limits_{x_x\in M
}y_i(wx_i+b)\)</span>,M代表所有误差分类点的集合。</li>
<li>损失函数：<span class="math inline">\(L(w, b)=-\sum\limits_{x_i\in
M}y_i(wx_i+b)\)</span></li>
</ul>
<h4 id="梯度下降法">梯度下降法</h4>
<p><strong>相关概念</strong></p>
<ul>
<li>梯度：指某一函数在该点处最大的方向导数，沿着该方向可取得最大的变化率。<span class="math inline">\(\bigtriangledown = \frac{\partial
f(\theta)}{\partial \theta}\)</span></li>
<li>若<span class="math inline">\(f(\theta)\)</span>是凸函数，可通过梯度下降法进行优化：<span class="math inline">\(\theta^{(k+1)} = \theta^{(k)}-\eta
\bigtriangledown f(\theta^{(k)})\)</span></li>
</ul>
<p><strong>算法</strong></p>
<ul>
<li><p>输入：目标函数<span class="math inline">\(f(\theta)\)</span>,
步长<span class="math inline">\(\eta\)</span>，计算精度<span class="math inline">\(\varepsilon\)</span></p></li>
<li><p>输出：<span class="math inline">\(f(\theta)\)</span>的极小值点<span class="math inline">\(\theta^{*}\)</span></p>
<blockquote>
<ol type="1">
<li>选取初识值<span class="math inline">\(\theta^{(0)}\in
R^n\)</span>，置k = 0</li>
<li>计算<span class="math inline">\(f(\theta^{(k)})\)</span></li>
<li>计算梯度<span class="math inline">\(\bigtriangledown
f(\theta^{(k)})\)</span></li>
<li>置<span class="math inline">\(\theta^{(k+1)}=\theta^{(k)}-\eta
\bigtriangledown f(\theta^{(k)})\)</span>,计算<span class="math inline">\(f(\theta^{(k+1)})\)</span>，当<span class="math inline">\(||f(\theta^{(k+1)})- f(\theta^{(k)})|| &lt;
\varepsilon\)</span>或者<span class="math inline">\(||\theta^{(k+1)}-\theta^{(k)}|| &lt;
\varepsilon\)</span>时，停止迭代，令<span class="math inline">\(\theta^*=\theta^{(k+1)}\)</span></li>
<li>否则，置k = k + 1， 转3执行。</li>
</ol>
</blockquote></li>
</ul>
<h4 id="原始形式学习算法">原始形式学习算法</h4>
<p>训练数据集：<span class="math inline">\(T=\{(x_1, y_1),(x_2,
y_2),(x_3, y_3),...,(x_N, y_N)\}\)</span>,其中<span class="math inline">\(x_i\in \mathcal{X} \subseteq R^n\)</span>，<span class="math inline">\(y_i\in\mathcal{Y}=\{+1, -1\}\)</span></p>
<p>损失函数: <span class="math inline">\(L(w,b)=-\sum\limits_{x_i\in
M}y_i(wx_i+b)\)</span></p>
<p>模型参数估计：<span class="math inline">\(arg\  min
_{w,b}L(w,b)\)</span></p>
<p><strong>随机梯度下降法</strong></p>
<ul>
<li><p>梯度：<span class="math inline">\(\bigtriangledown _wL(w,
b)=-\sum\limits_{x_i\in M}y_ix_i\)</span>, <span class="math inline">\(\bigtriangledown_bL(w,b)=-\sum\limits_{x_i\in
M}y_i\)</span></p></li>
<li><p>参数更新：批量梯度下降法，即每次迭代时使用所有误分类点来进行参数更新：</p>
<p><span class="math inline">\(w \leftarrow w + \eta \sum\limits_{x_i\in
M}y_ix_i, \ \ b \leftarrow b + \eta \sum\limits_{x_i\in
M}y_i\)</span></p></li>
<li><p>随机梯度下降法：每次随机选取一个误分类点进行参数更新：</p>
<p><span class="math inline">\(w \leftarrow w + \eta y_ix_i, \ \ b
\leftarrow b + \eta y_i\)</span></p></li>
</ul>
<p><strong>算法步骤</strong></p>
<blockquote>
<ol type="1">
<li>选取 初始值<span class="math inline">\(w_0, b_0\)</span></li>
<li>在数据集中随机选择数据<span class="math inline">\((x_i,
y_i)\)</span></li>
<li>若<span class="math inline">\(y_i(wx_i+n)\le 0\)</span>, <span class="math inline">\(w \leftarrow w + \eta y_ix_i, \ \ b \leftarrow b +
\eta y_i\)</span></li>
<li>转2，直到训练集中没有误分类点。</li>
</ol>
</blockquote>
<h4 id="对偶形式学习算法">对偶形式学习算法</h4>
<p><strong>对偶形式</strong></p>
<p>在原始形式中，若<span class="math inline">\((x_i,
y_i)\)</span>为误分类点，可如下更新参数</p>
<p><span class="math inline">\(w \leftarrow w + \eta y_ix_i, \ \ b
\leftarrow b + \eta y_i\)</span></p>
<p>假设初始值<span class="math inline">\(w_0=0,b_0=0\)</span>，
对误差分类点<span class="math inline">\((x_i,
y_i)\)</span>通过上述公式更新参数，修改<span class="math inline">\(n_i\)</span>次之后，<span class="math inline">\(w,b\)</span>的增量分别为<span class="math inline">\(\alpha_iy_ix_i\)</span>和<span class="math inline">\(\alpha_iy_i\)</span>，其中<span class="math inline">\(\alpha_i=n_i\eta\)</span></p>
<p>最后学习到的参数为，<span class="math inline">\(w=\sum\limits_{i=1}\limits^{N}\alpha_iy_ix_i;\
\  \ b=\sum\limits_{i=1}\limits^{N}\alpha_iy_i\)</span></p>
<p><strong>算法步骤</strong></p>
<ul>
<li><p>输入训练集：<span class="math inline">\(T=\{(x_1, y_1),(x_2,
y_2),(x_3, y_3),...,(x_N, y_N)\}\)</span>,其中<span class="math inline">\(x_i\in \mathcal{X} \subseteq R^n\)</span>，<span class="math inline">\(y_i\in\mathcal{Y}=\{+1, -1\}\)</span></p></li>
<li><p>输出：<span class="math inline">\(\alpha,
b\)</span>；感知机模型<span class="math inline">\(f(x)=sign(\sum\limits_{j=1}\limits^N\alpha_jy_jx_j
\cdot x + b), \alpha=(\alpha_1,
\alpha_2,...,\alpha_N)^T\)</span></p></li>
</ul>
<blockquote>
<ol type="1">
<li>选取初始值<span class="math inline">\(\alpha^{&lt;0&gt;}=(0, 0, ...,
0), b^{&lt;0&gt;}=0\)</span>;</li>
<li>在训练集中随机选取数据<span class="math inline">\((x_i,
y_i)\)</span>；</li>
<li>若<span class="math inline">\(y_i(\sum\limits_{j=1}\limits^N\alpha_jy_jx_j \cdot
x_i + b) \le 0\)</span>, <span class="math inline">\(\alpha_i \leftarrow
\alpha_i + \eta;\ \ \ b \leftarrow b + \eta y_i\)</span></li>
<li>转2，直到训练集中没有误分类点</li>
</ol>
</blockquote>
<h2 id="k近邻法">k近邻法</h2>
<h3 id="理解与相关概念">理解与相关概念</h3>
<p>K近邻法(k-nearest neighbor, k-NN)是一种基本的分类与回归方法。</p>
<p><strong>主要思想</strong>：假定给定一个训练数据集，其中实例标签已定，当输入新的实例时，可以根据其最近的k个训练实例的标签，预测新实例对应的标注信息。</p>
<ul>
<li>分类问题：对新的实例，根据与之相邻的k个训练实例的类别，通过多数表决等方式进行预测</li>
<li>回归问题：对新的实例，根据与之相邻的k个训练实例的标签，通过均值计算进行预测</li>
</ul>
<p><strong>算法</strong></p>
<ul>
<li><p>输入训练集：<span class="math inline">\(T={(x_1, y_1), (x_2,
y_2),...,(x_N, y_N)}\)</span>,其中<span class="math inline">\(x_i\in\mathcal{X}\subseteq R^n,
y\in\mathcal{Y}=\{c_1, c_2,...,c_K\}\)</span>;输出为实例<span class="math inline">\(x\)</span>所属的类别y</p></li>
<li><p>算法步骤：</p>
<blockquote>
<ol type="1">
<li><p>根据给定的<strong>距离度量</strong>，计算x与T中点的距离；</p></li>
<li><p>在T中找到与x最邻近的<em>k</em>个点，涵盖这k个点的x的邻域记作<span class="math inline">\(N_k(x)\)</span>；</p></li>
<li><p>在<span class="math inline">\(N_k(x)\)</span>中根据<strong>决策规则</strong>（如多数表决）决定x的类别y。</p>
<p><span class="math inline">\(y=arg \ \ max_{c_j} \sum\limits_{x_i\in
N_k(x)}I(y_i=c_i), i=1, 2,...,N;j=1, 2,...,K\)</span></p></li>
</ol>
</blockquote></li>
</ul>
<h3 id="三要素">三要素</h3>
<p><strong>模型</strong>：k近邻法不具有显性的学习过程，实际上利用训练数据集对特征向量空间进行划分，以其作为分类的“模型”。</p>
<h4 id="距离度量">距离度量</h4>
<p><strong><span class="math inline">\(L_p\)</span>距离</strong>：特征空间<span class="math inline">\(\mathcal{X}\)</span>假设为<span class="math inline">\(R^n\)</span>，<span class="math inline">\(\forall
x_i, x_j\in \mathcal{X}, \  x_i=(x_i^{(1)}, x_i^{(2)}, ...,
x_i^{(n)})^T, \ x_j=(x_j^{(1)}, x_j^{(2)}, ...,
x_j^{(n)})^T\)</span>,则有</p>
<p><span class="math inline">\(L_p(x_i, x_j) =
(\sum\limits_{I=1}\limits^{n}|x_i^{(I)}-x_j^{(I)}|^p)^{\frac{1}{p}}, \ p
\ge 1\)</span></p>
<p>p取2时为<strong>欧氏距离</strong>。</p>
<p>P取1时为<strong>曼哈顿距离</strong></p>
<p>p为无穷大时为切<strong>比雪夫不距离</strong>：<span class="math inline">\(L_{\infty}=max_I|x_i^{(I)}-x_j^{(I)}|\)</span></p>
<h4 id="k值的选择"><em>k</em>值的选择</h4>
<ul>
<li><p>较小的k值，学习的近似误差较小，但估计误差增大，敏感性增强，而且模型复杂，容易过拟合。</p></li>
<li><p>较大的k值，减小学习的估计误差，但近似误差增大，而且模型简单。</p>
<p>k的取值可以通过交叉验证来选择，一般低于训练集样本量的平方跟。</p></li>
</ul>
<h4 id="分类决策规则">分类决策规则</h4>
<p><strong>多数表决规则</strong>：由输入实例的<em>k</em>个邻近的训练实例中的多数类决定输入实例的类。</p>
<ul>
<li>分裂函数: <span class="math inline">\(f:R^n \rightarrow {c_1, c_2,
..., c_K}\)</span></li>
<li>0-1损失函数：<span class="math display">\[L(Y, f(X))=\begin{cases}1,
Y \ne f(X) \\ 0, Y = f(X) \end{cases}\]</span></li>
<li>误分类概率：<span class="math inline">\(P(Y\ne
f(X))=1-P(Y=f(X))\)</span></li>
</ul>
<p>对于给定实例<span class="math inline">\(x\in
\mathcal{X}\)</span>，相应的<em>k</em>邻域<span class="math inline">\(N_k(x)\)</span>, 类别为<span class="math inline">\(c_j\)</span>，误分类率为<span class="math inline">\(\frac{1}{k}\sum\limits_{x_i\in N_k(x)}I(y_i\ne
c_j)=1-\frac{1}{k}\sum\limits_{x_i\in N_k(x)}I(y_i=c_j)\)</span>;
最小化误分类率，等价于<span class="math inline">\(arg \ \ max \sum
\limits_{x_i\in N_k(x)}I(y_i=c_j)\)</span></p>
<h3 id="kd树"><em>kd</em>树</h3>
<p><em>kd</em>树是一种对k维空间中的实例点进行存储以便对其进行快速检索的树形数据结构。</p>
<p>本质是二叉树，表示对k维空间的一个划分</p>
<p><strong>构造过程</strong>：不断地用垂直于坐标轴的超平面将k维空间切分，形成k维超矩形区域。<em>kd</em>树中的每一个结点对应于一个k维超矩形区域。</p>
<p><strong>构造<em>kd</em>树算法</strong></p>
<ul>
<li><p>输入：<em>k</em>维空间数据集<span class="math inline">\(T=\{x_1,
x_2,...,x_N\}\)</span>, 其中<span class="math inline">\(x_i=(x_i^{(1)}),
x_i^{(2)}),...,x_i^{(k)})^T\)</span></p></li>
<li><p>输出：<em>kd</em>树</p>
<blockquote>
<ol type="1">
<li>开始，构造根节点。
<ul>
<li>选取<span class="math inline">\(x^{(1)}\)</span>为坐标轴，以训练集中的所有数据<span class="math inline">\(x^{(1)}\)</span>坐标中的中位数作为切分点，将超矩形区域切割成两个字区域，将该切分点作为根节点。</li>
<li>由根节点生出深度为1的左右子节点，左节点对应坐标小于切分点，右节点对应坐标大于切分点。</li>
</ul></li>
<li>重复
<ul>
<li>对深度为j的节点，选择<span class="math inline">\(x^{(I)}\)</span>为切分坐标轴，<span class="math inline">\(I=j( mod \ k) + 1\)</span>,
以该节点区域中所有实例<span class="math inline">\(x^{(I)}\)</span>坐标的中位数作为切分点，将区域划分为两个子区域。</li>
<li>生成深度为j+1的左右节点。左节点对应坐标小于切分点，右节点对应坐标大于切分点。</li>
</ul></li>
<li>直到两个子区域没有实例时停止。</li>
</ol>
</blockquote></li>
</ul>
<p><strong>搜索<em>kd</em>树</strong></p>
<ul>
<li><strong>最近邻搜索算法</strong>
<ul>
<li>寻找<strong>当前最近点</strong>，从树根不停寻找下一级节点，最终找到离目标点最近的叶子节点作为<strong>当前最近点</strong></li>
<li>回溯：以目标点和<strong>当前最近点</strong>的距离沿树根进行回溯和迭代</li>
</ul></li>
</ul>
<p><strong>机器学习实战中的代码例子</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> operator</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">createDataSet</span>():</span><br><span class="line">    group = np.array([[<span class="number">1.0</span>, <span class="number">1.1</span>], [<span class="number">1.0</span>, <span class="number">1.0</span>], [<span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">0.1</span>]])</span><br><span class="line">    labels = [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;B&#x27;</span>]</span><br><span class="line">    <span class="keyword">return</span> group, labels</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">classify</span>(<span class="params">inX, dataSet, labels, k</span>):</span><br><span class="line">    dataSetSize = dataSet.shape[<span class="number">0</span>]</span><br><span class="line">    diffMat = np.tile(inX, (dataSetSize, <span class="number">1</span>)) - dataSet</span><br><span class="line">    sqDiffMat = diffMat ** <span class="number">2</span></span><br><span class="line">    sqDistances = sqDiffMat.<span class="built_in">sum</span>(axis=<span class="number">1</span>)</span><br><span class="line">    distances = sqDistances ** <span class="number">0.5</span></span><br><span class="line">    sortedDistIndicies = distances.argsort()</span><br><span class="line">    classCount = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">        voteIlabel = labels[sortedDistIndicies[i]]</span><br><span class="line">        classCount[voteIlabel] = classCount.get(voteIlabel, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">    sortedClassCount = <span class="built_in">sorted</span>(classCount.items(), key=operator.itemgetter(<span class="number">1</span>), reverse=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">return</span> sortedClassCount[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">file2matrix</span>(<span class="params">filename</span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> fr:</span><br><span class="line">        lines = fr.readlines()</span><br><span class="line">        len_lines = <span class="built_in">len</span>(lines)</span><br><span class="line">        res = np.zeros((len_lines, <span class="number">3</span>))</span><br><span class="line">        label_vector = []</span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">            line = line.strip()</span><br><span class="line">            line_list = line.split(<span class="string">&quot;\t&quot;</span>)</span><br><span class="line">            res[index, :] = line_list[<span class="number">0</span>:<span class="number">3</span>]</span><br><span class="line">            label_vector.append(<span class="built_in">int</span>(line_list[-<span class="number">1</span>]))</span><br><span class="line">            index += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res, label_vector</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">autoNorm</span>(<span class="params">dataset</span>):</span><br><span class="line">    minv = dataset.<span class="built_in">min</span>(<span class="number">0</span>)</span><br><span class="line">    maxv = dataset.<span class="built_in">max</span>(<span class="number">0</span>)</span><br><span class="line">    diff = maxv - minv</span><br><span class="line">    normdataset = np.zeros(np.shape(dataset))</span><br><span class="line">    m = dataset.shape[<span class="number">0</span>]</span><br><span class="line">    normdataset = dataset - np.tile(minv, (m, <span class="number">1</span>))</span><br><span class="line">    normdataset = normdataset / np.tile(diff, (m, <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">return</span> normdataset, diff, minv</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">datatest</span>():</span><br><span class="line">    r = <span class="number">0.1</span></span><br><span class="line">    data, label = file2matrix(<span class="string">&#x27;datingTestSet2.txt&#x27;</span>)</span><br><span class="line">    normdata, rang, minv = autoNorm(data)</span><br><span class="line">    m = normdata.shape[<span class="number">0</span>]</span><br><span class="line">    numtest = <span class="built_in">int</span>(m * r)</span><br><span class="line">    error_count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(numtest):</span><br><span class="line">        class_res = classify(normdata[i, :], normdata[numtest:m, :], label[numtest:m], <span class="number">4</span>)</span><br><span class="line">        <span class="built_in">print</span>(class_res, label[i])</span><br><span class="line">        <span class="keyword">if</span> class_res != label[i]:</span><br><span class="line">            error_count += <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(error_count / <span class="built_in">float</span>(numtest))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    group, labels = createDataSet()</span><br><span class="line">    res = classify([<span class="number">0</span>, <span class="number">0</span>], group, labels, <span class="number">3</span>)</span><br><span class="line">    <span class="built_in">print</span>(res)</span><br><span class="line"></span><br><span class="line">    dataset, labels = file2matrix(<span class="string">&quot;datingTestSet2.txt&quot;</span>)</span><br><span class="line">    <span class="comment"># print(dataset, labels)</span></span><br><span class="line">    plt.scatter(dataset[:, <span class="number">0</span>], dataset[:, <span class="number">1</span>], <span class="number">15.0</span> * np.array(labels), <span class="number">15.0</span> * np.array(labels))</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line">    normdata, diff, minv = autoNorm(dataset)</span><br><span class="line">    <span class="comment"># print(normdata, diff, minv)</span></span><br><span class="line">    datatest()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="朴素贝叶斯法">朴素贝叶斯法</h2>
<h3 id="贝叶斯定理">贝叶斯定理</h3>
<p><strong>先验概率</strong>：基于统计的概率，是基于以往历史经验和分析得到的结果，不需要依赖当前发生的条件。</p>
<p><strong>后验概率</strong>：从条件概率而来，由因推果，是基于当下发生了事件之后计算的概率，依赖于当前发生的条件。</p>
<p><strong>条件概率</strong>：记事件A发生的概率为P(A),事件B发生的概率为P(B),则在B事件发生的前提下，A事件发生的概率即为条件概率，记为<span class="math inline">\(P(A|B)=\frac{P(AB)}{P(B)}\)</span>.</p>
<p><strong>贝叶斯公式</strong>：基于条件概率，通过P(B|A)来求P(A|B).</p>
<p><span class="math inline">\(P(B|A)=\frac{P(AB)}{P(A)} \rightarrow
P(AB)=P(B|A)P(A)\)</span>,因此<span class="math inline">\(P(A|B)=\frac{P(AB)}{P(B)}=\frac{P(B|A)P(A)}{P(B)}\)</span></p>
<p><strong>全概率公式</strong>：若事件<span class="math inline">\(A_1,A_2,...,A_n\)</span>构成一个完备事件组且都有正概率，则对任意一个事件B都有公式：</p>
<p><span class="math inline">\(P(B)=\sum\limits_{i=1}\limits^{n}P(B|A_i)P(A_i)\)</span></p>
<p>将全概率公式带入贝叶斯公式：<span class="math inline">\(P(A|B)=\frac{P(B|A)P(A)}{\sum\limits_{i=1}\limits^{n}P(B|A_i)P(A_i)}\)</span></p>
<p><strong>贝叶斯分类</strong></p>
<p>存在K类<span class="math inline">\(c_1,
c_2,...,c_K\)</span>，给定一个新的实例<span class="math inline">\(x=(x^{(1)},
x^{(2)},...,x^{(n)})\)</span>，求x应属于哪一类</p>
<p><span class="math inline">\(P(Y=c_i|X=x)=\frac{P(X=x|Y=c_i)P(Y=c_i)}{\sum\limits_{i=1}\limits^{K}P(X=x|Y=c_i)P(Y=c_i)}\)</span></p>
<p>最终求：<span class="math inline">\(arg\ \ max_{c_i}P(X=x|Y=c_i)\cdot
P(Y=c_i)\)</span></p>
<h3 id="朴素贝叶斯算法原理">朴素贝叶斯算法原理</h3>
<p>假设实例特征之间相互独立</p>
<p><span class="math inline">\(P(X=x_i|Y=c_i)=\prod\limits_{j=1}\limits^{n}P(X^{(j)}=x^{(j)}|Y=c_i)\)</span></p>
<p><span class="math inline">\(\Longrightarrow
P(X=x)=\sum\limits_{i=1}\limits^{K}P(Y=c_i)\prod\limits_{j=1}\limits^{n}P(X^{(j)}=x^{(j)}|Y=c_i)\)</span></p>
<p><span class="math inline">\(\Longrightarrow
P(Y=c_i|X=x)=\frac{P(X=x|Y=c_i)P(Y=c_i)}{\sum\limits_{i=1}\limits^{K}P(Y=c_i)\prod\limits_{j=1}\limits^{n}P(X^{(j)}=x^{(j)}|Y=c_i)}\)</span></p>
<p><span class="math inline">\(\Longrightarrow
P(Y=c_i|X=x)=\frac{P(Y=c_i)\prod\limits_{j=1}\limits^{n}P(X^{(j)}=x^{(j)}|Y=c_i)}{\sum\limits_{i=1}\limits^{K}P(Y=c_i)\prod\limits_{j=1}\limits^{n}P(X^{(j)}=x^{(j)}|Y=c_i)}\)</span></p>
<p>最终，朴素贝叶斯分类器只需要关注分子，即<span class="math inline">\(arg \ \ max_{c_i}
P(Y=c_i)\prod\limits_{j=1}\limits^{n}P(X^{(j)}=x^{(j)}|Y=c_i)\)</span>，即<strong>后验概率最大化</strong>。</p>
<h3 id="拉普拉斯平滑">拉普拉斯平滑</h3>
<p>为了解决零概率的问题，法国数学家拉普拉斯最早提出用加1的方法估计没有出现过的现象的概率，所以加法平滑也叫做拉普拉斯平滑。</p>
<p>先验概率的贝叶斯估计：<span class="math inline">\(P_\lambda(Y=c_k)=\frac{\sum\limits_{i=1}\limits^{N}I(y_i=c_k)+\lambda}{N+K\lambda}\)</span></p>
<p>条件概率的贝叶斯估计: <span class="math inline">\(P_\lambda(X^{(j)}=a_{jI}|Y=c_k)=\frac{\sum\limits_{i=1}\limits^{N}I(x_j^{(j)}=a_{iI},y_i=c_k)+\lambda}{\sum\limits_{i=1}\limits^{N}I(y_i=c_k)+S_j\lambda}\)</span></p>
<p>机器学习实战上的一个简单的实例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">loadDataSet</span>():</span><br><span class="line">    posting_list = [[<span class="string">&#x27;my&#x27;</span>, <span class="string">&#x27;dog&#x27;</span>, <span class="string">&#x27;has&#x27;</span>, <span class="string">&#x27;flea&#x27;</span>, <span class="string">&#x27;problems&#x27;</span>, <span class="string">&#x27;help&#x27;</span>, <span class="string">&#x27;please&#x27;</span>],</span><br><span class="line">                    [<span class="string">&#x27;maybe&#x27;</span>, <span class="string">&#x27;not&#x27;</span>, <span class="string">&#x27;take&#x27;</span>, <span class="string">&#x27;him&#x27;</span>, <span class="string">&#x27;to&#x27;</span>, <span class="string">&#x27;dog&#x27;</span>, <span class="string">&#x27;park&#x27;</span>, <span class="string">&#x27;stupid&#x27;</span>],</span><br><span class="line">                    [<span class="string">&#x27;my&#x27;</span>, <span class="string">&#x27;dalmation&#x27;</span>, <span class="string">&#x27;is&#x27;</span>, <span class="string">&#x27;so&#x27;</span>, <span class="string">&#x27;cute&#x27;</span>, <span class="string">&#x27;I&#x27;</span>, <span class="string">&#x27;love&#x27;</span>, <span class="string">&#x27;him&#x27;</span>],</span><br><span class="line">                    [<span class="string">&#x27;stop&#x27;</span>, <span class="string">&#x27;posting&#x27;</span>, <span class="string">&#x27;stupid&#x27;</span>, <span class="string">&#x27;worthless&#x27;</span>, <span class="string">&#x27;garbage&#x27;</span>],</span><br><span class="line">                    [<span class="string">&#x27;mr&#x27;</span>, <span class="string">&#x27;licks&#x27;</span>, <span class="string">&#x27;ate&#x27;</span>, <span class="string">&#x27;my&#x27;</span>, <span class="string">&#x27;steak&#x27;</span>, <span class="string">&#x27;how&#x27;</span>, <span class="string">&#x27;to&#x27;</span>, <span class="string">&#x27;stop&#x27;</span>, <span class="string">&#x27;him&#x27;</span>],</span><br><span class="line">                    [<span class="string">&#x27;quit&#x27;</span>, <span class="string">&#x27;buying&#x27;</span>, <span class="string">&#x27;worthless&#x27;</span>, <span class="string">&#x27;dog&#x27;</span>, <span class="string">&#x27;food&#x27;</span>, <span class="string">&#x27;stupid&#x27;</span>]]</span><br><span class="line">    class_vec = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> posting_list, class_vec</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">createVocabList</span>(<span class="params">dataset</span>):</span><br><span class="line">    vocab_set = <span class="built_in">set</span>([])</span><br><span class="line">    <span class="keyword">for</span> document <span class="keyword">in</span> dataset:</span><br><span class="line">        vocab_set = vocab_set | <span class="built_in">set</span>(document)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>(vocab_set)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将输入词特征向量转换成数字特征向量</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">setOfWords2Vec</span>(<span class="params">vocab_list, input_set</span>):</span><br><span class="line">    return_vec = [<span class="number">0</span>] * <span class="built_in">len</span>(vocab_list)</span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> input_set:</span><br><span class="line">        <span class="keyword">if</span> word <span class="keyword">in</span> vocab_list:</span><br><span class="line">            return_vec[vocab_list.index(word)] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;the word: &#123;&#125; is not in my vocabulary&quot;</span>.<span class="built_in">format</span>(word))</span><br><span class="line">    <span class="keyword">return</span> return_vec</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">trainNB0</span>(<span class="params">train_matrix, train_category</span>):</span><br><span class="line">    len_train_doc = <span class="built_in">len</span>(train_matrix)</span><br><span class="line">    num_words = <span class="built_in">len</span>(train_matrix[<span class="number">0</span>])</span><br><span class="line">    p_busive = <span class="built_in">sum</span>(train_category) / <span class="built_in">float</span>(len_train_doc)</span><br><span class="line">    p0_num, p1_num = np.ones(num_words), np.ones(num_words)</span><br><span class="line">    p0_den, p1_den = <span class="number">2.0</span>, <span class="number">2.0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(len_train_doc):</span><br><span class="line">        <span class="keyword">if</span> train_category[i] == <span class="number">1</span>:</span><br><span class="line">            p1_num += train_matrix[i]</span><br><span class="line">            p1_den += <span class="built_in">sum</span>(train_matrix[i])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            p0_num += train_matrix[i]</span><br><span class="line">            p0_den += <span class="built_in">sum</span>(train_matrix[i])</span><br><span class="line">    p1_vect = np.log(p1_num / p1_den)</span><br><span class="line">    p0_vect = np.log(p0_num / p0_den)</span><br><span class="line">    <span class="keyword">return</span> p0_vect, p1_vect, p_busive</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calssifyNB</span>(<span class="params">vec2calssify, p0_vec, p1_vec, p_class1</span>):</span><br><span class="line">    p1 = <span class="built_in">sum</span>(vec2calssify * p1_vec) + np.log(p_class1)</span><br><span class="line">    p0 = <span class="built_in">sum</span>(vec2calssify * p0_vec) + np.log(<span class="number">1.0</span> - p_class1)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> <span class="keyword">if</span> p1 &gt; p0 <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    posts, label = loadDataSet()</span><br><span class="line">    my_vocab_list = createVocabList(posts)</span><br><span class="line">    <span class="comment"># print(my_vocab_list)</span></span><br><span class="line">    <span class="comment"># print(setOfWords2Vec(my_vocab_list, posts[0]))</span></span><br><span class="line">    train = []</span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> posts:</span><br><span class="line">        train.append(setOfWords2Vec(my_vocab_list, p))</span><br><span class="line">    p0, p1, pab = trainNB0(train, label)</span><br><span class="line">    test_words = [<span class="string">&#x27;love&#x27;</span>, <span class="string">&#x27;my&#x27;</span>, <span class="string">&#x27;dalmation&#x27;</span>]</span><br><span class="line">    test_doc = np.array(setOfWords2Vec(my_vocab_list, test_words))</span><br><span class="line">    <span class="comment"># print(test_doc)</span></span><br><span class="line">    <span class="built_in">print</span>(calssifyNB(test_doc, p0, p1, pab))</span><br><span class="line">    test_words = [<span class="string">&#x27;stupid&#x27;</span>, <span class="string">&#x27;garbage&#x27;</span>]</span><br><span class="line">    test_doc = np.array(setOfWords2Vec(my_vocab_list, test_words))</span><br><span class="line">    <span class="built_in">print</span>(calssifyNB(test_doc, p0, p1, pab))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="决策树">决策树</h2>
<p>决策树模型是一种描述对实例进行分类的树形结构，是通过一系列规则对数据进行分类的过程。</p>
<p><img src="/2024/04/19/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/image-20240425225834808.png" alt="image-20240425225834808" style="zoom:67%;"></p>
<p>构建过程</p>
<blockquote>
<ol type="1">
<li>构建根结点；</li>
<li>选择最优特征，以此分类训练数据集；</li>
<li>若子集被基本分类正确，构建叶结点，否则，继续选择新的最优特征；</li>
<li>重复上述两步，直到所有训练数据子集被正确分类。</li>
</ol>
</blockquote>
<h3 id="条件概率分布与决策树">条件概率分布与决策树</h3>
<p>决策树就是在给定特征条件下类的条件概率分布<span class="math inline">\(P(Y|X)\)</span>，条件概率分布对应了特征空间的一个划分。</p>
<p>当某单元c的条件概率满足<span class="math inline">\(P(Y=+1|X=c)&gt;0.5\)</span>时，则认为该单元属于正类。</p>
<p>决策树的一条路径对应划分中的一个单元。</p>
<h3 id="决策树学习">决策树学习</h3>
<p>已知训练集<span class="math inline">\(T=\{(x_1, y_1), (x_2,
y_2),...,(x_N, y_N)\}\)</span>,其中<span class="math inline">\(x_i=(x_i^{(1)}, x_i^{(2)},...,x_i^{(n)}),
y_i\in\{1, 2,...,K\},i=1,2,...,N\)</span></p>
<p>目的是构造决策树，并对实例正确分类。</p>
<p><strong>决策树的本质</strong>：从训练数据集中归纳出一组分类规则，与训练数据集不相矛盾</p>
<p>假设空间：由无穷多个条件概率模型组成，就是可能训练出无穷多个决策树模型。一棵较好的决策树与训练数据矛盾较小，同时具有很好的泛化能力。</p>
<p><strong>策略</strong>：最小化损失函数</p>
<p><strong>特征选择</strong>：递归选择最优特征</p>
<p>生成：对应特征空间的划分，直到所有训练子集被基本正确分类。</p>
<p>剪枝：避免过拟合，具有更好的泛化能力。</p>
<h3 id="信息增益">信息增益</h3>
<p>信息增益有熵构建而成，熵表示随机变量的不确定性。信息熵表示为</p>
<p><span class="math inline">\(H(X)=-\sum\limits_{i=1}\limits^{n}p_i
logo_i\)</span>或者<span class="math inline">\(H(p)=-\sum\limits_{i=1}\limits^{n}p_ilogp_i\)</span></p>
<p>随机变量的取值等概率分布的时候，相应的熵最大。<span class="math inline">\(0\le H(p) \le log\ n\)</span></p>
<p><strong>条件熵</strong></p>
<p><span class="math inline">\(H(Y|X)=-\sum\limits_{i=1}\limits^{n}p_iH(Y|X=x_i)\)</span></p>
<p>当熵和条件熵中的概率有数据估计得到时，则为经验熵和经验条件熵。</p>
<p>信息增益即为得知特征X而使类Y的信息的不确定性减少的程度。<span class="math inline">\(g(D,A)=H(D)-H(D|A)\)</span></p>
<p><strong>求解特征增益算法</strong></p>
<p>输入：训练集D和特征A</p>
<p>输出：特征A对D的信息增益<span class="math inline">\(g(D,A)\)</span></p>
<ol type="1">
<li>计算经验熵<span class="math inline">\(H(D)=-\sum\limits_{k=1}\limits^{K}\frac{|C_k|}{|D|}log_2\frac{|C_k|}{|D|}\)</span></li>
<li>计算经验条件熵<span class="math inline">\(H(D|A)=\sum\limits_{i=1}\limits^{n}\frac{|D_i|}{|D|}H(D_i)=-\sum\limits_{i=1}\limits^{n}\frac{|D_i|}{|D|}\sum\limits_{k=1}\limits^{K}\frac{|D_{ik}|}{|D_i|}log_2\frac{|D_{ik}|}{|D_i|}\)</span></li>
<li>计算信息增益<span class="math inline">\(g(D,A)=H(D)-H(D|A)\)</span></li>
</ol>
<p>求解信息增益的目的是为了得到<strong>最优特征</strong>。</p>
<p><strong>信息增益比</strong></p>
<p>信息增益比=惩罚参数*信息增益。</p>
<p><span class="math inline">\(g_R(D,A)=\frac{g(D,A)}{H_A(D)}\)</span></p>
<p><span class="math inline">\(H_A(D)\)</span>是对于样本集合D，将当前特征A作为随机变量（取值是特征A的各个特征值），求得的经验熵。</p>
<p><span class="math inline">\(H_A(D)=-\sum\limits_{i=1}\limits^{n}\frac{|D_i|}{|D|}log_2\frac{|D_i|}{|D|}\)</span></p>
<p><strong>信息增益比本质</strong>：
是在信息增益的基础之上乘上一个惩罚参数。特征个数较多时，惩罚参数较小；特征个数较少时，惩罚参数较大。
<strong>惩罚参数</strong>：数据集D以特征A作为随机变量的熵的倒数，即：将特征A取值相同的样本划分到同一个子集中（之前所说数据集的熵是依据类别进行划分的）</p>
<h3 id="决策树的生成">决策树的生成</h3>
<h4 id="id3算法">ID3算法</h4>
<p>输入：训练集D、特征集A、阈值<span class="math inline">\(\epsilon\)</span></p>
<p>输出：决策树T</p>
<ol type="1">
<li><p>判断T是否需要选择特征生成决策树</p>
<p>若D中所有实例属于同一类，则T为单结点树，记录实例类别<span class="math inline">\(C_K\)</span>，以此作为该结点的类标记，并返回T</p>
<p>若D中所有实例无任何特征，则T为单结点树，记录D中实例个数最多类别<span class="math inline">\(C_K\)</span>,以此作为该结点的类标记，并返回T；</p></li>
<li><p>否则，计算A中各特征的<strong>信息增益</strong>，并选择<strong>信息增益最大</strong>的特征<span class="math inline">\(A_g\)</span>；</p>
<p>若<span class="math inline">\(A_g\)</span>的信息增益小于<span class="math inline">\(\epsilon\)</span>，则T为单结点树，记录D中实例<strong>个数最多</strong>类别<span class="math inline">\(C_K\)</span>，以此作为该结点的类标记，并返回T；</p>
<p>否则，按照<span class="math inline">\(A_g\)</span>的每个可能值<span class="math inline">\(a_i\)</span>，将D分为若干非空子集<span class="math inline">\(D_i\)</span>，将<span class="math inline">\(D_i\)</span>中实例个数最多的类别作为标记，构建子结点，以结点和其子结点构成T，并返回T；</p></li>
<li><p>第i个字结点，以<span class="math inline">\(D_i\)</span>为训练集，<span class="math inline">\(A-A_g\)</span>为特征集合，递归调用上述步骤，得到子树<span class="math inline">\(T_i\)</span>并返回。</p></li>
</ol>
<h4 id="c4.5算法">C4.5算法</h4>
<p>此算法和ID3算法不同的地方就是信息增益换成了信息增益比。</p>
<h3 id="剪枝">剪枝</h3>
<p>优秀的决策树：在具有好的拟合和泛化能力的同时，深度小；叶节点少；深度小并且叶节点少。</p>
<p>剪枝是为了处理决策树的过拟合问题。</p>
<h4 id="预剪枝">预剪枝</h4>
<p>生成过程中，对每个结点划分前进行估计，若当前节点的划分不能提升泛化能力，则停止划分，记当前结点为叶节点。</p>
<p>预剪枝的方法：</p>
<ul>
<li>限定决策树的深度</li>
<li>设定一个阈值</li>
<li>设定某个指标，比较结点划分前后的泛化能力</li>
</ul>
<h4 id="后剪枝">后剪枝</h4>
<p>生成一棵完整的决策树之后，自底而上地对内部结点考察，若此内部结点变为叶节点，可提升泛化能力，则做此替换。</p>
<ul>
<li><p>降低错误剪枝</p>
<p>原理：自下而上进行，
使用测试集来剪枝。对每个结点，计算剪枝前和剪枝后的<strong>误判个数</strong>，若是剪枝有利于减少误判，则减掉该结点所在分支。</p></li>
<li><p>悲观错误剪枝(PEP)</p>
<p>根据剪枝前后的错误率来决定是否剪枝，和降低错误剪枝不同之处在于，PEP只需要训练集即可，不需要验证集，并且PEP是自上而下剪枝的。</p>
<p>具体步骤：</p>
<ol type="1">
<li>计算剪枝前目标子树每个叶子结点的误差，并进行连续修正：<span class="math inline">\(Error(Leaf_i)=\frac{error(Leaf_i)+0.5}{N(T)}\)</span></li>
<li>计算剪枝前目标子树的修正误差：<span class="math inline">\(Error(T)=\sum\limits_{i=1}\limits^{L}Error(Leaf_i)=\frac{\sum\limits_{i=1}\limits^{L}error(Leaf_i)+0.5*L}{N(T)}\)</span></li>
<li>计算剪枝前目标子树误判个数的期望值：<span class="math inline">\(E(T)=N(T)×Error(T)=\sum\limits_{i=1}\limits^{L}error(Leaf_i)
+ 0.5*L\)</span></li>
<li>计算剪枝前目标子树误判个数的标准差：<span class="math inline">\(std(T)=\sqrt{N(T)×Error(T)×(1-Error(T))}\)</span></li>
<li>计算剪枝前误判上限(即悲观误差: <span class="math inline">\(E(T)+std(T)\)</span></li>
<li>计算剪枝后该节点的修正误差: <span class="math inline">\(Error(Leaf)=\frac{error(Leaf)+0.5}{N(T)}\)</span></li>
<li>计算剪枝后该结点误判个数的期望值：<span class="math inline">\(E(Leaf)=error(Leaf)+0.5\)</span></li>
<li>比较剪枝前后的误判个数，如果满足不等式<span class="math inline">\(E(Leaf) &lt; E(T) +
std(T)\)</span>，则剪枝，否则，不剪枝。</li>
</ol>
<p>悲观错误剪枝不需要分离剪枝数据集，有利于实例较少的问题；误差使用了连续修正值，使得适用性更强。由于采用了自上而下的剪枝策略，效率更高，但可能会剪掉不应该剪枝的。</p></li>
<li><p>最小误差剪枝(MEP)</p>
<p>原理：根据剪枝前后的<strong>最小分类错误概率</strong>来决定是否剪枝。自下而上剪枝，只需要训练集即可。</p>
<p><strong>最小分类错误概率计算</strong></p>
<p>在结点T处，属于类别k的概率为：<span class="math inline">\(P_k(T)=\frac{n_k(T)+Pr_k(T)×m}{N(T)+m}\)</span>，<span class="math inline">\(Pr_k(T)\)</span>为先验概率，m表示先验概率对于后验概率的影响。</p>
<p>在结点T处，预测错误概率为：<span class="math inline">\(Error(T)=min\{1-P_k(T)\}=min\{\frac{N(T)-n_k(T)+m(1-Pr_k(T))}{N(T)+m}\}\)</span></p>
<p>假设<span class="math inline">\(Pr_k(T)=\frac{1}{K},
m=K\)</span>，则算法步骤为：</p>
<ol type="1">
<li>计算剪枝前目标子树每个叶子结点的预测错误率：<span class="math inline">\(Error(Leaf_i)=\frac{N(Leaf_i)-n_k(Leaf_i)+K-1}{N(Leaf_i)+K}\)</span></li>
<li>计算剪枝前目标子树的预测错误率(加权求和)：<span class="math inline">\(Error(Leaf)=\sum\limits_{i=1}\limits^{L}w_iError(Leaf_i)=\sum\limits_{i=1}\limits^{L}\frac{N(Leaf_i)}{N(T)}Errot(Leaf_i)\)</span></li>
<li>计算剪枝后目标子树的预测错误率：<span class="math inline">\(Error(T)=\frac{N(T)-n_k(T)+K-1}{N(T)+K}\)</span></li>
<li>比较剪枝前后的预测错误率，如果满足<span class="math inline">\(Error(T) &lt;
Error(Leaf)\)</span>，则剪枝；否则，不剪枝。</li>
</ol></li>
<li><p>基于错误剪枝(EBP)</p>
<p>原理：根据剪枝前后的<strong>误判个数</strong>来决定是否剪枝。自下而上剪枝，只需要训练集即可。</p>
<p><strong>误判个数的计算</strong></p>
<p>在置信水平<span class="math inline">\(\alpha\)</span>下每个节点的误判率上界为：</p>
<p><img src="/2024/04/19/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/image-20240427213818511.png" alt="image-20240427213818511" style="zoom: 80%;"></p>
<p><span class="math inline">\(q_{\alpha}\)</span>代表了上分位数，即<span class="math inline">\(P(X\ge q_{\alpha})=\alpha\)</span></p>
<p>算法步骤：</p>
<ol type="1">
<li><p>计算剪枝前目标子树每个叶子结点的误判率上界：</p>
<p><img src="/2024/04/19/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/image-20240427215254778.png" alt="image-20240427215254778" style="zoom:67%;"></p></li>
<li><p>计算剪枝前目标子树的误判个数上界：</p>
<p><span class="math inline">\(E(Leaf)=\sum\limits_{i=1}\limits^{L}N(Leaf_i)U_{CF}(e(Leaf_i),
N(Leaf_i))\)</span></p></li>
<li><p>计算剪枝后目标子树的误判率上界：</p>
<p><img src="/2024/04/19/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/image-20240427215519484.png" alt="image-20240427215519484" style="zoom:67%;"></p></li>
<li><p>计算剪枝后目标子树的误判个数上界：</p>
<p><span class="math inline">\(E(T)=N(T)U_{CF}(e(T),
N(T))\)</span></p></li>
<li><p>比较剪枝前后的误判个数上界，如果满足不等式<span class="math inline">\(E(T) &lt;
E(Leaf)\)</span>则剪枝，否则不剪枝。</p></li>
</ol></li>
<li><p>代价复杂度剪枝(CCP)</p>
<p>根据剪枝前后的损失函数来决定是否剪枝。</p>
<p>损失函数:</p>
<p>​ <span class="math inline">\(C_\alpha = C(T)+\alpha |T|\)</span></p>
<p>其中，<span class="math inline">\(C(T)=\sum\limits_{t=1}\limits^{|T|}N_tH_t(T)=-\sum\limits_{t=1}\limits^{|T|}\sum\limits_{k=1}\limits^{K}N_{tk}log\frac{N_{tk}}{N_t}\)</span>,对应代价cost，表示T在训练集中的预测误差，体现了模型T的拟合程度。<span class="math inline">\(|T|\)</span>表示树包含的叶子结点的个数，体现了模型的复杂度。<span class="math inline">\(\alpha\)</span>是一个惩罚参数。</p></li>
</ul>
<h4 id="cart算法">CART算法</h4>
<h4 id="基尼指数">基尼指数</h4>
<p>基尼指数是特征选择的标准。</p>
<p>假设现有K个类，样本点属于第k个类的概率为<span class="math inline">\(p_k\)</span>，则概率分布的基尼指数为：<span class="math inline">\(Gini(p)=\sum\limits_{k=1}\limits^{K}p_k(1-p_k)=1-\sum\limits_{k=1}\limits^{K}p_k^2\)</span></p>
<p>二分类的基尼指数为:<span class="math inline">\(Gini(p)=2p(1-p)\)</span></p>
<p>样本集D的基尼指数为：<span class="math inline">\(Gini(D)=1-\sum\limits_{k=1}\limits^{K}(\frac{|C_k|}{|D|})^2\)</span></p>
<p>基尼指数越大代表有越大的不确定性。</p>
<p><strong>特征下的基尼指数</strong></p>
<p>在特征A条件下，样本集D的基尼指数为：<span class="math inline">\(Gini(D,A)=\frac{|D_1|}{|D|}Gini(D_1)+\frac{|D_2|}{|D|}Gini(D_2)\)</span></p>
<p><span class="math inline">\(D_1,
D_2\)</span>是在特征A条件下分成的两个小集合。</p>
<h4 id="cart分类树算法">CART分类树算法</h4>
<p>输入：训练数据集D，特征集A，阈值<span class="math inline">\(\epsilon\)</span>（停止条件）</p>
<p>输出：CART决策树T</p>
<ol type="1">
<li>从根节点出发，进行操作，构建二叉树</li>
<li>结点处的训练数据集为D，计算现有特征对该数据集的基尼指数，并选择最优特征。
<ul>
<li>在特征<span class="math inline">\(A_g\)</span>下，对其可能取的每个值<span class="math inline">\(a_g\)</span>，根据样本点对<span class="math inline">\(A_g=a_g\)</span>的测试为“是”或者"否"，将D分割成<span class="math inline">\(D_1\)</span>和<span class="math inline">\(D_2\)</span>两部分，计算<span class="math inline">\(A_g=a_g\)</span>时的基尼指数。</li>
<li>选择基尼指数最小的那个值作为该特征下的最优切分点。</li>
<li>计算每个特征下的最优切分点，并比较在最优切分下的每个特征的基尼指数，选择基尼指数最小的那个特征，即最优特征。</li>
</ul></li>
<li>根据最优特征与最优切分点，从现结点生成两个子结点，将训练数据集依特征分配到两个子结点中去。</li>
<li>分别对两个子结点递归调用上述步骤，直至满足停止条件(比如结点中的样本个数小于预定阈值，或样本集的基尼指数小于预定阈值（样本基本属于同一类），或者没有更多特征)，即生成CART决策树。</li>
</ol>
<h4 id="cart回归树算法">CART回归树算法</h4>
<p>假设将输入空间划分为M个单元<span class="math inline">\(R_1,R_2,...,R_M\)</span>,并在每个单元<span class="math inline">\(R_m\)</span>上有一个固定的输出值<span class="math inline">\(c_m\)</span>。回归树模型可表示为：<span class="math inline">\(f(x)=\sum\limits_{m=1}\limits^{M}c_mI(x\in
R_m)\)</span></p>
<p>平方误差为：<span class="math inline">\(\sum\limits_{x_i\in
R_m}(y_i-f(x_i))^2\)</span>，寻找划分点</p>
<p>最优输出：<span class="math inline">\(\hat{c_m}=average(y_i|x_i\in
R_m)\)</span></p>
<p><strong>寻找划分点算法</strong></p>
<p>选择第<span class="math inline">\(x^{(j)}\)</span>个变量和取值s，分别作为切分变量和切分点，并定义两个区域：</p>
<p><span class="math inline">\(R_1(j,s)=\{x|x^{(j)}\le s\},
R_2(j,s)=\{x|x^{(j)}&gt;s\}\)</span></p>
<p>寻找最优切分变量j和最优切分点s的条件为：</p>
<p><span class="math inline">\(\underset {j,s}{min}[\underset
{c_1}{min}\sum\limits_{x_i\in R_1(j,s)}(y_i-c_1)^2+\underset
{c_2}{min}\sum\limits_{x_i \in R_2(j, s)}(y_i-c_2)^2]\)</span></p>
<p>对于固定输入变量j可以找到最优切分点s：</p>
<p><span class="math inline">\(\hat{c}_1=ave(y_i|x_i\in
R_1(j,s))\)</span>和<span class="math inline">\(\hat{c}_2=ave(y_i|x_i\in
R_2(j, s))\)</span></p>
<p><strong>回归树算法步骤</strong></p>
<p>输入：训练数据集D,停止条件</p>
<p>输出：CART决策树</p>
<ol type="1">
<li><p>从根节点出发，进行操作，构建二叉树</p></li>
<li><p>结点处的训练数据集为D，计算变量的最优切分点，并选择最优变量</p>
<p><span class="math inline">\(\underset {j,s}{min}[\underset
{c_1}{min}\sum\limits_{x_i\in R_1(j,s)}(y_i-c_1)^2+\underset
{c_2}{min}\sum\limits_{x_i \in R_2(j, s)}(y_i-c_2)^2]\)</span></p>
<ul>
<li>在第j变量下，对其可能取的每个值s，根据样本点分割成<span class="math inline">\(R_1\)</span>和<span class="math inline">\(R_2\)</span>两部分，计算切分点为s时的平方误差。</li>
<li>选择平方误差最小的那个值作为该变量下的最优切分点。</li>
<li>计算每个变量下的最优切分点，并比较在最优切分点下的每个变量的平方误差，选择平方误差最小的那个变量，即最优变量。</li>
</ul></li>
<li><p>根据最优特征与最优切分点(j,
s)，从现有结点生成两个子结点，将训练集依变量配到两个子结点中去，得到相应的输出值。</p>
<p><span class="math inline">\(R_1(j, s)=\{x|x^{(j)}\le s\}, \ \ R_2(j,
s)=\{x|x^{(j)}&gt;s\}\)</span></p>
<p><span class="math inline">\(\hat{c}_m=\frac{1}{N_m}\sum\limits_{x_i\in
R_m(j,s)}y_i, \ \ x\in R_m, m=1,2\)</span></p></li>
<li><p>继续对两个子区域调用上述步骤，直至满足停止条件，即生成CART决策树。</p>
<p><span class="math inline">\(f(x)=\sum\limits_{m=1}\limits^{M}\hat{c}_mI(x\in
R_m)\)</span></p></li>
</ol>
<h4 id="cart树剪枝">CART树剪枝</h4>
<p>CART树剪枝采用代价复杂度函数进行剪枝。</p>
<p>损失函数：<span class="math inline">\(C_\alpha = C(T)+\alpha
|T|\)</span></p>
<p>取值：<span class="math inline">\(\alpha=\frac{C(t)-C(T_t)}{|T_t|-1}\)</span>,
剪枝的临界值</p>
<p><img src="/2024/04/19/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/image-20240428232744900.png" alt="image-20240428232744900" style="zoom: 80%;"></p>
<h2 id="逻辑回归">逻辑回归</h2>
<h3 id="逻辑分布">逻辑分布</h3>
<p>设X是连续型随机变量，X服从逻辑分布是指X具有以下分布函数和分布密度：</p>
<p><span class="math inline">\(F(x)=P(X\le
x)=\frac{1}{1+e^{-\frac{(x-\mu)}{\gamma}}}\)</span></p>
<p><span class="math inline">\(f(x)=F&#39;(x)=\frac{e^{\frac{-(x-\mu)}{\gamma}}}{\gamma(1+e^{\frac{-(x-\mu)}{\gamma}})^2}\)</span></p>
<p>式中<span class="math inline">\(\mu\)</span>是未知参数，<span class="math inline">\(\gamma\)</span>是形状参数。</p>
<p>分布函数曲线也称为sigmoid曲线，关于点<span class="math inline">\((\mu, \frac{1}{2})\)</span>中心对称。</p>
<h3 id="回归模型">回归模型</h3>
<p>设<span class="math inline">\(x\in R^n\)</span>是输入，<span class="math inline">\(Y\in \{0, 1\}\)</span>是输出，<span class="math inline">\(\omega\in R^n\)</span>和<span class="math inline">\(b \in R\)</span>是参数，<span class="math inline">\(\omega\)</span>称为权值参数，<span class="math inline">\(b\)</span>称为偏置。二项逻辑回归模型为以下的条件概率：</p>
<p><span class="math inline">\(P(Y=1|x)=\frac{e^{\omega \cdot x + b}}{1
+ e^{\omega \cdot x + b}}\)</span></p>
<p><span class="math inline">\(P(Y=0|x)=\frac{1}{1+e^{\omega \cdot x +
b}}\)</span></p>
<h3 id="逻辑回归模型">逻辑回归模型</h3>
<p>逻辑回归模型定义即为上述条件概率下的模型，实际还是一个二分类问题，输入实例x，计算两类别的概率，将实例x分到概率大的那一类去。</p>
<p>为了方便，将权重和输入向量加以扩充，扔记为<span class="math inline">\(\omega ,x\)</span>，则有: <span class="math inline">\(\omega=(\omega^{(1)},\omega^{(2)},...,\omega^{(n)},
b), \ \  x = (x^{(1)}, x^{(2)}, ..., x^{(n)}, 1)\)</span></p>
<p>逻辑分布函数重写为：</p>
<p><span class="math inline">\(P(Y=1|x)=\frac{e^{\omega \cdot x}}{1 +
e^{\omega \cdot x}}\)</span></p>
<p><span class="math inline">\(P(Y=0|x)=\frac{1}{1+e^{\omega \cdot
x}}\)</span></p>
<p><strong>参数估计方法</strong></p>
<p>参数估计方法采用极大似然估计</p>
<p>对于输入数据集<span class="math inline">\(T=\{(x_1, y_1), (x_2, y_2),
..., (x_n, y_n)\}\)</span>,条件概率为：<span class="math inline">\(P(Y=y_i|x_i)=(1-p_i)^{1-y_i}p_i^{y_i}\)</span>,其中，<span class="math inline">\(p_i=\frac{e^{\omega\cdot x_i}}{1+e^{w\cdot
x_i}}\)</span></p>
<p>似然函数为：<span class="math inline">\(L(\omega)=\prod\limits_{i=1}\limits^{N}(1-p_i)^{1-y_i}p_i^{y_i}\)</span></p>
<p>求对数：</p>
<p><span class="math display">\[ \begin{equation}
\begin{aligned}ln(L)&amp;=\sum\limits_{i=1}\limits^{N}y_iln(p_i)+(1-y_i)ln(1-p_i)
\\ &amp;= \sum\limits_{i=1}\limits^{N} [y_iln\frac{p_i}{1-p_i}+
ln(1-p_i)] \\ &amp;=\sum\limits_{i=1}\limits^{N}[y_i(\omega \cdot x_i) -
ln(1+e^{\omega \cdot x_i})] \end{aligned} \end{equation} \]</span></p>
<p>已知<span class="math inline">\((x_i, y_i)\)</span>，求未知的<span class="math inline">\(\omega\)</span>使得似然函数最大。可采用牛顿法、梯度下降法等迭代方法求解。</p>
<h2 id="最大熵模型">最大熵模型</h2>
<h3 id="模型简介">模型简介</h3>
<p>最大熵模型为：</p>
<p>假设满足所有约束条件的模型集合为</p>
<p><span class="math inline">\(\mathcal{C}=\{P\in
\mathcal{P}|E_P(f_i)=E_{\tilde{P}}(f_i), \
i=1,2,...,n\}\)</span>，包含n个约束项</p>
<p>定义在条件概率分布<span class="math inline">\(P(Y|X)\)</span>上的条件熵为</p>
<p><span class="math inline">\(H(P)=-\sum\limits_{x,y}\tilde{P}(x)P(y|x)logP(y|x)\)</span></p>
<p>则模型集合<span class="math inline">\(\mathcal{C}\)</span>中条件熵<span class="math inline">\(H(P)\)</span>最大的模型称为最大熵模型</p>
<p><strong>特征函数</strong></p>
<p>特征函数<span class="math inline">\(f(x,y)\)</span>描述输入x和输出y之间的某一个事实：</p>
<p><span class="math display">\[f(x,y) = \begin{cases}1,\ \
\  x,y满足某一事实 \\0, \ \ \ 否则 \end{cases}\]</span></p>
<p>特征函数<span class="math inline">\(f(x,y)\)</span>关于经验分布<span class="math inline">\(\tilde{P}(X,Y)\)</span>的期望值用<span class="math inline">\(E_{\tilde{P}}(f)\)</span>表示：<span class="math inline">\(E_{\tilde{P}}(f)=\sum\limits_{x,y}\tilde{P}(x,y)f(x,y)\)</span></p>
<p>特征函数<span class="math inline">\(f(x,y)\)</span>关于模型<span class="math inline">\(P(Y|X)\)</span>与经验分布<span class="math inline">\(\tilde{P}(X)\)</span>的期望值为：<span class="math inline">\(E_P(f)=\sum\limits_{x,y}\tilde{P}(x)P(y|x)f(x,y)\)</span></p>
<p>对于给定训练数据集，可以确定联合分布<span class="math inline">\(P(X,Y)\)</span>的经验分布和边缘分布<span class="math inline">\(P(X)\)</span>的经验分布，分别以<span class="math inline">\(\tilde{P}(X,Y),\tilde{P}(X)\)</span>表示，其中(v表示样本出现的频数，N为样本容量)：</p>
<p><span class="math inline">\(\tilde{P}(X=x,Y=y)=\frac{v(X=x,Y=y)}{N}\\
\tilde{P}(X=x)=\frac{v(X=x)}{N}\)</span></p>
<h3 id="最大熵模型学习">最大熵模型学习</h3>
<p>对于给定的训练数据集<span class="math inline">\(T=\{(x_1,
y_1),(x_2,y_2), ..., (x_N,y_N)\}\)</span>以及特征函数<span class="math inline">\(f_i(x,y),
i=1,2,...,n\)</span>，最大熵模型的学习等价于约束最优化问题：</p>
<p><span class="math display">\[\begin{align}\underset{\mathcal{P}\in
\mathcal{C}}{max} H(P)=-\sum\limits_{x,y} \tilde{P}(x) P(y|x)logP(y|x)
\\ s.t. \ \ \ \ \ \ \ \  E_P(f_i)=E_{\tilde{P}}(f_i), i=1,2,...,n \\
\sum\limits_{y}P(y|x)=1 \ \ \ \ \ \ \ \ \ \ \  \ \ \ \
\end{align}\]</span></p>
<p>该问题等价于：</p>
<p><span class="math display">\[\begin{align}\underset{\mathcal{P}\in
\mathcal{C}}{min} -H(P)=\sum\limits_{x,y} \tilde{P}(x) P(y|x)logP(y|x)
\\ s.t. \ \ \ \ \ \ \ \  E_P(f_i)=E_{\tilde{P}}(f_i), i=1,2,...,n \\
\sum\limits_{y}P(y|x)=1 \ \ \ \ \ \ \ \ \ \ \  \ \ \ \
\end{align}\]</span></p>
<p>采用拉格朗日乘子法，引入拉格朗日乘子<span class="math inline">\(w_0,
w_1, w_2,...,w_n\)</span>，拉格朗日函数为：</p>
<p><span class="math display">\[\begin{align} L(P,w) &amp;= -H(P) +
w_0(1-\sum\limits_{y}P(y|x)) +
\sum\limits_{i=1}\limits^{n}w_i(E_{\tilde{P}}(f_i)-E_P(f_i)) \\ &amp;=
\sum\limits_{x,y} \tilde{P}(x) P(y|x)logP(y|x) +
w_0(1-\sum\limits_{y}P(y|x)) +
\sum\limits_{i=1}\limits^{n}w_i(\sum\limits_{x,y}\tilde{P}(x,y)f_i(x,y)-\sum\limits_{x,y}\tilde{P}(x)P(y|x)f_i(x,y))\end{align}\]</span></p>
<p>最优化的原始问题为：<span class="math inline">\(\underset{P\in\mathcal{C}}{min}\
\  \underset{w}{max}L(P,w)\)</span></p>
<p>对偶问题为：<span class="math inline">\(\underset{w}{max} \
\  \underset{P\in \mathcal{C}}{min}L(P,w)\)</span></p>
<p>原始问题和对偶问题是等价的，因此可转换为求解对偶问题。首先求解对偶问题内部的极小化问题<span class="math inline">\(\underset{P\in \mathcal{C}}{min}
L(P,w)\)</span>，结果是w的函数，记为：<span class="math inline">\(\Psi(w)=\underset{P\in
\mathcal{C}}{min}L(P,w)=L(P_w, w)\)</span></p>
<p>具体求解时，分别对<span class="math inline">\(P(y|x)\)</span>求导，得到关于<span class="math inline">\(w\)</span>的函数，再关于<span class="math inline">\(w\)</span>求导，令导数为0，待会原概率公式，求得概率。</p>
<h3 id="优化算法">优化算法</h3>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>统计学习方法</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>计网模拟题</title>
    <url>/2023/12/01/%E8%AE%A1%E7%BD%91%E6%A8%A1%E6%8B%9F%E9%A2%98/</url>
    <content><![CDATA[<h2 id="年全国硕士研究生入学统一考试模拟题01"><strong>2024
年全国硕士研究生入学统一考试模拟题01</strong></h2>
<h3 id="一单项选择题第140小题每小题2分共80分下列每题给出的四个选项中只有一个选项最符合试题要求">一、<strong>单项选择题：第1</strong>~<strong>40小题，每小题2分，共80分。下列每题给出的四个选项中，只有一个选项最符合试题要求。</strong></h3>
<ul>
<li><ol start="33" type="1">
<li>在OSI/RM中，不属于网络层相邻下层涉及的范畴是（ ）。</li>
</ol>
<p>A．物理地址</p>
<p>B．封装成帧</p>
<p>C．透明传输</p>
<p>D．频分复用</p></li>
<li><ol start="34" type="1">
<li>假设某信道中的信号功率为0.6W，噪声功率为0.0193W，信道的频带宽度为160MHz，信道的长度为1km，信号在该信道的传播速率为200,000km/s，则该信道的时延带宽积是（
）。</li>
</ol>
<p>A．500b</p>
<p>B．512b</p>
<p>C．1024b</p>
<p>D．4000b</p></li>
<li><ol start="35" type="1">
<li>以下有关VLAN的叙述中，<strong>错误</strong>的有（ ）。</li>
</ol>
<p>I. VLAN是一种新型局域网</p>
<ol start="2" type="I">
<li><p>VLAN使用的802.1Q帧的最大长度为1518B</p></li>
<li><p>连接在同一交换机上的多个站点可以属于不同的VLAN</p></li>
<li><p>不同VLAN中的站点之间不能直接通信</p></li>
</ol>
<p>V. 属于同一VLAN的多个站点不能连接在不同的交换机上</p>
<p>A．I、V</p>
<p>B．II、IV</p>
<p>C．I、II、V</p>
<p>D．II、III、IV、V</p></li>
<li><ol start="36" type="1">
<li>若主机A的IP地址是192.168.0.129/25，则主机A所在网络中可分配给其他主机或路由器接口的最小地址是（
）。</li>
</ol>
<p>A．192.168.0.127</p>
<p>B．192.168.0.128</p>
<p>C．192.168.0.129</p>
<p>D．192.168.0.130</p></li>
<li><ol start="37" type="1">
<li>若将某个
“/17”地址块划分为9（不多也不少）个子块，则可能的最小子块中所包含的IP地址数量为（
）。</li>
</ol>
<p>A．126</p>
<p>B．128</p>
<p>C．2046</p>
<p>D．2048</p></li>
<li><ol start="38" type="1">
<li>以下有关SDN的叙述中，错误的是（ ）。</li>
</ol>
<p>A. 数据层面与控制层面是分离的，二者不在同一个设备中</p>
<p>B.
各分组交换机的流表中的流表项，都是由SDN控制器进行计算、管理和安装的</p>
<p>C. SDN控制器与网络控制应用程序的交互都要通过南向API接口</p>
<p>D. OpenFlow协议是目前被广泛采用的SDN控制器通信层的协议</p></li>
<li><ol start="39" type="1">
<li>在TCP建立连接的过程中，TCP服务器收到SYN=1的TCP报文段并给TCP客户发送相应的SYN=1且ACK=1的TCP报文段后，TCP服务器的TCP状态转换为（
）。</li>
</ol>
<p>A．SYN-RCVD</p>
<p>B．TIME-WAIT</p>
<p>C．ESTABLISHED</p>
<p>D．CLOSED</p></li>
<li><ol start="40" type="1">
<li>假设主机H通过HTTP/1.1请求浏览某个Web服务器S上的Web页rfc.html，rfc.html引用了同目录下的3个JPEG小图像，一次请求-响应的时间为RTT，忽略其他各种时延，不考虑拥塞控制和流量控制，则从发送HTTP请求报文开始到收到全部内容为止，所耗费的时间是（
）。</li>
</ol>
<p>A．2RTT</p>
<p>B．2.5RTT</p>
<p>C．4RTT</p>
<p>D．4.5RTT</p></li>
</ul>
<h3 id="二综合应用题第4147-题共70-分">二、<strong>综合应用题：第41~47
题，共70 分。</strong></h3>
<ul>
<li><ol start="47" type="1">
<li>（9分）某网络拓扑如下图所示，现做如下假设：</li>
</ol>
<p>（1）
服务器Server1是本地域名服务器，其记录有Internet中Web服务器的域名和IP地址的对应关系。</p>
<p>（2）
服务器Server2为主机H提供网络参数（IP地址、子网掩码、默认网关的IP地址、本地域名服务器的IP地址）。</p>
<p>（3） S为二层交换机，其各接口的接口号已标注在接口旁边。</p>
<p>（4）
Server1、Server2、路由器R1和R2各自相关接口的IP地址和MAC地址已标注在它们各自的旁边；
H的MAC地址已标注在其旁边。</p>
<p>（5）
一开始H的ARP表和S的交换表均为空，并且后续各表获得的相关记录没有老化时间（即长期保存）。</p>
<p>（6）
H获取到IP地址、子网掩码以及默认网关的IP地址后，利用浏览器通过域名www.abc.com访问Web服务器，并且整个访问过程中没有传输差错，也未发生与Web访问无关的网络通信。</p></li>
</ul>
<p><img src="https://p.sda1.dev/14/ca8243e36a1b972682be5ded7495f088/1.png" alt="1.png" style="zoom: 67%;"></p>
<p>请回答以下问题：</p>
<p>（1）
H使用什么协议从Server2获取到自己的IP地址？该IP地址所在范围是什么？H从Server2获取到的默认网关的IP地址是什么？</p>
<p>（2）
H向Server1请求Web服务器的域名www.abc.com所对应的IP地址时，发送给Server1的第一个以太网帧的数据载荷封装的是什么报文？该以太网帧的目的MAC地址是什么？</p>
<p>（3）
H访问Web服务器的过程中，除HTTP外还用到了哪个应用层协议？该应用层协议的熟知端口号是什么？从应用层到数据链路层，该应用层协议报文分别通过哪些协议进行逐层封装？</p>
<p>（4）
若S的交换表结构为&lt;MAC地址，接口号&gt;，则H获取到自己的IP地址等网络参数时，S的交换表中的内容是什么？当H收到来自Web服务器的响应时，S的交换表中的内容是什么？</p>
<p>（5）
为了使H能够与Web服务器通信，R1需要开启什么功能？H给Web服务器发送的IP数据报，从R1转发出来时，其源IP地址是什么？</p>
<h2 id="年全国硕士研究生入学统一考试模拟题01-答案"><strong>2024
年全国硕士研究生入学统一考试模拟题01 答案</strong></h2>
<ul>
<li><ol start="33" type="1">
<li>D</li>
</ol>
<p>在OSI/RM中，网络层的相邻下层是数据链路层。</p>
<p>选项A中的物理地址、也称为硬件地址、MAC地址，属于数据链路层范畴。</p>
<p>选项B中的封装成帧、选项C中的透明传输都属于数据链路层范畴。另外，差错检测也属于数据链路层范畴。</p>
<p>选项D中的<strong>频分复用，属于物理层范畴。</strong></p></li>
<li><ol start="34" type="1">
<li>D</li>
</ol>
<p>最大传输速率是<span class="math inline">\(160*log_2(1+\frac{0.6}{0.0193})=800Mb/s\)</span>。传播时延为：<span class="math inline">\(\frac{1}{200000}s\)</span>，时延带宽积为<strong>单向传播时延<span class="math inline">\(\times\)</span>带宽</strong>。因此时延带宽积为:<span class="math inline">\(800M * \frac{1}{200000}=4000b\)</span>。</p></li>
<li><ol start="35" type="1">
<li>C</li>
</ol>
<p>I项的叙述错误。VLAN是在以太网交换机上实现的一种分割广播域的技术，而不是一种新型的局域网。</p>
<p>II项的叙述错误。802.1Q帧对以太网V2的MAC帧格式进行了扩展：在源地址字段和类型字段之间插入了4字节的VLAN标签字段，则802.1Q帧的最大长度为1518B+4B=1522B。</p>
<p>III项的叙述正确。在同一个交换机上可以划分不同的VLAN。</p>
<p>IV项的叙述正确。不同VLAN中的站点之间不能直接通信，要实现它们之间的通信，需要使用三层交换机或路由器。</p>
<p>V项的叙述错误。属于同一VLAN的多个站点，可以连接在不同的交换机上。只要将相关的交换机接口划分到同一VLAN即可。</p></li>
<li><ol start="36" type="1">
<li>D</li>
</ol></li>
<li><ol start="37" type="1">
<li>B</li>
</ol>
<p>满足网络号不是前缀就行。一种可能的划分方法是: 0, 10, 110, 1110,
11110, 111110, 1111110, 11111110, 11111111。网络号最长是8位。</p></li>
<li><ol start="38" type="1">
<li>C</li>
</ol>
<p><img src="https://p.sda1.dev/14/ac356a62795b375f0ed50afb18fbd778/38.png" alt="38.png" style="zoom:67%;"></p></li>
<li><ol start="39" type="1">
<li>A</li>
</ol>
<p><img src="https://p.sda1.dev/14/fbaab7001a2e3136b971b2f92fc8a113/18.jpg" style="zoom:80%;"></p></li>
<li><ol start="40" type="1">
<li>A</li>
</ol>
<p><img src="https://p.sda1.dev/14/04fde899361ea840aa8192436fef5fe0/40.png" alt="40.png" style="zoom: 50%;"></p></li>
<li><ol start="47" type="1">
<li></li>
</ol>
<p>(1).
H通过<strong>DHCP协议</strong>从Server2获取到自己的IP地址。该IP地址所在范围是<strong>192.168.16.195-192.168.16.253</strong>。H从Server2获取的默认网关的IP地址是<strong>192.168.16.254</strong>。</p>
<p>(2).
发送给Server1的第一个以太网帧的数据载荷是<strong>ARP请求报文</strong>。该以太网帧的目的MAC地址是<strong>FF-FF-FF-FF-FF-FF</strong>。</p>
<p>(3).
除HTTP外还用的应用层协议是<strong>DNS协议</strong>。对应<strong>熟知端口号是53</strong>。从应用层到数据链路层逐层封装的协议为:DNS协议，UDP协议，IP协议，最后在数据链路层被封装在以太网帧中。</p>
<p><img src="https://p.sda1.dev/14/debc8cc1f2119e41b63e2d97c0f84872/Image_1698924422482.jpg" alt="Image_1698924422482.jpg" style="zoom: 50%;"></p></li>
</ul>
<p>​ (4). H获取到自己的IP地址等网络参数时，S的交换表中的内容是:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">MAC地址</th>
<th style="text-align: center;">接口号</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">00-11-22-33-44-aa</td>
<td style="text-align: center;">4</td>
</tr>
<tr class="even">
<td style="text-align: center;">00-11-22-33-44-ee</td>
<td style="text-align: center;">3</td>
</tr>
</tbody>
</table>
<p>收到来自Web服务器的相应时，S的交换表内容是:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">MAC地址</th>
<th style="text-align: center;">接口号</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">00-11-22-33-44-aa</td>
<td style="text-align: center;">4</td>
</tr>
<tr class="even">
<td style="text-align: center;">00-11-22-33-44-ee</td>
<td style="text-align: center;">3</td>
</tr>
<tr class="odd">
<td style="text-align: center;">00-11-22-33-44-bb</td>
<td style="text-align: center;">1</td>
</tr>
<tr class="even">
<td style="text-align: center;">00-11-22-33-44-dd</td>
<td style="text-align: center;">2</td>
</tr>
</tbody>
</table>
<p>​ (5).
R1需要开启<strong>NAT功能</strong>。源IP地址是<strong>218.75.230.2/30</strong></p>
<hr>
<h2 id="年全国硕士研究生入学统一考试模拟题02"><strong>2024
年全国硕士研究生入学统一考试模拟题02</strong></h2>
<h3 id="一单项选择题第140小题每小题2分共80分下列每题给出的四个选项中只有一个选项最符合试题要求-1">一、<strong>单项选择题：第1</strong>~<strong>40小题，每小题2分，共80分。下列每题给出的四个选项中，只有一个选项最符合试题要求。</strong></h3>
<ul>
<li><ol start="33" type="1">
<li>以下有关计算机网络体系结构的相关叙述中，<strong>错误</strong>的是（
）。</li>
</ol>
<p>I. 对等实体是指通信双方相同网络体系结构中相同层次中的实体</p>
<ol start="2" type="I">
<li><p>协议的三要素为语法、语义、同步（或称时序）</p></li>
<li><p>实体为了使用下层提供的服务，需要知道实现服务的具体协议细节</p></li>
<li><p>对等层次之间传送的数据包称为该层的SDU</p></li>
</ol>
<p>V.
上层要使用相邻下层所提供的服务，需要通过与相邻下层交换一些命令，这些命令称为服务原语</p>
<p>A．I，IV</p>
<p>B．III、IV</p>
<p>C．II、III</p>
<p>D．III、IV、V</p></li>
<li><ol start="34" type="1">
<li>有X、Y和Z共3个站进行CDMA通信，其中X站的码片序列是(-1 -1 -1 +1 +1 -1
+1 +1)，Y站的码片序列是(-1 -1 +1 -1 +1 +1 +1
-1)，则Z站的码片序列可以是（ ）。</li>
</ol>
<p>A. (+1 +1 +1 -1 -1 +1 -1 -1)</p>
<p>B. (+1 +1 -1 +1 -1 -1 -1 +1)</p>
<p>C. (-1 -1 +1 -1 -1 +1 -1 -1)</p>
<p>D. (-1 +1 -1 +1 +1 +1 -1 -1)</p></li>
<li><ol start="35" type="1">
<li>以下有关停止-等待协议与GBN协议的相关叙述中，<strong>正确</strong>的是（
）。</li>
</ol>
<p>I. 停止-等待协议的发送窗口和接收窗口的尺寸都是1</p>
<ol start="2" type="I">
<li><p>GBN协议的发送窗口和接收窗口的尺寸都大于1</p></li>
<li><p>对于RTT远大于分组发送时延的卫星链路，不适合使用停止-等待协议，因为其信道利用率很低</p></li>
<li><p>GBN协议的信道利用率大于停止-等待协议的信道利用率</p></li>
</ol>
<p>A．I，IV</p>
<p>B．I、III</p>
<p>C．II、IV</p>
<p>D．I、III、IV</p></li>
<li><ol start="36" type="1">
<li>在下图所示的802.11无线局域网中，主机A要通过接入点AP给主机B发送一个数据帧，则该数据帧从主机A发出时，其地址字段中的地址1、地址2以及地址3分别为是（
）。</li>
</ol>
<p><img src="https://p.sda1.dev/14/ada875f76f8b8279319019ea8f73b217/2_36.png" alt="2_36.png" style="zoom:67%;"></p>
<p>A. MAC1、MAC2、MAC3</p>
<p>B. MAC3、MAC2、MAC1</p>
<p>C. MAC3、MAC1、MAC2</p>
<p>D. MAC2、MAC1、MAC3</p></li>
<li><ol start="37" type="1">
<li>网络拓扑如下图所示，假设交换机当前已学习到了主机E的MAC地址，主机A给E发送ARP请求报文，主机E收到后给主机A发送ARP响应报文。则能收到ARP请求报文和ARP响应报文的主机数量分别（
）。</li>
</ol>
<p><img src="https://p.sda1.dev/14/e7d59d65b48c2d192508053976d9ee2d/2_37.png" alt="2_37.png" style="zoom:67%;"></p>
<p>A．5，3</p>
<p>B．5，1</p>
<p>C．3，5</p>
<p>D．1，1</p></li>
<li><ol start="38" type="1">
<li>将IP多播地址226.0.9.26和226.128.9.26转换成以太网的硬件多播地址分别是（
）。</li>
</ol>
<p>A. 00-00-5E-00-00-00，00-00-5E-7F-FF-FF</p>
<p>B. 01-00-5E-00-09-26，01-00-5E-10-09-26</p>
<p>C. 01-00-5E-00-09-1A，01-00-5E-00-09-1A</p>
<p>D. 00-00-5E-7F-FF-FF, 00-00-5E-00-00-00</p></li>
<li><ol start="39" type="1">
<li>下列有关SDN的叙述中，<strong>正确</strong>的是（ ）。</li>
</ol>
<p>A. SDN是近年来出现的一种新型物理网络</p>
<p>B. SDN等同于OpenFlow</p>
<p>C. SDN将网络的控制层面和数据层面分开</p>
<p>D. OpenFlow交换机就是IP路由器</p></li>
<li><ol start="40" type="1">
<li>下列有关IPv4和IPv6的叙述中，<strong>错误</strong>的是（ ）。</li>
</ol>
<p>A.
IPv4数据报首部固定部分长度为20字节，而IPv6数据报的基本首部长度为40字节</p>
<p>B. IPv6支持任播</p>
<p>C. IPv6首部取消了首部校验和字段</p>
<p>D. 与IPv6配套使用的网际层协议有ICMPv6和IGMPv6</p></li>
</ul>
<h3 id="二综合应用题第4147-题共70-分-1">二、<strong>综合应用题：第41~47
题，共70 分。</strong></h3>
<ul>
<li><ol start="47" type="1">
<li>（9分）某网络拓扑如下图所示，AS1和AS2分别是两个自治系统，R1~R4都是路由器。本题所需的相关信息（例如网络地址、路由器接口的IP地址，MTU等）已标注在图中。</li>
</ol>
<p><img src="https://p.sda1.dev/14/e048536e18ac77dd8396e387099467dc/2_47.png" alt="2_47.png" style="zoom:67%;"></p>
<p>请回答以下问题：</p>
<p>（1）
若AS2内部各路由器使用RIP协议进行路由选择且已收敛，网络192.1.1.0/25中的主机A给网络192.1.1.128/25中的主机B发送一个IP数据报，其首部中TTL字段的初始值为128，则当主机B正确接收到该IP数据报时，其首部中的TTL字段的值为多少？若TTL字段的初始值被设置为2，则会出现什么情况？</p>
<p>（2）
请给R2添加一条去往AS1内部各网络的聚合路由条目（而非默认路由）,路由条目的格式为（目的网络
子网掩码
下一跳）。这条聚合路由是否会引入图中AS1内部三个网络以外的其他网络？</p>
<p>（3）
AS1与AS2之间可使用的路由选择协议是什么？该路由选择协议使用运输层的哪个协议？</p>
<p>（4）
若R4在给网络192.1.2.192/26转发一个总长度为1580B的IP数据报（首部长度为20B）时进行了分片，且每个分片尽可能大，则最小的分片IP数据报的长度字段和片偏移字段的取值分别是多少？</p>
<p>（5）
若R4的路由表中仅包含有直连网络的路由，当R4收到一个目的地址为192.1.4.16的IP数据报时，会如何处理？</p>
<p>（6）
假设AS1与AS2可以完全互通，AS1中的某台主机通过浏览器访问AS2中的某台Web服务器，采用HTTP/1.1协议的持续的非流水线方式，一次请求-响应时间为RTT，若浏览器所请求的Web页面引用了2个图片，则从浏览器向Web服务器发出的第一个请求报文开始到浏览器收到全部内容为止，需要的RTT数量是多少？</p></li>
</ul>
<p>​</p>
<h2 id="年全国硕士研究生入学统一考试模拟题02-答案"><strong>2024
年全国硕士研究生入学统一考试模拟题02</strong> 答案</h2>
<ul>
<li><ol start="33" type="1">
<li>B</li>
</ol>
<p>实体看得见下层提供的服务，但并不知道实现该服务的具体协议。也就是说，下层的协议对上层的实体是“透明”的。因此，叙述III错误。</p>
<p>对等层次之间传送的数据包称为该层的协议数据单元PDU；同一系统内层与层之间交换的数据包称为服务数据单元SDU。因此，叙述IV错误。</p></li>
<li><ol start="34" type="1">
<li>D</li>
</ol>
<p>CDMA系统给每个站分配的码片序列需要满足以下两个条件：</p>
<p>● 条件1：必须各不相同</p>
<p>● 条件2：必须相互正交，即规格化内积为0</p></li>
<li><ol start="35" type="1">
<li>B</li>
</ol>
<p>使用n个比特给分组编号，GBN协议的发送窗口的尺寸WT的取指范围是：<span class="math inline">\(1&lt;W_T\le 2^n-1\)</span>。</p>
<p><strong>只有在不出现传输差错的情况下，GBN协议的信道利用率大于停止-等待协议的信道利用率</strong>；若出现传输差错，则GBN协议就需要回退N帧进行重传，信道利用率不一定大于停止-等待协议的信道利用率。因此，叙述IV错误。</p></li>
<li><ol start="36" type="1">
<li>D</li>
</ol>
<table>
<colgroup>
<col style="width: 10%">
<col style="width: 10%">
<col style="width: 29%">
<col style="width: 25%">
<col style="width: 13%">
<col style="width: 10%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">去往AP</th>
<th style="text-align: center;">来自AP</th>
<th style="text-align: center;">地址1</th>
<th style="text-align: center;">地址2</th>
<th style="text-align: center;">地址3</th>
<th style="text-align: center;">地址4</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">目的地址</td>
<td style="text-align: center;">源地址</td>
<td style="text-align: center;">BSSID</td>
<td style="text-align: center;">未使用</td>
</tr>
<tr class="even">
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">接收地址=目的地址</td>
<td style="text-align: center;">发送地址=AP地址</td>
<td style="text-align: center;">源地址</td>
<td style="text-align: center;">未使用</td>
</tr>
<tr class="odd">
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">接收地址=AP地址</td>
<td style="text-align: center;">发送地址=源地址</td>
<td style="text-align: center;">目的地址</td>
<td style="text-align: center;">未使用</td>
</tr>
<tr class="even">
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">接收地址=AP地址</td>
<td style="text-align: center;">发送地址=AP地址</td>
<td style="text-align: center;">目的地址</td>
<td style="text-align: center;">源地址</td>
</tr>
</tbody>
</table></li>
<li><ol start="37" type="1">
<li>A</li>
</ol>
<p><img src="https://p.sda1.dev/14/47f1427fcaee0776c5a2ffedc78bc868/2_37_.png" alt="2_37_.png" style="zoom: 67%;"></p></li>
<li><ol start="38" type="1">
<li>C</li>
</ol>
<p><img src="https://p.sda1.dev/14/e49b20ef0de0421bf63c6b1373547bf8/2_38.png" alt="2_38.png" style="zoom: 67%;"></p></li>
<li><ol start="39" type="1">
<li>C</li>
</ol>
<p>SDN是一种新型网络体系结构，是一种设计、构建和管理网络的<strong>新方法和新概念</strong>，但<strong>不是一种新型物理网络</strong>。因此，选项A的叙述错误。</p>
<p>OpenFlow协议可被看成是在SDN体系结构中<strong>控制层面与数据层面之间的通信接口</strong>。因此，选项B的叙述错误。</p>
<p>SDN的核心思想就是<strong>把网络的控制层面和数据层面分离</strong>，而让控制层面利用软件来控制数据层面中的许多设备。因此，选项C的叙述正确。</p>
<p>在SDN的<strong>广义转发</strong>中，<strong>完成“匹配+动作”的设备并不局限在网络层工作</strong>，因此不再称为路由器，而称为“OpenFlow交换机”或“分组交换机”，或更简单地称为“交换机”。相应的，在SDN中取代传统路由器中转发表的是“流表（Flow
Table）”。因此，选项D的叙述错误。</p></li>
<li><ol start="40" type="1">
<li>D</li>
</ol>
<p>与IPv4协议配套使用的网际层协议有：ICMP、IGMP、ARP和RARP。</p>
<p>在IPv6中，ICMPv6包括了IPv4中的ARP和IGMP的功能。邻站询问和邻站通告报文代替了原来的ARP协议，而多播听众发现报文替代了原来的IGMP协议。另外，IPv6取消了RARP协议。因此，与IPv6配套使用的网际层协议只有ICMPv6一个协议，选项D的叙述错误。</p></li>
<li><ol start="47" type="1">
<li></li>
</ol>
<ul>
<li><p>(1).
主机B正确收到IP数据报时，其首部中<strong>TTL字段是126</strong>。若TTL初始值设置为2，IP数据报进入R1时，TTL-1变成1，进入R3时，TTL变成0，<strong>R3会丢弃该IP数据报，并向该IP数据报的源主机A发送ICMP差错报告报文，类型为时间超过</strong>。</p></li>
<li><p>(2). AS1中IP后8位分别为：</p>
<p>​ <strong>0</strong>000 0000</p>
<p>​ <strong>10</strong>00 0000</p>
<p>​ <strong>110</strong>0 0000</p>
<p>路由聚合后为<strong>192.1.2.0/24</strong>。因此R2添加的路由条目为：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">目的网络</th>
<th style="text-align: center;">子网掩码</th>
<th style="text-align: center;">下一跳</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">192.1.2.0/24</td>
<td style="text-align: center;">255.255.255.0</td>
<td style="text-align: center;">192.1.3.30/30</td>
</tr>
</tbody>
</table>
<p>从网络号可以看出，刚好是前缀划分的方法，因此聚合后没有引入其他网络。</p></li>
<li><p>(3).
AS1和AS2之间可使用的路由协议是BGP，该协议使用的运输层协议是TCP。</p></li>
<li><p>(4).
R4转发后MTU=800B，因此数据部分是8的整数倍，则数据部分为776B，首部20B。总长度1580B的IP数据报应划分为3个分片，第一个总长度为796B，片偏移0；第二个总长度为796B，片偏移为97；第三个长度为28B，片偏移为194。<strong>所以最小的分片IP数据报的长度字段为28，片偏移字段为194。</strong></p></li>
</ul>
<p><img src="https://p.sda1.dev/14/3e1c81743232344cc8defb04baa95434/2_47_4.png" alt="2_47_4.png" style="zoom:67%;"></p>
<ul>
<li><p>(5).
该IP数据报所去的目的网络地址不在R4的路由表中，R4不知道应从自己的哪个接口转发该IP数据报，<strong>因此将其丢弃，并且会给发送该IP数据报的源主机发送ICMP差错报告报文，具体为目的网络不可达。</strong></p></li>
<li><p>(6). <strong>4RTT</strong></p>
<p><img src="https://p.sda1.dev/14/5be4f36e071810c990fa098307956eb7/2_47_6.png" alt="2_47_6.png" style="zoom: 50%;"></p></li>
</ul></li>
</ul>
<hr>
<h2 id="年全国硕士研究生入学统一考试模拟题03"><strong>2024
年全国硕士研究生入学统一考试模拟题03</strong></h2>
<h3 id="一单项选择题第140小题每小题2分共80分下列每题给出的四个选项中只有一个选项最符合试题要求-2">一、<strong>单项选择题：第1</strong>~<strong>40小题，每小题2分，共80分。下列每题给出的四个选项中，只有一个选项最符合试题要求。</strong></h3>
<ul>
<li><ol start="33" type="1">
<li>以下有关OSI/RM的叙述中，<strong>错误</strong>的是（ ）。</li>
</ol>
<p>I. 10Base-T中“T”的含义，属于物理层范畴</p>
<ol start="2" type="I">
<li><p>物理地址、硬件地址以及MAC地址，都属于数据链路层范畴</p></li>
<li><p>网络层不涉及拥塞控制功能</p></li>
<li><p>运输层为其上层提供端到端的服务</p></li>
</ol>
<p>V. 应用层使用其下层提供的服务，在本层协议的控制下实现网络应用</p>
<p>A．I，III</p>
<p>B．II、V</p>
<p>C．I、II、IV</p>
<p>D．III、IV、V</p></li>
<li><ol start="34" type="1">
<li>假设下图所示的两个不同的编码波形表示的是同一串比特流，则该比特流是（
）。</li>
</ol>
<p><img src="https://p.sda1.dev/14/1e142157f5fc68040ace3caf817f5b13/3_34.png" alt="3_34.png" style="zoom: 50%;"></p>
<p>A. 011111100101</p>
<p>B. 111111100101</p>
<p>C. 000000011011</p>
<p>D. 111111100100</p></li>
<li><ol start="35" type="1">
<li>采用CRC进行检错，接收到的信息为101101001，生成多项式为<span class="math inline">\(G(X)=X^3+X^2+1\)</span>，则以下叙述<strong>错误</strong>的是（
）。</li>
</ol>
<p>A. 生成多项式各项系数构成的位串为1101</p>
<p>B. 接收到的信息的最后3位，即001为冗余码</p>
<p>C. 接收方认为收到的信息没有出现误码</p>
<p>D. 收发双方应使用相同的生成多项式</p></li>
<li><ol start="36" type="1">
<li>某个按MSS为1540B封装的TCP报文段被封装成IP数据报，假设TCP和IP都使用固定首部（没有选项或扩展部分），某个路由器收到该IP数据报后向MTU为800B的链路转发该IP数据报时进行了分片，且每个分片尽可能大，则最小的分片IP数据报的长度字段和片偏移字段的取值分别是（
）。</li>
</ol>
<p>A. 28，194</p>
<p>B. 784，97</p>
<p>C. 800，97</p>
<p>D. 800，0</p></li>
<li><ol start="37" type="1">
<li>下图给出的是一个移动IP的相关示例。移动主机A的归属网络地址、外地网络地址、永久地址以及漫游到外地网络后从外地代理获得的一个属于该外地网络的转交地址已标注在图中。假设图中的固定主机B要给处于外地网络的A发送一个IPv4数据报，则该IPv4数据报从B发送出来时的目的IP地址和从配置有归属代理的路由器转发出来时的目的IP地址分别是（
）。</li>
</ol>
<p><img src="https://p.sda1.dev/14/435ad86a839862cd01b94403fe7013f7/3_37.png" alt="3_37.png" style="zoom:50%;"></p>
<p>A. 218.75.230.16，175.1.1.1</p>
<p>B. 175.1.1.1，218.75.230.16</p>
<p>C. 218.75.230.16，0.0.0.0</p>
<p>D. 255.255.255.255， 218.75.230.16</p></li>
<li><ol start="38" type="1">
<li>包含在TCP报文段首部中但不包含在UDP用户数据报首部中的字段是（
）。</li>
</ol>
<p>A. 检验和</p>
<p>B. 源端口</p>
<p>C. 目的端口</p>
<p>D. 序号</p></li>
<li><ol start="39" type="1">
<li>以下关于TCP窗口与拥塞控制概念的叙述中，<strong>错误</strong>的是（
）。</li>
</ol>
<p>A. 接收窗口值通过TCP首部中的窗口字段通知数据的发送方</p>
<p>B. 发送窗口值=min[接收端窗口值，拥塞窗口值]</p>
<p>C. 拥塞窗口值是接收方根据网络拥塞情况确定的窗口值</p>
<p>D. 拥塞窗口值在开始时可以按指数规律增长</p></li>
<li><ol start="40" type="1">
<li>浏览器请求Web服务器中的某个万维网文档，若该文档除包含文本外，还有2个图片，则在使用HTTP/1.0时，需要建立TCP连接和UDP连接的次数分别是（
）。</li>
</ol>
<p>A. 3，0</p>
<p>B. 2，1</p>
<p>C. 0，2</p>
<p>D. 1，0</p></li>
</ul>
<h3 id="二综合应用题第4147-题共70-分-2">二、<strong>综合应用题：第41~47
题，共70 分。</strong></h3>
<ul>
<li><ol start="47" type="1">
<li>已知路由器R的路由表如下所示。</li>
</ol>
<p><img src="https://p.sda1.dev/14/e751919c75c761b60135b3738ef8b49f/3_47.png" alt="3_47.png" style="zoom: 60%;"></p>
<p>请回答以下问题：</p>
<p>（1）
试画出各网络、必要的路由器、特定主机的连接拓扑，标注出必要的IP地址和接口，对不能确定的情况请指明。</p>
<p>（2） 请给出路由器R的路由表中地址掩码这一列的点分十进制形式。</p>
<p>（3）
假设DHCP服务器的IP地址为192.168.0.60，网络192.168.0.128/26中的各主机需要从DHCP服务器获取各自的网络参数（例如IP地址和子网掩码等），则需要在路由器R上进行怎样的配置？为什么要进行这样的配置？</p>
<p>（4）
若IP地址为192.168.1.16的主机给IP地址为192.168.2.2的主机发送一个IP数据报，在不产生任何传输错误的情况下，为了使该IP数据报能够到达目的主机，其首部中TTL字段的初始值最少应设置为多少？该IP数据报从源主机发出时，其首部中源IP地址和目的IP地址分别是什么？该IP数据报从路由器R转发出来时，其首部中源IP地址和目的IP地址分别是什么、封装该IP数据报的以太网帧的源MAC地址和目的MAC地址分别是什么？</p></li>
</ul>
<h2 id="年全国硕士研究生入学统一考试模拟题03-答案"><strong>2024
年全国硕士研究生入学统一考试模拟题03</strong> 答案</h2>
<ul>
<li><ol start="33" type="1">
<li>A</li>
</ol>
<p>10Base-T中“T”的含义是双绞线，传输媒体不属于网络体系结构。因此，叙述I错误。</p>
<p>路由器会采用主动丢包策略，这表明网络层参与拥塞控制。因此，叙述III错误。</p></li>
<li><ol start="34" type="1">
<li>B</li>
</ol>
<p>曼彻斯特编码：每个码元的中间时刻电平发生跳变：正跳变表示1还是0，负跳变表示0还是1，可以自行定义。</p>
<p>差分曼彻斯特编码：
码元中间时刻的电平跳变仅表示时钟信号，而不表示数据。
数据的表示在于每一个码元开始处是否有电平跳变：无跳变表示1，有跳变表示0。</p></li>
<li><ol start="35" type="1">
<li>C</li>
</ol></li>
<li><ol start="36" type="1">
<li>A</li>
</ol>
<p><img src="/2023/12/01/%E8%AE%A1%E7%BD%91%E6%A8%A1%E6%8B%9F%E9%A2%98/3_37_.png" style="zoom: 50%;"></p></li>
<li><ol start="37" type="1">
<li>A</li>
</ol>
<p><img src="/2023/12/01/%E8%AE%A1%E7%BD%91%E6%A8%A1%E6%8B%9F%E9%A2%98/3_38_.png" style="zoom:50%;"></p></li>
<li><ol start="38" type="1">
<li>D</li>
</ol>
<p><img src="/2023/12/01/%E8%AE%A1%E7%BD%91%E6%A8%A1%E6%8B%9F%E9%A2%98/3_38.png" style="zoom:50%;"></p></li>
<li><ol start="39" type="1">
<li>C</li>
</ol>
<p>拥塞窗口值是<strong>发送方</strong>根据网络拥塞情况确定的窗口值。</p></li>
<li><ol start="40" type="1">
<li>A</li>
</ol>
<p>HTTP/1.0，HTTP/1.1，HTTP/2.0在运输层使用TCP，而HTTP/3.0在运输层使用UDP。</p></li>
<li><ol start="47" type="1">
<li><p>(1).</p>
<p><img src="/2023/12/01/%E8%AE%A1%E7%BD%91%E6%A8%A1%E6%8B%9F%E9%A2%98/3_47_1.png" style="zoom:50%;"></p></li>
</ol></li>
</ul>
<p>​ (2).</p>
<p><img src="/2023/12/01/%E8%AE%A1%E7%BD%91%E6%A8%A1%E6%8B%9F%E9%A2%98/3_47_2.jpg" style="zoom: 67%;"></p>
<p>​ (3).</p>
<p><img src="/2023/12/01/%E8%AE%A1%E7%BD%91%E6%A8%A1%E6%8B%9F%E9%A2%98/3_47_3.png" style="zoom:50%;"></p>
<p>​ (4).</p>
<p><img src="/2023/12/01/%E8%AE%A1%E7%BD%91%E6%A8%A1%E6%8B%9F%E9%A2%98/3_47_4.png" style="zoom: 50%;"></p>
<hr>
<h2 id="年全国硕士研究生入学统一考试模拟题04"><strong>2024
年全国硕士研究生入学统一考试模拟题04</strong></h2>
<h3 id="一单项选择题第140小题每小题2分共80分下列每题给出的四个选项中只有一个选项最符合试题要求-3">一、<strong>单项选择题：第1</strong>~<strong>40小题，每小题2分，共80分。下列每题给出的四个选项中，只有一个选项最符合试题要求。</strong></h3>
<ul>
<li><ol start="33" type="1">
<li>OSI参考模型自下而上的第3层完成的主要功能是（ C ）。</li>
</ol>
<p>A．数据表示和转换</p>
<p>B．差错控制</p>
<p>C．路由选择</p>
<p>D．会话管理</p></li>
<li><ol start="34" type="1">
<li>以下有关100Base-T快速以太网的叙述中，<strong>错误</strong>的是（ B
）。</li>
</ol>
<p>A. 网段的最大电缆长度为100m</p>
<p>B. 最大传输速率为100MB/s</p>
<p>C. 传输基带信号</p>
<p>D. 使用双绞线作为传输介质</p>
<p><img src="/2023/12/01/%E8%AE%A1%E7%BD%91%E6%A8%A1%E6%8B%9F%E9%A2%98/4_34.png" style="zoom:67%;"></p></li>
<li><ol start="35" type="1">
<li>数据链路层使用GBN协议，采用3个比特给帧编序号，发送方的发送窗口取最大值，不考虑流量控制。假设发送方发送的第一个帧的序号为0，并且将序号落入发送窗口内的所有帧都已经发送出去。当计时器超时时，若发送方只收到了1、3号帧的确认，则发送方需要重发的帧的数量以及发送窗口内的最后一个序号分别是（
C ）。</li>
</ol>
<p>A. 1，2</p>
<p>B. 2，0</p>
<p>C. 3，2</p>
<p>D. 7，0</p>
<p><img src="/2023/12/01/%E8%AE%A1%E7%BD%91%E6%A8%A1%E6%8B%9F%E9%A2%98/4_35.png" style="zoom:80%;"></p></li>
<li><ol start="36" type="1">
<li>主机A和B位于总线型以太网的两端，它们使用CSMA/CD协议和截断二进制指数退避算法进行重传。假设该网络中仅有这两台主机，则第11次重传失败的概率是（
C ）。</li>
</ol>
<p>A. 0</p>
<p>B. <span class="math inline">\((0.25)^{11}\)</span></p>
<p>C.$ (0.5)^{10}$</p>
<p>D. 1</p></li>
<li><ol start="37" type="1">
<li>若网络层要发送长度为21B的数据，将其封装成IP数据报时采用固定首部（没有选项部分），封装好的IP数据报通过以太网传输，则数据链路层将其封装成帧时，需要在帧的数据载荷部分额外填充的字节数量是（
B ）。</li>
</ol>
<p>A. 0</p>
<p>B. 5</p>
<p>C. 23</p>
<p>D. 1459</p></li>
<li><ol start="38" type="1">
<li>某路由器的路由表中有四项路由条目，各路由条目中的目的网络如下。</li>
</ol>
<p>路由条目1：目的网络地址为11.0.0.0/8</p>
<p>路由条目2：目的网络地址为11.1.0.0/16</p>
<p>路由条目3：目的网络地址为11.1.2.0/24</p>
<p>路由条目4：目的网络地址为0.0.0.0/0</p>
<p>若该路由器收到一个IP数据报，其目的地址为11.1.2.5，则转发该IP数据报时应当选择的路由条目是（
C ）。</p>
<p>A. 路由条目1</p>
<p>B. 路由条目2</p>
<p>C. 路由条目3</p>
<p>D. 路由条目4</p></li>
<li><ol start="39" type="1">
<li>TCP双方基于长度为2000m的链路传送数据，信号在该链路上的传播速率为200,000km/s，该链路的时延带宽积为1000b，如果充分利用链路的带宽且不考虑流量控制，则TCP出现序号绕回的周期约为（
B ）。</li>
</ol>
<p>A. 42.9s</p>
<p>B. 343.6s</p>
<p>C. 687.2s</p>
<p>D. 996.4s</p>
<p><img src="/2023/12/01/%E8%AE%A1%E7%BD%91%E6%A8%A1%E6%8B%9F%E9%A2%98/4_39.png" style="zoom:80%;"></p></li>
<li><ol start="40" type="1">
<li>某主机通过已知URL获取Web服务器中的某个Web页，若一开始主机不知道Web服务器的IP地址并且主机的ARP高速缓存是空的，则除HTTP外，主机需要使用的应用层协议和运输层协议有（
C ）。</li>
</ol>
<p>I. FTP</p>
<ol start="2" type="I">
<li><p>DNS</p></li>
<li><p>UDP</p></li>
<li><p>TCP</p></li>
</ol>
<p>V. ICMP</p>
<ol start="6" type="I">
<li>ARP</li>
</ol>
<p>A. I、IV</p>
<p>B. II、IV、VI</p>
<p>C. II、III、IV</p>
<p>D. II、IV、V、VI</p></li>
</ul>
<h3 id="二综合应用题第4147-题共70-分-3">二、<strong>综合应用题：第41~47
题，共70 分。</strong></h3>
<ul>
<li><ol start="47" type="1">
<li>假设用户在自己的主机上使用浏览器访问远程服务器上的某个Web页面，该Web页面非常简单，仅引用了同目录下的3个非常小的GIF图像，若忽略Web页面和这些GIF图像的传输时延，用户主机访问远程服务器的往返时间记为RTT，请回答以下问题。</li>
</ol>
<ol type="1">
<li>若使用HTTP/1.0标准协议且不考虑“TCP四报文挥手”过程，则从浏览器向Web服务器发出第一个请求报文开始到浏览器收到全部内容为止，需要的RTT数量至少是？</li>
<li>若使用HTTP/1.1协议以持续的非流水线方式，则从浏览器<strong>向Web服务器发出Web请求</strong>开始到浏览器收到全部内容为止，需要的RTT数量至少是？</li>
<li>若使用HTTP/1.1标准协议，则从浏览器向Web服务器发出HTTP请求报文开始到浏览器收到全部内容为止，需要的RTT数量<strong>至少</strong>是？</li>
<li>若根据Web页面引用对象的数量采用并行TCP连接的非持续HTTP，则从浏览器向Web服务器发出第一个请求报文开始到浏览器收到全部内容为止，需要的RTT数量至少是？</li>
</ol>
<p><strong>HTTP/1.0标准协议不支持持续连接和流水线。</strong></p>
<p><img src="/2023/12/01/%E8%AE%A1%E7%BD%91%E6%A8%A1%E6%8B%9F%E9%A2%98/4_47.png" style="zoom:80%;"></p></li>
</ul>
<ol type="1">
<li>8</li>
<li></li>
</ol>
<p><img src="/2023/12/01/%E8%AE%A1%E7%BD%91%E6%A8%A1%E6%8B%9F%E9%A2%98/4_47_2.png" style="zoom: 50%;"></p>
<ol start="3" type="1">
<li></li>
</ol>
<p><img src="/2023/12/01/%E8%AE%A1%E7%BD%91%E6%A8%A1%E6%8B%9F%E9%A2%98/4_37_4.png" style="zoom:50%;"></p>
<ol start="4" type="1">
<li></li>
</ol>
<p><img src="/2023/12/01/%E8%AE%A1%E7%BD%91%E6%A8%A1%E6%8B%9F%E9%A2%98/4_47_4.png" style="zoom:50%;"></p>
]]></content>
      <categories>
        <category>研究生入学考试</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计网</tag>
      </tags>
  </entry>
  <entry>
    <title>计网每日一题</title>
    <url>/2023/09/15/%E8%AE%A1%E7%BD%91%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</url>
    <content><![CDATA[<h2 id="day1-9月6日">day1 9月6日</h2>
<p><img src="https://p.sda1.dev/13/3826706c5f7f985eb5ed6a510916b81e/day1解析.png" style="zoom:67%;"></p>
<p><img src="https://p.sda1.dev/13/ae27e446c4f39bcc62f7ce4bc0515d17/day1.png" style="zoom: 67%;"></p>
<h2 id="day2-9月7日">day2 9月7日</h2>
<p><img src="https://p.sda1.dev/13/e0f3b1cb6ef45301b3415298ebc46abc/day2.png" style="zoom: 67%;"></p>
<p><img src="https://p.sda1.dev/13/26e84f1f12abcbea3879bb6719bd4969/day2解析.png" style="zoom:67%;"></p>
<h2 id="day3-9月8日">day3 9月8日</h2>
<p><img src="https://p.sda1.dev/13/13944e69af8e0ac63e42572e0552ce31/day3.png" style="zoom:67%;"></p>
<p><img src="https://p.sda1.dev/13/bc78ef73a3c4ac8251d527a1ef68962c/day3解析.png" style="zoom:67%;"></p>
<h2 id="day4-9月9日">day4 9月9日</h2>
<p><img src="https://p.sda1.dev/13/245deb9873831f2a4f0a585d2d3316cb/day4.png" style="zoom: 67%;"></p>
<p><img src="https://p.sda1.dev/13/439db40d097118747c5c994e60f8d8b4/day4解析.png" style="zoom:67%;"></p>
<h2 id="day5-9月10日">day5 9月10日</h2>
<p><img src="https://p.sda1.dev/13/b39ba3bc619ca86392120e5d8530f2ee/day5解析.png" style="zoom:80%;"></p>
<h2 id="day6-9月11日">day6 9月11日</h2>
<p><img src="https://p.sda1.dev/13/fd343bd932885d77cd993dda5a7fae04/day6.png" style="zoom:80%;"></p>
<h2 id="day7-9月12日">day7 9月12日</h2>
<p><img src="https://p.sda1.dev/13/c8b596cb4b5ba8c2122cb78265866996/day7.png" style="zoom:80%;"></p>
<h2 id="day8-9月13日">day8 9月13日</h2>
<p><img src="https://p.sda1.dev/13/efe3abf321337481d3abef8abf8e0fd9/da8.png" style="zoom:80%;"></p>
<p>TTL字段经过一个路由器减一</p>
<h2 id="day9-9月14日">day9 9月14日</h2>
<p><img src="https://p.sda1.dev/13/567ed9cb6a590e40cc43471f53447edc/day9.png" style="zoom:80%;"></p>
<p><img src="https://p.sda1.dev/13/d84e243dbd5cf4b1f4db5b736e75cc89/day9解析.png" style="zoom:80%;"></p>
<h2 id="day10-9月15日">day10 9月15日</h2>
<p><img src="https://p.sda1.dev/13/85c4ee948fc325f8ad2270269c5971ce/day10.png" style="zoom:80%;"></p>
<h2 id="day11-9月16日">day11 9月16日</h2>
<p><img src="https://p.sda1.dev/13/9d9cb429e857ca239214ee84e77b5541/day11.png" style="zoom:80%;"></p>
<h2 id="day12-9月17日">day12 9月17日</h2>
<p><img src="https://p.sda1.dev/13/e3257293467c30c53fd480ed2d3aed53/day12.png" alt="d" style="zoom:80%;"></p>
<p><img src="https://p.sda1.dev/13/bb5efd370a561e13a608ef8d890d41f6/day12j.png" style="zoom:80%;"></p>
<h2 id="day13-9月18日">day13 9月18日</h2>
<p><img src="https://p.sda1.dev/13/e5cd6c8478656bd931331795623fe818/day13.png" style="zoom:80%;"></p>
<p><img src="https://p.sda1.dev/13/d6fb806688c8268d94ef493babfca777/day13j.png" style="zoom:80%;"></p>
<h2 id="day14-9月19日">day14 9月19日</h2>
<p><img src="https://p.sda1.dev/13/2659f9e56b2fd8147367d5e219f20148/919.png" style="zoom:80%;"></p>
<h2 id="day15-9月20日">day15 9月20日</h2>
<p><img src="https://p.sda1.dev/13/bcb0657cbb838d7d5631721590f2861e/920.png" style="zoom:80%;"></p>
<p><img src="https://p.sda1.dev/13/530c7f2761d190777c5beaeb9931a00f/9201.png" style="zoom:80%;"></p>
<h2 id="day16-9月21日">day16 9月21日</h2>
<p><img src="https://p.sda1.dev/14/217025d6633b49c8b1f0d9bbad5c2a47/16.jpg" style="zoom:80%;"></p>
<h2 id="day17-9月22日">day17 9月22日</h2>
<p><img src="https://p.sda1.dev/14/5f236e1bab95a73c7dab28fc2f76d38d/17.jpg" style="zoom:80%;"></p>
<h2 id="day18-9月23日">day18 9月23日</h2>
<p><img src="https://p.sda1.dev/14/fbaab7001a2e3136b971b2f92fc8a113/18.jpg" style="zoom:80%;"></p>
<h2 id="day19-9月24日">day19 9月24日</h2>
<p><img src="https://p.sda1.dev/14/357e5daa5ef7b1209eccd2c751c0b5d4/19.jpg" style="zoom:80%;"></p>
<h2 id="day20-9月25日">day20 9月25日</h2>
<p><img src="https://p.sda1.dev/14/765944aaa2126007a6f3c373a344d9e6/20.jpg" style="zoom:80%;"></p>
<h2 id="day21-9月26日">day21 9月26日</h2>
<p><img src="https://p.sda1.dev/14/491d9610790c10ccd8c6d7fd082f0e58/21.jpg" style="zoom:80%;"></p>
<h2 id="day22-9月27日">day22 9月27日</h2>
<p><img src="https://p.sda1.dev/14/3fa33aa6907222e389cb8d0675a41ed5/22.jpg" style="zoom:80%;"></p>
<h2 id="day23-10月4日">day23 10月4日</h2>
<p><img src="https://p.sda1.dev/14/142106b27b0ea40a68f2eb9106a204e6/23.jpg" style="zoom:50%;"></p>
<p><img src="https://p.sda1.dev/14/8bfc27dd1dad0053ef61ec6023104bfa/22_.jpg" style="zoom: 80%;"></p>
<h2 id="day24-10月5日">day24 10月5日</h2>
<p><img src="https://p.sda1.dev/14/87af403f127657a2874a99786f9c7170/24.jpg" style="zoom:80%;"></p>
<h2 id="day25-10月6日">day25 10月6日</h2>
<p><img src="https://p.sda1.dev/14/7d554fdf639df33d83ed8fda0fcbe81d/25.jpg" style="zoom:80%;"></p>
<h2 id="day26-10月7日">day26 10月7日</h2>
<p><img src="https://p.sda1.dev/14/07c816c53d93d70f6ce0a66f81e7f998/26.jpg" style="zoom:67%;"></p>
<p>IP地址的后23位与mac地址进行映射</p>
<h2 id="day27-10月8日">day27 10月8日</h2>
<p><img src="https://p.sda1.dev/14/1d21893a493c5712eefc02099887cf00/27.jpg" style="zoom:67%;"></p>
<p><img src="https://p.sda1.dev/14/073cf5a5452688abb987f29fad6a91d9/27_.jpg" style="zoom:67%;"></p>
<h2 id="day28-10月9日">day28 10月9日</h2>
<p><img src="https://p.sda1.dev/14/6262dd16ce739522ba81220492abf41b/28.jpg" style="zoom:80%;"></p>
<h2 id="day29-10月10日">day29 10月10日</h2>
<p><img src="https://p.sda1.dev/14/e8aadbd1df089e9cde37fda08dfa0fdc/29.jpg" alt="29.jpg" style="zoom:67%;"></p>
<p><img src="https://p.sda1.dev/14/cf800dfa0480c30ef23cc38435569b17/29_.jpg"></p>
<h2 id="day30-10月11日">day30 10月11日</h2>
<p><img src="https://p.sda1.dev/14/ee93c3965b4705f0a4b10bd6aa762bbf/30.jpg" style="zoom:67%;"></p>
<p><img src="https://p.sda1.dev/14/49f1dc5411da92fe4eb44e683388a25a/30_.jpg" style="zoom:67%;"></p>
<h2 id="day31-10月12日">day31 10月12日</h2>
<p><img src="https://p.sda1.dev/14/55a3dcd1689747589b1fd1c2a0a38c56/31.jpg" style="zoom:80%;"></p>
<h2 id="day32-10月13日">day32 10月13日</h2>
<p><img src="https://p.sda1.dev/14/11c9f3d7e441725f09925dcde57a2a1e/32.jpg" alt="32.jpg" style="zoom:67%;"></p>
<p><img src="https://p.sda1.dev/14/e50674b499bd486686fe9523c00a8fa2/32_.jpg" alt="32_.jpg" style="zoom:67%;"></p>
<h2 id="day33-10月14日">day33 10月14日</h2>
<p><img src="https://p.sda1.dev/14/1862a5b5ff535dc6ddaa97bba92be4c3/33.jpg" style="zoom:67%;"></p>
<p><img src="https://p.sda1.dev/14/587cf00f90fc3ea0ce87ef94471c855c/33_.jpg" style="zoom:67%;"></p>
<h2 id="day34-10月15日">day34 10月15日</h2>
<p><img src="https://p.sda1.dev/14/458913835e5b433084b2fa2ba0f606de/34.jpg" alt="34.jpg" style="zoom:67%;"></p>
<p><img src="https://p.sda1.dev/14/2e00d8c33c8341f882baa69a1999787a/34_.jpg" alt="34_.jpg" style="zoom:67%;"></p>
<h2 id="day35-10月16日">day35 10月16日</h2>
<p><img src="https://p.sda1.dev/14/3e91dfdf5a1ca7ef795d30ffaa03f70d/35.jpg" alt="35.jpg" style="zoom:80%;"></p>
<h2 id="day36-10月17日">day36 10月17日</h2>
<p><img src="https://p.sda1.dev/14/6fc22882b30b8e57c3df88c70e8cd0d8/36.jpg" alt="36.jpg" style="zoom:80%;"></p>
<h2 id="day37-10月18日">day37 10月18日</h2>
<p><img src="https://p.sda1.dev/14/274c423406a2daa981b34ff87b8248d2/37.jpg" alt="37.jpg" style="zoom:80%;"></p>
<h2 id="day38-10月19日">day38 10月19日</h2>
<p><img src="https://p.sda1.dev/14/7f3189db95699d2db85b60085624c7ad/38.jpg" alt="38.jpg" style="zoom:80%;"></p>
<h2 id="day39-10月20日">day39 10月20日</h2>
<p><img src="https://p.sda1.dev/14/7ace162519cb145633cba9605ba0f6d4/39.jpg" alt="39.jpg" style="zoom:67%;"></p>
<p><img src="https://p.sda1.dev/14/22a37e27601f26a5bd80534330379ec6/39_.jpg" alt="39_.jpg" style="zoom:67%;"></p>
<p><strong>第二段是带数据的报文段，但不叫数据报文段，所以必须从实际第三段算起。</strong></p>
<h2 id="day40-10月21日">day40 10月21日</h2>
<p><img src="https://p.sda1.dev/14/3aa110932043c6f8881d45f210a08093/40.jpg" alt="40.jpg" style="zoom:67%;"></p>
<p><img src="https://p.sda1.dev/14/565c7d8411531209d4ce743fe95dbaba/40_.jpg" alt="40_.jpg" style="zoom:67%;"></p>
<h2 id="day41-10月22日">day41 10月22日</h2>
<p><img src="https://p.sda1.dev/14/c7a05b69ebc85459cfb73ce637019e78/41.jpg" alt="41.jpg" style="zoom:80%;"></p>
<h2 id="day42-10月23日">day42 10月23日</h2>
<p><img src="https://p.sda1.dev/14/0d812311329d4f2df53120f10ebf2beb/42.jpg" alt="42.jpg" style="zoom:80%;"></p>
<h2 id="day43-10月24日">day43 10月24日</h2>
<p><img src="https://p.sda1.dev/14/859bdbe767feed4010d31aa952bade1c/43.jpg" alt="43.jpg" style="zoom:67%;"></p>
<p><img src="https://p.sda1.dev/14/777a757228b13522b114491578433220/43_.jpg" alt="43_.jpg" style="zoom:67%;"></p>
<h2 id="day44-10月25日">day44 10月25日</h2>
<p><img src="https://p.sda1.dev/14/4556237393eb499ff25a9863c7440d4b/44.jpg" alt="44.jpg" style="zoom:80%;"></p>
<p><img src="https://p.sda1.dev/14/aab69db8120a69b6100947301cf16254/44_.jpg" alt="44_.jpg" style="zoom:80%;"></p>
<h2 id="day45-10月26日">day45 10月26日</h2>
<p><img src="https://p.sda1.dev/14/9fedbeb6e0d5dc1241ece81d6191548b/45.jpg" alt="45.jpg" style="zoom:80%;"></p>
<h2 id="day46-10月27日">day46 10月27日</h2>
<p><img src="https://p.sda1.dev/14/5ea5d1188d3123ef7e9f510b3ea0f87f/46.jpg" alt="46.jpg" style="zoom:80%;"></p>
<h2 id="day47-10月28日">day47 10月28日</h2>
<p><img src="https://p.sda1.dev/14/8b784202f47c7433fe3cf48730ffcb31/47.jpg" alt="47.jpg" style="zoom:80%;"></p>
<p><img src="https://p.sda1.dev/14/70d9e71b255938bab8b7c24eb9f3b3e8/47_.jpg" alt="47_.jpg" style="zoom:80%;"></p>
<h2 id="day48-10月29日">day48 10月29日</h2>
<p><img src="https://p.sda1.dev/14/677d591e81e6562f1c739e26c1cf6ca7/48.jpg" alt="48.jpg" style="zoom:67%;"></p>
<p><img src="https://p.sda1.dev/14/f6a63cd252d2f82213c870cc59617b41/48_.jpg" alt="48_.jpg" style="zoom:67%;"></p>
<h2 id="day49-10月30日">day49 10月30日</h2>
<p><img src="https://p.sda1.dev/14/3a0c7620fc215e4057cada613b27ffc5/49.jpg" alt="49.jpg" style="zoom:80%;"></p>
<h2 id="day50-10月31日">day50 10月31日</h2>
<p><img src="https://p.sda1.dev/14/862ecb947b9f8565f78537e889d6bc18/50.jpg" alt="50.jpg" style="zoom:80%;"></p>
<h2 id="day51-11月1日">day51 11月1日</h2>
<p><img src="https://p.sda1.dev/14/584d33a8c0efe6f6cb4820db63b2425e/51.jpg" alt="51.jpg" style="zoom:67%;"></p>
<p><img src="https://p.sda1.dev/14/aad26e927ee04890a03d0d624e374778/51_.jpg" alt="51_.jpg" style="zoom:67%;"></p>
<h2 id="day52-11月2日">day52 11月2日</h2>
<p><img src="https://p.sda1.dev/14/b431628ddc3d1fc8d7096c669260779b/52.jpg" alt="52.jpg" style="zoom:67%;"></p>
<h2 id="day53-11月10日">day53 11月10日</h2>
<p><img src="https://p.sda1.dev/14/b2a891f970eb84d81348bdf9afe688ec/53.jpg" alt="53.jpg" style="zoom: 80%;"></p>
<p><img src="https://p.sda1.dev/14/650a06cefaaadb531827f1a945193c12/53_.jpg" alt="53_.jpg" style="zoom: 80%;"></p>
<h2 id="day54-11月11日">day54 11月11日</h2>
<p><img src="https://p.sda1.dev/14/1e7550c607b29888545d2107690389e1/54.jpg" alt="54.jpg" style="zoom:80%;"></p>
<h2 id="day55-11月12日">day55 11月12日</h2>
<p><img src="https://p.sda1.dev/14/87826d73a831c73c757ea73c2c189ff9/55_.jpg" alt="55_.jpg" style="zoom:80%;"></p>
<h2 id="day56-11月13日">day56 11月13日</h2>
<p><img src="https://p.sda1.dev/14/07149ab2870b7aafb62cbe5e79db018e/56.jpg" alt="56.jpg" style="zoom:80%;"></p>
<h2 id="day57-11月14日">day57 11月14日</h2>
<p><img src="https://p.sda1.dev/14/4e78a8f3db14ef6c30bdb959741f3376/57.jpg" alt="57.jpg" style="zoom:80%;"></p>
<h2 id="day58-11月15日">day58 11月15日</h2>
<p><img src="https://p.sda1.dev/14/fb1cbdf9bb9fbafac2bd788f77601367/58.jpg" alt="58.jpg" style="zoom:80%;"></p>
<h2 id="day59-11月16日">day59 11月16日</h2>
<p><img src="https://p.sda1.dev/14/c733d55cea2cf91d2899dace34674f00/59.jpg" alt="59.jpg" style="zoom:67%;"></p>
<p><img src="https://p.sda1.dev/14/e4015576d7573be9c591f57abb376bfd/59_.jpg" alt="59_.jpg" style="zoom:67%;"></p>
<h2 id="day60-11月17日">day60 11月17日</h2>
<p><img src="https://p.sda1.dev/14/70cdedfd3c93f9ba595c52c7d847a44a/60.jpg" alt="60.jpg" style="zoom:67%;"></p>
<p><img src="https://p.sda1.dev/14/fb0b6a80eba884cf89bd89c802ee1b29/60_.jpg" alt="60_.jpg" style="zoom:67%;"></p>
<h2 id="day61-11月18日">day61 11月18日</h2>
<p><img src="https://p.sda1.dev/14/8310d54fb590c656f60233ec73804254/61.jpg" alt="61.jpg" style="zoom:80%;"></p>
<p><img src="https://p.sda1.dev/14/01770f372f3d24494e159b7a956b6b02/61_.jpg" alt="61_.jpg" style="zoom:80%;"></p>
<h2 id="day62-11月19日">day62 11月19日</h2>
<p><img src="https://p.sda1.dev/14/50a413d62f5e99299d060be6f5c0d04a/62.jpg" alt="62.jpg" style="zoom:80%;"></p>
<h2 id="day63-11月20日">day63 11月20日</h2>
<p><img src="https://p.sda1.dev/14/687ab8528c889563b09c6deab31399f9/63.jpg" alt="63.jpg" style="zoom:67%;"></p>
<p><img src="https://p.sda1.dev/14/2998adb431d10f06ef0f441c969ca0a3/63_.jpg" alt="63_.jpg" style="zoom:67%;"></p>
<h2 id="day64-11月21日">day64 11月21日</h2>
<p><img src="https://p.sda1.dev/14/b6ebeb3f8eed1f07df7f7107e6131d86/64.jpg" alt="64.jpg" style="zoom:67%;"></p>
<p><img src="https://p.sda1.dev/14/a9a1a1f659139617d2009b4533a11606/64_.jpg" alt="64_.jpg" style="zoom:67%;"></p>
<h2 id="day65-11月22日">day65 11月22日</h2>
<p><img src="https://p.sda1.dev/14/ed86c0234fef7f41cfac0cbdcf7f2c17/65.jpg" alt="65.jpg" style="zoom:80%;"></p>
<h2 id="day66-11月23日">day66 11月23日</h2>
<p><img src="https://p.sda1.dev/14/e1e9415020eba265e4ff6f38dc80419a/66.jpg" alt="66.jpg" style="zoom:67%;"></p>
<p><img src="https://p.sda1.dev/14/32deef7527ed159313f77ca3d893b94f/65_.jpg" alt="65_.jpg" style="zoom:67%;"></p>
<h2 id="day67-11月24日">day67 11月24日</h2>
<p><img src="https://p.sda1.dev/14/b3f100fc05f11d85aced0974ad63d7d2/67.jpg" alt="67.jpg" style="zoom:80%;"></p>
<h2 id="day68-11月25日">day68 11月25日</h2>
<p><img src="https://p.sda1.dev/14/1788afff6071f1a36594fe5205baaf91/68.jpg" alt="68.jpg" style="zoom:80%;"></p>
<h2 id="day69-11月26日">day69 11月26日</h2>
<p><img src="https://p.sda1.dev/14/8d7f2054913383661703c82a5d622218/69.jpg" alt="69.jpg" style="zoom:80%;"></p>
<h2 id="day70-11月27日">day70 11月27日</h2>
<p><img src="https://p.sda1.dev/14/33d924bbed9ea03024a06393e00f4444/70.jpg" alt="70.jpg" style="zoom:80%;"></p>
<h2 id="day71-11月28日">day71 11月28日</h2>
<p><img src="https://p.sda1.dev/14/7428a417684ac2c0493fb5351c558a9e/71.jpg" alt="71.jpg" style="zoom:67%;"></p>
<p><img src="https://p.sda1.dev/14/ef67e821bd2175c1528897e5fb3a9dd5/71_.jpg" alt="71_.jpg" style="zoom:67%;"></p>
<h2 id="day72-11月29日">day72 11月29日</h2>
<p><img src="https://p.sda1.dev/14/6756dd0406633d59d806dab2e7e63b67/72.jpg" alt="72.jpg" style="zoom:80%;"></p>
<h2 id="day73-11月30日">day73 11月30日</h2>
<p><img src="https://p.sda1.dev/14/eb93cbaa09435df8b0010132069ff5b2/73.jpg" alt="73.jpg" style="zoom:80%;"></p>
]]></content>
      <categories>
        <category>研究生入学考试</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计网</tag>
      </tags>
  </entry>
</search>
